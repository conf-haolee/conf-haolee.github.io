{"meta":{"title":"cvhao's library","subtitle":"","description":"haolees blogs","author":"haolee","url":"http://example.com","root":"/"},"pages":[{"title":"archives","date":"2023-04-09T03:31:38.000Z","updated":"2023-04-09T03:31:38.847Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-04-09T03:31:22.000Z","updated":"2023-04-09T03:31:22.625Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-11-09T04:15:24.433Z","updated":"2024-11-09T04:15:24.420Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"⚠️ 由于该网站部署在Github pages上，需要科学上网，否则很多图片加载不出来，影响阅读体验，敬请谅解。 关于作者 学习经历：广西师范大学 软件工程学硕（2022-2025） 研究方向：机器视觉 实习经历：曾在两家机器视觉公司分别实习半年和一年。 项目经历： 工业密封圈视觉计数 conf-haolee&#x2F;VisionCounting O型圈缺陷检测 conf-haolee&#x2F;O-ringDefectDetection 个人简介：致力于通过机器视觉算法和技术让机器“看见”和“理解”世界。 生活爱好：羽毛球，摄影，弹吉他"},{"title":"catagories","date":"2023-04-09T03:30:58.000Z","updated":"2023-04-09T03:30:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"视频学习资料","date":"2023-04-12T12:33:07.000Z","updated":"2024-11-09T04:18:02.325Z","comments":true,"path":"notes/index.html","permalink":"http://example.com/notes/index.html","excerpt":"","text":"这里汇总了一些视频学习资料，方便回顾。 一 专业知识（计算机基础）101 计算机应用基础102 操作系统103 计算机组成原理104 计算机网络105 数据结构与算法106 编程基础C&#x2F;C++黑马程序员 入门视频 【宝藏 C++侯捷老师全系列八部曲】 python拉钩教育 -2021最新 Python 基础实战（收藏版）哔哩哔哩_bilibili 【收藏版】兼职2小时赚8000的 Python爬虫秘籍，2021B站最全的保姆级教程（网络爬虫+办公自动化+数据分析）_哔哩哔哩_bilibili 107 人工智能机器学习【斯坦福大学】CS229 机器学习 · 2018年（完结·中英字幕·机翻） 深度学习PyTorch深度学习快速入门教程（绝对通俗易懂！）【小土堆】 计算机视觉【经典课程】计算机视觉-CS231n [斯坦福|高清|中文字幕] 计算机视觉与深度学习 北京邮电大学 鲁鹏 清晰版合集（完整版） YOLOv5 最速上手 ✦ 40分钟带你训练自定义模型 python openCv 【李超】慕课网 OpenCV入门到进阶_实战三大典型项目-慕课网 (imooc.com) NLP108 计算机图形学二 工作需要（机器视觉）微软基础类库 MFC【20W播放】新版MFC编程全套精品视频 跨平台C++应用开发框架 Qt爱编程的大丙 Qt 手撕Qt5图形视图项目实战，GraphicsView框架结构分析。场景坐标QGraphicsScene类。视图坐标QGraphicsView类。 C# 三 个人兴趣吉他指弹 羽毛球单打精彩合集 经典电影资源 经典影视"},{"title":"书单与网站分享","date":"2023-04-12T12:39:43.000Z","updated":"2024-11-18T02:15:45.995Z","comments":true,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":"> 这里汇总了一些有价值的书籍资料，以网盘形式共享，方便以后回顾。 自学网站 地址 备注 CS自学指南 (csdiy.wiki) 小林coding (xiaolincoding.com) 本站简介 labuladong 的算法笔记 一 专业知识408 -1计算机组成原理408-2 计算机网络【计算机网络 谢希仁】 数据结构与算法 408-3 数据结构本站简介 | labuladong 的算法笔记 大话数据结构 408-4 操作系统深入理解计算机系统 编程语言基础C&#x2F;C++ C++ 改善程序与设计的55个具体做法 第3版 ([美] Scott Meyers 侯捷 Python《python编程 从入门到实战》 python之路V2.0 《利用python进行数据分析》 机器学习：【统计学习方法】 李沐：《动手学深度学习》 — 动手学深度学习 2.0.0 documentation (d2l.ai) 机器学习 西瓜书 【机器学习实战】 计算机视觉：数字图像处理 &lt;数字图像处理 第四版冈萨雷斯&gt; &lt;局部不变性特征与描述&gt; 计算机视觉40例 从入门到深度学习 机器视觉领域&lt;halcon 图像处理&gt; &lt;python opencv图像处理&gt; 三 课余兴趣&lt;给青年的十二封信 (朱光潜) &gt; &lt;数学之美&gt; &lt;浪潮之巅&gt; &lt;乔布斯传&gt; &lt;娱乐至死&gt; 书籍来源： zlibrary"}],"posts":[{"title":"中国大陆机器视觉工程师岗位未来三年前景分析报告 (2025-2028)","slug":"中国大陆机器视觉工程师岗位未来三年前景分析报告 (2025-2028)","date":"2025-04-07T13:59:20.306Z","updated":"2025-04-07T14:09:51.377Z","comments":true,"path":"2025/04/07/中国大陆机器视觉工程师岗位未来三年前景分析报告 (2025-2028)/","link":"","permalink":"http://example.com/2025/04/07/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B2%97%E4%BD%8D%E6%9C%AA%E6%9D%A5%E4%B8%89%E5%B9%B4%E5%89%8D%E6%99%AF%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%20(2025-2028)/","excerpt":"","text":"引言机器视觉工程师是近年来中国大陆科技领域的热门职业，承担着将计算机视觉技术应用于工业制造、医疗、交通、安防、新能源等行业的重任。在当前宏观经济增速放缓但产业升级加速的背景下，国家政策正引导制造业向智能化转型，人工智能与实体经济深度融合。机器视觉作为“工业之眼”，在提高生产效率、降低成本和实现智能化方面具有不可替代的价值 。本报告将从宏观环境和政策、行业应用前景、岗位优劣势、技能要求和职业规划五个方面，对未来三年机器视觉工程师岗位的发展趋势进行深入分析，并为新入行者提供指导建议。 宏观环境与政策导向的影响中国宏观经济正处于结构调整期，传统低端制造业增速放缓，但以人工智能为代表的新兴技术被寄予厚望以带动经济新动能。政府在“十四五”规划中明确提出发展“智能制造”“数字经济”等战略，促进工业数字化转型。这为机器视觉行业创造了良好的政策环境。尤其在制造业领域，机器视觉相关技术被纳入各级政府的扶持计划，如工业互联网、智能工厂示范项目等，使企业有动力投入视觉自动化改造。 与此同时，“国产替代”成为科技产业的关键词，国家鼓励自主可控的技术和产品。机器视觉领域过去由海外厂商（如康耐视、基恩士等）主导，但近年本土企业迅速崛起 。**2023年中国机器视觉产业综述 **自2018年以来，中国机器视觉市场中本土品牌的份额从不到50%提高到2023年的约63%，反映出国产厂商的竞争力显著增强 。这一趋势离不开政策支持，例如工信部组织人工智能“揭榜挂帅”项目，聚焦关键技术攻关。2022年由天准公司承担的“高精度工业视觉智能检测系统”项目成功入选工信部人工智能产业创新任务榜单，旨在突破核心技术并加速新产品落地应用 。政府通过此类专项和补贴，培育出海康机器人、凌云光、大恒图像、奥普特等一批本土机器视觉领军企业，提升了产业自主可控性。可以预见，在政策东风下，机器视觉行业将在未来几年保持较快增长。前瞻产业研究院预测到2029年中国机器视觉市场规模将超过1000亿元人民币 ，远高于2022年的170.5亿元 。宏观经济环境虽有周期波动，但国家坚定推进制造业升级和科技创新的方针将持续为机器视觉发展保驾护航。预见2024：《2024年中国机器视觉产业全景图谱》 机器视觉在重点行业的应用场景与增长潜力机器视觉技术目前已广泛渗透到制造业和各行各业，但不同领域的发展成熟度各异。总体来看，在汽车制造、3C电子、半导体等领域机器视觉应用渗透率较高；在包装、医疗、制药、智能交通等领域渗透率中等；而在纺织、烟草等传统行业渗透率相对较低 。这既表明前者已经取得显著成效，也意味着后者仍有巨大的增长潜力。以下是机器视觉在中国几大重点行业的应用场景及其前景分析： ​ 工业制造（工业自动化与智能制造）：这是机器视觉应用最成熟的领域。目前广泛用于产线上的产品质量检测、尺寸测量、装配定位、缺陷识别等。例如电子产品和汽车零部件的瑕疵检测，以机器视觉系统代替人工目检，大幅提升了良品率和效率 。随着劳动力成本上升和用工短缺，制造业对视觉检测和机器人视觉引导需求旺盛，未来机器视觉将在更多工序实现100%自动化检测，推动无人工厂的实现。近年物流仓储和新能源制造的蓬勃发展也带动了视觉检测设备的需求增长 。例如在锂电池、电动车零部件生产中，引入高速视觉分拣和缺陷检测，以保证产品一致性并提高产线效率。 ​ 医疗：机器视觉（计算机视觉）在医疗领域的应用正快速扩展，主要体现在医学影像分析和辅诊决策方面。诸多初创公司和医院合作开发基于深度学习的医学影像识别系统，用于X光&#x2F;CT&#x2F;MRI等影像的病灶识别、肿瘤检测、病理切片分析等 。这些AI诊断工具可以提高医生诊断的准确率和效率，缓解优质医疗资源不足的问题。目前国内已有40多家公司提供医学影像AI服务，功能涵盖病灶标注、放疗靶区勾画、三维重建等 。随着监管政策的完善和医院接受度提高，预计未来三年医疗计算机视觉市场将以30%以上的年复合增长率快速增长 。特别是在老龄化趋势下，医疗影像智能分析、手术机器人的视觉导航等都有巨大潜力。 ​ 交通与出行：在智慧交通领域，机器视觉主要用于车辆与行人检测、交通流量统计、违章识别和道路安全监测等。例如车牌识别系统早已普及于高速公路和城市道路的电子眼，交通事件检测算法可以自动发现事故、拥堵并报警。在城市治理中，大规模视频监控结合视觉算法实现智能交通管理。更重要的是，在自动驾驶和高级驾驶辅助系统（ADAS）中，机器视觉是核心感知技术之一。摄像头作为自动驾驶汽车的“眼睛”，需要识别车道线、交通标志、行人和障碍物。中国新能车辆和智能汽车产业的高速发展为计算机视觉人才打开了新的广阔赛道。智能驾驶视觉算法工程师成为炙手可热的职位之一，据统计其人才供需比仅0.38，职位空缺远多于求职者 。可以预见，未来3-5年随着L2-L4级自动驾驶功能逐步量产落地，视觉感知算法将在汽车领域保持高速迭代和应用扩张。 ​ 安防：安防监控是中国计算机视觉技术大规模商用的起点和优势领域之一。基于摄像头的人脸识别、行为分析等系统已广泛部署于城市安防、金融安保、社区管理等场景。平安城市建设催生了海量的视频监控需求，通过视觉AI实现对异常行为、可疑人物的自动预警。国内诸如海康威视、商汤科技等企业在安防视觉算法上世界领先。随着对公共安全和智慧城市要求的提高，安防领域仍将稳步扩大对更高精度、更快响应的视觉技术的需求，包括跨镜追踪、多目标识别等高级功能。在政策层面，《数据安全法》《个人信息保护法》等法规的实施也将引导安防视觉技术朝着更注重隐私保护和数据合规的方向发展，比如采用边缘计算、本地识别等方案来避免数据滥用。 ​ 新能源：新能源行业主要指新能源制造业和新能源应用两个方面。在制造业端，以太阳能光伏、风电和锂电池生产为代表的新兴产业对机器视觉有强烈需求。例如光伏硅片生产中的表面瑕疵检测、分类分选，锂电池极片的缺陷检测和尺寸测量等，都需要高速高精度的视觉系统来保障产品质量 。这些领域产品技术迭代快、产能扩张迅猛，对视觉检测设备的性能提出了持续升级的要求。数据显示，2022年中国3D机器视觉市场规模约为17.75亿元，同比增长54.21%，显著高于传统2D视觉增速 。这表明在新能源等需要三维测量的场景（如电池封装、风机叶片检测），3D视觉正成为新的增长点。在应用端，新能源车配备的智能驾驶、工厂中的机器人巡检等，也是机器视觉大显身手之处。可以预见，未来随着中国加速能源转型，围绕新能源生产和应用的视觉技术解决方案将层出不穷，市场需求保持高增长。 综上，机器视觉在各行业的应用深度和广度都在不断拓展。中国正成为全球机器视觉应用最活跃的地区之一，相关需求几乎覆盖国民经济各个领域 。特别是在工业4.0和“智能+”产业政策推动下，传统行业的视觉改造将提速，新兴行业的新场景也将涌现。对于机器视觉工程师来说，不同垂直领域的发展将带来多样化的就业机会和挑战，选择深入某一行业还是横跨多个领域发展，需要结合个人兴趣与行业前景综合考量。 岗位的优势与劣势分析职业发展优势： 当前人工智能热潮下，机器视觉工程师职位具备显著的需求旺盛和技术前沿优势。人才需求旺盛：各类企业争相招聘视觉方面的人才。根据脉脉发布的报告，2023年1-8月新发布的人工智能相关岗位平均月薪已超过4.6万元，且人才供需比仅0.39，意味着约5个岗位争抢2名候选人 。在AI技术人才中，视觉算法工程师的需求占比名列前茅（仅次于通用算法工程师），被视为最稀缺的角色之一 。供不应求的市场使得有能力的视觉工程师容易获得理想的工作机会和薪资待遇。薪资水平高：相比传统IT职位，计算机视觉&#x2F;机器视觉工程师薪资起点更高。统计显示，全国范围内计算机视觉算法工程师平均薪资已达约27K&#x2F;月，其中20%的顶尖工程师月薪在4万元以上 。尤其是在互联网、大型AI公司，从事算法研究的视觉人才年薪达到几十万已较为常见，顶尖公司的offer甚至可以给硕士毕业生开出50-60K&#x2F;月的基础工资 。同时，本领域技术具有创新性和挑战性，从业者有机会参与最前沿的AI研发，在解决富有挑战的问题中获得成就感，并不断学习成长。机器视觉还应用领域广泛，工程师可以服务于不同产业（工业、医疗、自动驾驶等），横向发展空间大，不易受到单一行业景气周期的影响。 岗位潜在劣势： 尽管前景光明，机器视觉工程师这一职业也有一些挑战和不足需要认清。首先是技术门槛高，成长曲线陡峭。视觉算法涉及计算机科学、数学、光学等多学科知识，新入行者需要掌握编程、图像处理、深度学习模型等众多技能，学习成本高。此外AI领域更新换代快，工程师必须持续学习最新算法和工具，才能避免技能过时带来的职业危机。其次，岗位要求高、压力大。来自互联网大厂的岗位往往要求名校学历、扎实的理论基础和项目经验，面临激烈竞争，高薪也对应着高强度的工作节奏和KPI压力 。据职场问答反馈：“互联网企业算法岗工资高、压力大、要求高；而传统工业企业的开发岗工资一般但加班压力大” 。这表明无论是在前沿公司还是传统企业，从事机器视觉都需要做好吃苦耐劳的心理准备。例如在集成商或设备厂商担任视觉工程师，常需要赴生产一线调试设备，出差和现场加班在所难免。再次，职业天花板和发展方向选择也是一大考验。如果仅掌握基础应用而缺乏深入创新能力，随着大量新人涌入，可能会面临职业发展瓶颈。尤其是一些只做简单项目实施的“视觉应用工程师”，其月薪主要集中在8K-15K区间 （约10-18万年薪），高于普通制造业工程师但远低于算法专家岗位，而且近年此类岗位薪资有下滑趋势 。只有不断提升技能、向算法和架构高端岗位迈进，才能突破这一薪资天花板。此外，目前机器视觉行业岗位的地域集中度高也是一大因素。根据企业注册分布数据，中国机器视觉企业主要聚集在珠三角和长三角地区，广东省拥有相关企业3489家，江苏省920家 ；北京和浙江（含杭州）也是重要集聚地。这意味着本领域高薪职位大量集中于深圳、广州、上海、苏州、杭州、北京等发达城市，对于地域受限的从业者而言可能机会相对较少。最后，宏观环境变化也可能带来影响：如果经济下行企业削减研发投入，或海外市场业务受限，机器视觉岗位增长可能阶段性放缓。不过总体而言，国家战略新兴产业的定位使其长期需求有保障。 综合来看，机器视觉工程师岗位的职业价值在于其技术含金量高、发展前景广、薪酬待遇优厚，是人工智能时代极具吸引力的职业。但要享受这一红利，也需要付出持续学习和高强度工作的努力，并在职业生涯中根据自身情况及时调整发展方向以避免陷入瓶颈。 初级从业者应重点发展的技能对于即将入行或处于初级阶段的机器视觉工程师来说，扎实的技术功底是立足之本。机器视觉涉及软硬件结合，从算法原理到工程实现都有较高要求。根据业内招聘要求统计，企业最看重的技能包括：深度学习理论与框架、编程能力以及项目实践经验 。结合行业特点，以下技能领域值得新人成为重点发展方向： ​ • 计算机视觉基础与图像处理算法：掌握经典的图像处理方法（如滤波、边缘检测、特征提取等）和计算机视觉算法原理。这是理解更高级别视觉任务（目标检测、识别、分割）的基础。应熟悉OpenCV等常用开源视觉库的使用，以及典型算法如SIFT&#x2F;SURF特征、霍夫变换、立体视觉原理等。在传统工业视觉场景中，很多简单检测任务仍然依赖传统图像处理技巧来实现快速稳定的效果，因此这部分基础不可忽视。 ​ • 深度学习与图像识别：当代机器视觉大部分前沿成果都基于深度学习。初学者需要系统学习深度学习基础知识，包括常见的神经网络结构（CNN卷积神经网络、Vision Transformer视觉Transformer等）、目标检测算法（如YOLO系列、Mask R-CNN）、图像分类和分割模型等。同时熟练掌握至少一种主流深度学习框架，如TensorFlow、PyTorch，国内也可关注百度飞桨等 。理解模型训练调优方法，能够处理图像数据集、进行数据增强，以及评估模型性能。尤其重要的是深度学习在边缘设备上的部署能力（后文详述），因为工程师不仅要会训练模型，更要能让模型在实际场景中高效运行。 ​ • 编程语言与软件开发能力：C++和Python是视觉工程师必须掌握的两大语言 。Python适合快速原型开发和模型训练（大量深度学习框架以Python为主要接口），而C++由于速度和底层控制优势，被广泛用于推理部署和嵌入式实现。初级工程师应力争精通至少一门语言并熟悉另一门，能够编写高效、可靠的代码。此外，掌握软件工程基本知识（数据结构与算法、设计模式、版本控制Git等）也是必要的，这保证团队协作和项目开发的顺利进行。如果从事上位机开发或GUI界面，可适当学习C#&#x2F;Java等，但核心还是C++&#x2F;Python。对于脚本和算法验证，用Python加速开发；而最终交付的工业软件模块往往要求用C&#x2F;C++实现以达到实时性能。 ​ • CUDA&#x2F;GPU并行加速与硬件适配：深度学习和图像处理对计算性能要求高，因此熟悉GPU编程对视觉工程师十分有利。CUDA是NVIDIA GPU的并行计算框架，掌握CUDA可以编写自定义的GPU加速算法，实现对计算瓶颈环节的优化。OpenCL作为开放标准也可了解。很多视觉算法（例如卷积、矩阵运算）能通过GPU实现数十倍的提速。除了GPU，加速手段还包括利用SIMD指令（如Intel AVX）、FPGA加速卡以及NPU(神经网络处理器)等专用芯片。初级工程师不一定都要深入底层架构，但应理解基本的并行计算概念，明白如何调用深度学习框架的GPU加速库，以及在部署时选择合适的推理引擎（如TensorRT、OpenVINO等）来充分利用硬件性能。未来计算设备多元化（GPU、TPU、ASIC），具备硬件加速思维将使工程师在优化模型部署时游刃有余。 ​ • 嵌入式视觉与边缘计算：越来越多机器视觉应用需要在边缘设备或嵌入式系统上实时运行，例如工业相机自带的处理器、机器人上的计算单元、智能摄像头等。因此建议新人培养嵌入式开发技能，包括了解嵌入式Linux操作系统、ARM架构处理器、常用接口协议（Camera Link、USB3 Vision、GigE Vision等）以及在资源受限环境下进行视觉算法优化的能力。比如在NVIDIA Jetson、树莓派这类设备上部署视觉算法，学会使用交叉编译、内存优化和硬件驱动编程。一些嵌入式视觉算法需要用C&#x2F;C++编写经过精简的推理代码，甚至使用FPGA&#x2F;DSP进行加速，这就要求工程师对系统软硬件协同有一定了解。 ​ • 视觉SDK和开发平台：工业界有许多成熟的机器视觉软件和SDK，新人熟悉这些工具可大大提高开发效率。例如德国的Halcon、美国康耐视VisionPro等商业视觉库提供了丰富的现成算法函数，在工业检测中应用广泛 。掌握使用这些SDK进行二次开发，能快速搭建起检测系统的原型。在开源领域，OpenCV是必备技能，此外像PCL(Point Cloud Library)用于3D点云处理，OpenVINO用于Intel平台优化等也值得了解。针对特定行业的视觉平台，如汽车领域的AUTOSAR感知模块、机器人领域的ROS视觉包等，根据职业方向选择学习。另一方面，自主研发视觉算法模块的能力同样重要，特别是当现有SDK无法满足定制化需求时，需要自行编写算法并封装成模块。因此，新人既要会用工具，也要懂原理、能自研，二者并重。 ​ • 软件工程与项目实践：很多AI初学者容易把重心放在算法本身，但忽视将算法融入产品的工程化能力。事实上，用人单位非常看重实际项目经验 。因此建议初级工程师多参与实践项目，培养从问题需求出发设计解决方案的思维。包括问题分析、数据收集标注、模型训练迭代、到部署调试的完整流程。在实践中锻炼调参和调试能力，比如如何通过调整光源和相机参数提高图像质量，如何根据反馈不断优化算法鲁棒性等。还应掌握基本的系统架构知识，理解前后端模块如何交互，算法如何与业务逻辑对接。良好的代码风格、文档撰写、测试能力也都是高级工程师所必需的软技能。这些综合素养需要在实际项目中刻意培养，为今后承担更大职责打下基础。 总之，初级从业者应当打好基础，扩大知识面，既精通一两项核心技能（如深度学习算法），又对周边技能有所涉猎（如硬件、开发流程）。这样的“T字型”技能结构有助于在机器视觉这样跨领域的行业中胜任各种挑战。在学习中注重理论联系实践，通过实战项目强化对知识的理解。针对个人职业方向，还可以有侧重地深入某些技能领域，例如立志于算法研究的多花时间在数学和模型原理上，倾向于产品开发的多锻炼软件架构和系统集成能力。最后，保持对新技术的敏感度，关注行业最新研究进展（如Transformer在视觉中的应用、多模态AI等），不断更新自己的技能清单。 职业发展路径规划（未来3-5年）针对机器视觉工程师这一职业，新入行者在未来3-5年应有清晰的规划以逐步成长为高级人才。根据个人兴趣和行业趋势，大致有技术专家和跨界发展两大方向可供选择。以下提供一个阶段性的成长路径建议： 第一阶段（入行1~2年）：积累经验，夯实基础。初入职场时，通常从助理工程师或初级研发做起。这一阶段的重点是将学校所学转化为实际生产力。新工程师应主动承担具体的小模块开发或测试任务，在实践中熟悉开发流程和业务需求。例如，参与一个工业视觉项目的子任务，如相机标定、简单缺陷检测算法开发等。通过师傅或团队指导，掌握企业内部使用的工具链和编码规范。夯实基础依然重要：利用工作之余巩固图像处理、机器学习等理论知识，针对项目中遇到的问题查漏补缺。与此同时，着手培养专项技能：例如对偏嵌入式的工作环境，就深入学习硬件知识；做算法模型的就专攻深度学习细分领域。目标是在1-2年内成为团队中独当一面的工程师，能够独立负责某类典型任务。此阶段也应广泛请教资深同事，学习他们的问题解决思路，为下一步成长做好准备。 第二阶段（3~5年）：确定方向，深化技能。工作3年以上，已积累一定项目经验，开始考虑更明确的职业方向。这时工程师应根据自身兴趣和行业前景，定位发展轨道。如果醉心技术研究，可向算法专家&#x2F;架构师方向演进；如果偏好产品和业务，可逐步向产品经理&#x2F;项目管理角色转型；或者利用视觉技能跨界到新兴热门领域。在技术线上，3-5年经验的工程师应尝试承担技术负责人的角色。例如担任项目中视觉模块的负责人，主导算法方案选型、框架设计，把控研发进度。这将锻炼系统设计和大局观，为晋升架构师奠定基础。与此同时，可以选择某个细分领域深耕成为专家，比如专攻3D视觉感知、强化学习在视觉中的应用等，从而形成自己的技术专长。在此过程中，应持续关注前沿动态，必要时通过参与开源社区、发表技术博客、甚至研究生进修等方式提升科研创新能力。对于有管理或产品意向的人，可以逐步参与产品规划、客户需求沟通等工作，学习将技术转化为产品语言，以便日后转型。有些工程师在这个阶段会考虑跳槽到更大的平台或创业公司获取不同历练，应该结合自身成长需要慎重选择。如果目标是进入AI头部企业或新兴热门领域（如自动驾驶、机器人），建议在这几年打好相关领域的基础。例如自动驾驶需要了解多传感器融合、车辆工程知识；机器人视觉需要学习SLAM（即时定位与地图构建）、机械控制等。正如数据显示，智能驾驶系统工程师目前是人才极度紧缺的岗位 ，具备视觉背景的人若能切入该领域，将有更多机遇。 第三阶段（5年及以上）：拓展影响，成为骨干。经过5年左右磨炼，机器视觉工程师应努力成为所在公司或行业的核心骨干。这时候无论是在技术还是管理路径上，都需要承担更大的责任和发挥更大的影响力。在技术专家路线，5年以上经验往往可以晋升为高级算法工程师或系统架构师。这意味着不仅要精通具体算法实现，还要能够设计复杂系统的整体架构，指导团队其他成员工作。你可能会负责公司核心技术方案的制定，或者带领攻关关键难题。例如设计一套通用的视觉检测平台，支持不同客户定制需求；或研发突破性的算法提升行业水准。在这个阶段，工程师应着力培养技术领导力：包括指导新人、把握技术发展方向、跨部门协作等能力，逐渐成为团队不可或缺的技术权威。如果选择管理&#x2F;产品路线，此时则可能担任产品负责人、项目经理或小型团队主管。需要把之前积累的技术背景与业务洞察结合起来，推动产品落地和市场开拓。机器视觉是典型的技术驱动型行业，懂技术的管理者在与客户和市场对接时更有优势，可大展身手。还有一条值得关注的是创业路径：有经验的工程师可选择加入初创公司甚至自己创业，将多年积累的经验用于开拓新的细分市场。目前计算机视觉领域创业依然活跃，从工业质检到无人零售，各种垂直应用都有创新机会。如果具备敏锐的洞察和资源整合能力，不妨在职业生涯中后期挑战一下创业，实现从工程师到技术合伙人的跨越。 在规划职业路径时，新人应牢记技术趋势与行业需求的变化速度很快，保持学习和适应是持续发展的关键。可以每隔一两年自我评估一次：所处的细分方向是否有良好前景？自身技能是否跟上了最新发展？有没有必要调整轨道？例如，近年大模型和多模态AI兴起，如果发现纯粹做传统机器视觉遇到瓶颈，可以考虑扩展技能树，学习融合视觉与NLP的新技术，成为复合型人才。又如工业机器人、AR增强现实等与视觉结合紧密的领域兴起时，提前储备相关知识就能抢占先机。总而言之，机器视觉工程师在未来3-5年内可通过逐步深化专业、拓宽领域来提升职业价值：先站稳脚跟成为领域能手，再根据兴趣与趋势选择做“通才”还是“专才”，最终成长为驱动产业创新的中坚力量。 结语未来三年，对于中国大陆的机器视觉工程师而言，将是机遇与挑战并存的黄金发展期。一方面，宏观政策和产业升级为机器视觉技术落地提供了广阔空间，各行业的丰富应用场景将催生源源不断的岗位需求；另一方面，技术日新月异和人才涌入也对从业者提出了更高要求。通过以上分析可以看出，紧跟行业脉搏、持续学习进化是保持竞争力的核心要素。希望本报告所提供的就业趋势洞察和技能、规划建议，能为有志于机器视觉领域的从业者带来启发。在人工智能加速发展的时代，扎根机器视觉这一领域，既能参与产业变革、实现自我价值，也有望收获丰厚的职业回报。愿每一位奋进的工程师都能在时代浪潮中把握机遇，开创属于自己的精彩职业生涯。 参考文献： ​ 1. 前瞻产业研究院，《2024年中国机器视觉产业全景图谱》，新浪财经，2024年04月24日 。 ​ 2. 猎聘大数据研究院，《2025 AI技术人才供需洞察报告》，引自观察者网，2025年02月22日 。 ​ 3. 脉脉高聘，《2023泛人工智能人才洞察》，封面新闻，2023年11月03日 。 ​ 4. 职友集，《机器视觉算法工程师就业前景与工资待遇》，2023 。 ​ 5. 职友集，《机器视觉应用工程师就业前景与工资待遇》，2024 。 ​ 6. CSDN博客，《年薪20万和50万的计算机视觉算法工程师区别》，2025 . ​ 7. 中国信息通信研究院，《智能化医疗装备产业蓝皮书》，2023 . ​ 8. 天准科技新闻稿，《天准入选工信部人工智能“揭榜挂帅”榜单》，2022 . ​ 9. 智联招聘职场问答，《机器视觉行业待遇怎么样》，2024 .","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器视觉","slug":"机器视觉","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"}]},{"title":"利用blender python自动渲染密封圈下落场景图片【bpy生成仿真图片数据集】","slug":"利用blender python自动渲染密封圈下落场景【生成仿真图片数据集】","date":"2024-11-20T09:40:33.018Z","updated":"2025-04-07T14:09:43.205Z","comments":true,"path":"2024/11/20/利用blender python自动渲染密封圈下落场景【生成仿真图片数据集】/","link":"","permalink":"http://example.com/2024/11/20/%E5%88%A9%E7%94%A8blender%20python%E8%87%AA%E5%8A%A8%E6%B8%B2%E6%9F%93%E5%AF%86%E5%B0%81%E5%9C%88%E4%B8%8B%E8%90%BD%E5%9C%BA%E6%99%AF%E3%80%90%E7%94%9F%E6%88%90%E4%BB%BF%E7%9C%9F%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E9%9B%86%E3%80%91/","excerpt":"","text":"auto_render_with_bpy使用blender-python 自动渲染模拟出的密封圈下落场景图片 完整仓库地址：conf-haolee&#x2F;auto-render-with-bpy 实例图片 密集下落场景模拟文件：fallRingsCircleSimulation.blend 自动渲染程序：auto_render_torus_simulate_fall.py 渲染指定数量labeled bmp密封圈图片程序：auto_render_torus_with_overlap.py 环境配置 Python 3.11.9blender 4.1bpy-4.1.0-cp311-cp311-win_amd64.whl官方软件下载https://download.blender.org/release/Blender4.1/bpy模块离线下载https://pypi.tuna.tsinghua.edu.cn/simple/bpy/","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"blender","slug":"blender","permalink":"http://example.com/tags/blender/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"bpy","slug":"bpy","permalink":"http://example.com/tags/bpy/"}]},{"title":"Halcon 基础知识","slug":"03 【编程学习】/Halcon 基础知识","date":"2024-10-15T05:22:12.000Z","updated":"2024-10-16T18:20:28.067Z","comments":true,"path":"2024/10/15/03 【编程学习】/Halcon 基础知识/","link":"","permalink":"http://example.com/2024/10/15/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/Halcon%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"HALCON是德国MVtec公司开发的一套完善的标准的机器视觉算法包，它节约了产品成本，缩短了软件开发周期。","text":"HALCON是德国MVtec公司开发的一套完善的标准的机器视觉算法包，它节约了产品成本，缩短了软件开发周期。 快速学习做法：研究实例、做实战项目。halcon不能提供相应的界面编程需求，需要和vs来构造MFC界面或者QT使用，才能构成一套完整软件。 HDevelop 开发环境的安装： HALCON20.11软件 64 破解 HDevelop语言特点介绍halcon 中有两种变量，对应两种参数类型： 图形对象（图像，区域和XLD） 和控制数据（数字，字符串）。 图像： 显示图向类型和尺寸的通道数量。 如果过图形变量包含多个图像，那么显示第一个图像的属性。 region: 显示区域的而面积和中心。 XLD: 显示轮廓点的数量和长度。 在HDevelop参数列表中四种参数总是以同样的顺序出现，如下： 算子名（图形输入： 图形输出： 控制输入： 控制输出） 变量的定义与赋值 index := 10 Halcon常用算子介绍显示相关打开一个窗口 dev_open_window() 打开一个适应图像大小的窗口 dev_open_window_fit_image 获取图像窗口句柄 dev_get_window () 清除图像窗口的内容 dev_clear_window () 关闭活动窗口 dev_close_window() 显示图像 dev_display() 在当前窗口显示文字 dev_disp_text() 在指定窗口显示文字 disp_message(） 设置显示字体类型 set_display_font() 设置显示颜色 dev_set_color() 设置轮廓线的线宽 dev_set_line_width() 定义区域填充模式 dev_set_draw() 图像相关加载图像 read_image() 保存图像 write_image() 剪切一个或多个矩形图像区域 crop_part() 彩色图转灰度图 rgb1_to_gray() 灰度转彩色 compose3() 灰度值取反 invert_image() 三通道彩色图像分离 decompose3() 获取图像的Roi reduce_domain() 获取图像尺寸 get_image_size() 确定区域内的最小和最大灰度值。 min_max_gray() 计算灰度值的平均值和偏差。 intensity() 两张图像相加 add_image() 两张图像相减 sub_image() 计算两幅图像的最大值 max_image() 计算两幅图像的最小值 min_image() 镜像图像 mirror_image() 围绕图像中心旋转图像 rotate_image() 将图像缩放到给定的大小 zoom_image_size() 以固定灰度值将区域绘制到图像中 paint_region() 计算灰度值直方图 gray_histo() 直方图转换为区域 gen_region_histo() 根据灰度值特征选择区域 select_gray() 案例参考阈值分割识别车牌，HDevelop示例程序threshold.hdev. read_image (Audi2, &#39;audi2&#39;) fill_interlace (Audi2, ImageFilled, &#39;odd&#39;) threshold (ImageFilled, Region, 0, 90) connection (Region, ConnectedRegions) select_shape (ConnectedRegions, SelectedRegions, &#39;width&#39;, &#39;and&#39;, 30, 70) select_shape (SelectedRegions, Letters, &#39;height&#39;, &#39;and&#39;, 60, 110) dev_clear_window () dev_set_colored (12) dev_display (ImageFilled) dev_display (Letters) 参考 halcon 工业应用实用教程 第一册——第四册 机器视觉(Halcon) 河南理工大学 苏波","categories":[{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"Volantis","slug":"Volantis","permalink":"http://example.com/tags/Volantis/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Linux 常用命令速查","slug":"03 【编程学习】/2021-10-31-Linux-常用命令速查","date":"2024-10-14T10:07:19.594Z","updated":"2024-10-14T18:24:23.644Z","comments":true,"path":"2024/10/14/03 【编程学习】/2021-10-31-Linux-常用命令速查/","link":"","permalink":"http://example.com/2024/10/14/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/2021-10-31-Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/","excerpt":"Linux 命令行速查表","text":"Linux 命令行速查表 1 系统操作命令 序号 命令 作用 补充 1 ls 列出当前目录中的文件和子目录 2 pwd 显示当前工作目录的路径 3 cd /path/to/directory 切换工作目录 4 mkdir 创建新目录 5 rmdir directory_name 删除空目录 6 ps aux 显示当前运行的进程 7 kill process_id 终止进程 8 chmod permissions file_name 修改文件或目录的权限 9 chown owner:group file_name 修改文件或目录的所有者 10 tar -czvf archive.tar.gz directory_name # 压缩目录tar -xzvf archive.tar.gz # 解压文件 用于压缩和解压文件和目录 11 df -h # 显示磁盘空间使用情况du -h directory_name # 显示目录的磁盘使用情况 显示磁盘使用情况 12 mount /dev/sdX1 /mnt # 挂载分区到指定目录umount /mnt # 卸载挂载的文件系统 挂载和卸载文件系统 13 tophtop 显示系统资源的实时使用情况和进程信息 14 find /path/to/search -name &quot;file_pattern&quot; find：在文件系统中查找文件和目录 15 uname -a 显示系统信息 16 shutdown -h now # 立即关闭系统reboot # 重新启动系统 关闭或重新启动系统 17 whow 显示当前登录的用户信息 18 zip archive.zip file1 file2 # 压缩文件unzip archive.zip # 解压ZIP文件 用于压缩和解压ZIP文件 19 useradd new_user # 添加用户userdel username # 删除用户 用于添加和删除用户账户 20 passwd username 更改用户密码 21 uptime 显示系统的运行时间和负载情况 22 hostname # 显示主机名 显示或设置计算机的主机名 23 free -m # 以MB为单位显示内存使用情况 显示系统内存使用情况 24 lsblk # 显示块设备信息fdisk /dev/sdX # 打开磁盘分区工具 查看磁盘分区信息和管理磁盘 25 stat file_or_directory 显示文件或目录的详细信息 26 sudo command_to_run_as_superuser 以超级用户权限运行命令 2 文件操作命令 序号 命令 作用 补充 1 touch file_name 创建空文件或更新文件的时间戳 2 rm file_name rm -r directory_name *# 递归删除目录及其内容* 删除文件或目录 3 cp source_file destinationcp -r source_directory destination # 递归复制目录及其内容ping：测试与主机的连通性 复制文件或目录 4 mv old_name new_name 移动或重命名文件或目录 5 cat file_name 连接和显示文件内容 6 more file_nameless file_name 逐页显示文本文件内容 7 head -n 10 file_name # 显示文件的前10行tail -n 20 file_name # 显示文件的后20行 显示文件的前几行或后几行 8 grep search_term file_name 在文件中搜索指定文本 9 3 网络设置命令 序号 命令 作用 补充 1 ifconfigip addr show 查看和配置网络接口信息 2 ping host_name_or_ip 测试与主机的连通性 3 wget URLcurl -O URL 从网络下载文件 4 ssh username@remote_host 远程登录到其他计算机 5 scp local_file remote_user@remote_host:/remote/directory 安全地将文件从本地复制到远程主机，或从远程主机复制到本地 6 iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 允许HTTP流量ufw enable # 启用Uncomplicated Firewall 用于配置防火墙规则 7 netstat -tuln # 显示所有TCP和UDP端口ss -tuln # 使用Socket Stat查看网络连接 显示网络连接信息 8 nc -vz host_name_or_ip port # 测试主机的端口是否可达 用于网络连接测试和数据传输 9 nmcli connection show # 显示网络连接信息 用于管理网络连接的命令行工具 引用 https://blog.csdn.net/wzk4869/article/details/132855372 Linux 命令行速查表","categories":[{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"blender小零件下落场景构建，以及图片自动生成python实现","slug":"blender小零件下落场景自动生成python实现","date":"2024-09-26T16:49:56.246Z","updated":"2024-11-20T09:52:06.283Z","comments":true,"path":"2024/09/27/blender小零件下落场景自动生成python实现/","link":"","permalink":"http://example.com/2024/09/27/blender%E5%B0%8F%E9%9B%B6%E4%BB%B6%E4%B8%8B%E8%90%BD%E5%9C%BA%E6%99%AF%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90python%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"参考代码 &quot;&quot;&quot; 模拟环体下落过程，自动渲染环体下落时的图片 v2 更新: 1. 添加 环体随机形变 2. 物体重命名 time: 2024/11/11 auther: haolee &quot;&quot;&quot; import bpy from datetime import datetime import math import random # 清除默认场景中的所有对象 # bpy.ops.object.delete(use_global=False, confirm=False) #del bpy.ops.object.select_all(action=&#39;DESELECT&#39;) bpy.ops.object.select_all(action=&#39;SELECT&#39;) bpy.ops.object.delete() # step1 新建一个环体 并设置属性 bpy.ops.mesh.primitive_torus_add( align=&#39;WORLD&#39;, location=(0, 0, 10), # 位置 XYZ rotation=(0, math.radians(90), 0), # 旋转 XYZ major_radius=0.5, # 圆环体内圆半径 minor_radius=0.2, #环半径 # major_segments=1000, # 设置主环段数 # minor_segments=100, # 辅环段数 # abso_major_rad=10, # 通过外圆半径内圆半径定义环体 外圆半径 # abso_minor_rad=5 # 内圆半径 ) bpy.context.object.name = &quot;torus&quot; bpy.ops.object.shade_smooth() #平滑着色 # 为环体添加修改器， [0]-简易形变 #bpy.context.space_data.context = &#39;MODIFIER&#39; bpy.ops.object.modifier_add(type=&#39;SIMPLE_DEFORM&#39;) bpy.context.object.modifiers[0].deform_axis = &#39;X&#39; select_torus = bpy.context.object # 记录当前环体 bpy.context.object.modifiers[0].angle = math.radians(10) # rad(10) # 设置橡胶圈材质 for material in bpy.data.materials: # 首先清除所有材质 bpy.data.materials.remove(material) # create material bpy.ops.material.new() rubberRing_material = bpy.data.materials[-1] # 获取最新创建的材质 # nodes[0] -- nodes[&quot;原理化BSDF&quot;] # HSV 设置基础色 (色相 饱和度 明度 alpha) 通过调整明度可调整密封圈灰度值 rubberRing_material.node_tree.nodes[0].inputs[0].default_value = (0.1, 0.1, 0.1, 1) # 设置材质金属度 范围[0.1] rubberRing_material.node_tree.nodes[0].inputs[1].default_value = 0.0942623 # apply light_material 应用材质 bpy.context.active_object.data.materials.append(rubberRing_material) # step2 新建一个平面背光 bpy.ops.mesh.primitive_plane_add(enter_editmode=False, align=&#39;WORLD&#39;, location=(-3, 0, 6), rotation=(3.14159, -1.5708, 0), scale=(2.4, 4.0, 1.0)) bpy.context.object.name = &quot;backlight_face&quot; bpy.context.object.scale[0] = 2.4 bpy.context.object.scale[1] = 4 # 新建一个发光材质 #bpy.context.space_data.context = &#39;MATERIAL&#39; bpy.ops.material.new() light_material = bpy.data.materials[-1] light_material.node_tree.nodes[0].inputs[27].default_value = 50 # 设置平面的自发光强度 亮度低会影响渲染背景不够白 # 应用自发光的材质 bpy.context.active_object.data.materials.append(light_material) # step3 新建摄像机 bpy.ops.object.camera_add(enter_editmode=False, align=&#39;VIEW&#39;, location=(6, 0, 6), rotation=(1.5708, 0, 1.5708), scale=(1, 1, 1)) bpy.context.object.name = &quot;camera&quot; bpy.context.object.data.lens = 80 #摄像机焦距 # step4 新建一个平面为其设置粒子系统，模拟环体下落过程 bpy.ops.mesh.primitive_plane_add(size=2, enter_editmode=False, align=&#39;WORLD&#39;, location=(0, 0, 8), scale=(1, 1, 1)) bpy.context.object.name = &quot;particle_face&quot; bpy.context.object.scale[0] = -0.26 # 缩放 X bpy.context.object.scale[1] = -0.8 # 缩放 Y bpy.context.object.scale[2] = -2.6 # 缩放 Z # set particle system 粒子系统设置 for particle in bpy.data.particles: bpy.data.particles.remove(particle) bpy.ops.object.particle_system_add() bpy.data.particles[-1].count = 100 # 环体下落数量 bpy.data.particles[-1].frame_start = 10 # 发射起始帧 bpy.data.particles[-1].frame_end = 20 # 发射结束 bpy.data.particles[-1].lifetime = 20 # 生命周期 bpy.data.particles[-1].render_type = &#39;OBJECT&#39; # 设置粒子系统渲染为 物体 bpy.data.particles[-1].instance_object = bpy.data.objects[3] # 选择渲染的实例物体 环体 bpy.data.particles[-1].use_rotations = True # 旋转开启， bpy.data.particles[-1].rotation_factor_random = 0.8 # 旋转开启，设置随机值范围[0,1] bpy.data.particles[-1].use_rotation_instance = True # 设置物体旋转 开启 bpy.data.particles[-1].particle_size = 0.5 # 渲染物体的缩放设置 bpy.data.particles[-1].distribution = &#39;RAND&#39; # 随机分布 bpy.data.particles[-1].use_scale_instance = False # 物体缩放 #rand = random.randint(0,100) # 生成一个随机数 #bpy.context.object.particle_systems[-1].seed = rand # 设置一个随机种子 # step5 渲染格式设置 scene = bpy.context.scene scene.render.resolution_x = 4096 # 输出图片的分辨率 X*Y 4k 4096*2048 scene.render.resolution_y = 2048 scene.render.image_settings.file_format = &#39;BMP&#39; # 保存格式为BMP scene.render.fps = 6 # 设置渲染fps = 6 scene.frame_start = 1 # 起始帧 scene.frame_end = 30 # 结束帧 scene.render.image_settings.color_mode = &#39;BW&#39; # 输入：黑白图片渲染 for renderTimes in range(1,3): rand_deform = random.randint(-60,60) # 生成随机形变值 select_torus.modifiers[0].angle = math.radians(rand_deform) # rad(10) rand = random.randint(0,100) # 生成一个随机数 bpy.context.object.particle_systems[-1].seed = rand # 设置一个随机种子 scene.camera = bpy.data.objects[&#39;camera&#39;] for frame_i in range(1,30): bpy.context.scene.frame_set(frame_i) # 切换到第30帧 bpy.ops.render.render() if frame_i is 20: # 保存第20帧图像 currentTime = datetime.now().strftime(&quot;%Y%m%d %H%M&quot;) save_bmp = &quot;D:/GXNU/blenderToBmp/BmpData/&quot; + currentTime + &quot;_Render&quot; + &quot;/&quot; + currentTime + &quot;_&quot; + str(renderTimes) + &quot;.bmp&quot; bpy.data.images[&quot;Render Result&quot;].save_render(save_bmp) # 保存渲染图片","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"blender","slug":"blender","permalink":"http://example.com/tags/blender/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"WSL 微软 linux子系统介绍与简易指南","slug":"WSL-微软-linux子系统介绍与简易指南","date":"2024-09-24T17:48:45.161Z","updated":"2024-10-14T15:40:10.757Z","comments":true,"path":"2024/09/25/WSL-微软-linux子系统介绍与简易指南/","link":"","permalink":"http://example.com/2024/09/25/WSL-%E5%BE%AE%E8%BD%AF-linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/","excerpt":"https://blog.csdn.net/Huahua_1223/article/details/140478455","text":"https://blog.csdn.net/Huahua_1223/article/details/140478455 WSL 待补充","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"http://example.com/tags/WSL/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"计算机视觉的常见任务","slug":"计算机视觉的常见任务","date":"2024-09-22T14:50:51.361Z","updated":"2025-02-19T04:10:01.032Z","comments":true,"path":"2024/09/22/计算机视觉的常见任务/","link":"","permalink":"http://example.com/2024/09/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BB%BB%E5%8A%A1/","excerpt":"常见的图像识别任务包括图像分类(Image Classification)、目标检测(Object Detection)、语义分割(Semantic Segmentation)和实例分割(Instance Segmentation)。","text":"常见的图像识别任务包括图像分类(Image Classification)、目标检测(Object Detection)、语义分割(Semantic Segmentation)和实例分割(Instance Segmentation)。 计算机视觉的常见任务经典数据集 MNIST数据集 ImageNet数据集 CIFAR-10&#x2F;100数据集 1. 图像分类 (Image Classification)原理：图像分类任务的目的是将输入图像分配到预定义的类别中。常见的算法是卷积神经网络（CNN），它通过卷积层自动提取图像的局部特征，再通过全连接层进行分类。 伪代码：python 复制编辑 # 伪代码：图像分类 def image_classification(image): # 数据预处理：缩放、归一化等 preprocessed_image = preprocess(image) # 定义CNN模型 model = create_cnn_model() # 使用训练好的模型进行预测 predicted_class = model.predict(preprocessed_image) return predicted_class Python代码实现 (使用Keras)：python 复制编辑 import keras from keras.models import Sequential from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense from keras.preprocessing import image import numpy as np # 加载预训练模型（如VGG16） model = keras.applications.VGG16(weights=&#39;imagenet&#39;) # 加载图像并预处理 img_path = &#39;path_to_image.jpg&#39; # 输入图片路径 img = image.load_img(img_path, target_size=(224, 224)) img_array = image.img_to_array(img) img_array = np.expand_dims(img_array, axis=0) img_array = keras.applications.vgg16.preprocess_input(img_array) # 使用模型进行预测 predictions = model.predict(img_array) # 输出预测结果 decoded_predictions = keras.applications.vgg16.decode_predictions(predictions) print(decoded_predictions) 2. 目标检测 (Object Detection)原理：目标检测不仅需要分类物体，还需要在图像中定位物体的具体位置。通常使用区域提议网络（RPN）和分类网络的组合。常见的模型有YOLO（You Only Look Once）和Faster R-CNN。 伪代码：python 复制编辑 # 伪代码：目标检测 def object_detection(image): # 数据预处理：图像缩放、归一化等 preprocessed_image = preprocess(image) # 使用目标检测模型（如YOLO） model = create_yolo_model() # 检测图像中的物体 bounding_boxes, class_labels = model.detect_objects(preprocessed_image) return bounding_boxes, class_labels Python代码实现 (使用YOLO模型)：python 复制编辑 import cv2 import numpy as np # 加载预训练的YOLO模型 net = cv2.dnn.readNet(&quot;yolov3.weights&quot;, &quot;yolov3.cfg&quot;) layer_names = net.getLayerNames() output_layers = [layer_names[i - 1] for i in net.getUnconnectedOutLayers()] # 读取图像 img = cv2.imread(&#39;image.jpg&#39;) height, width, channels = img.shape # 预处理图像 blob = cv2.dnn.blobFromImage(img, 0.00392, (416, 416), (0, 0, 0), True, crop=False) net.setInput(blob) outs = net.forward(output_layers) # 解析输出并绘制检测框 for out in outs: for detection in out: scores = detection[5:] class_id = np.argmax(scores) confidence = scores[class_id] if confidence &gt; 0.5: center_x = int(detection[0] * width) center_y = int(detection[1] * height) w = int(detection[2] * width) h = int(detection[3] * height) cv2.rectangle(img, (center_x, center_y), (center_x + w, center_y + h), (0, 255, 0), 2) # 显示检测结果 cv2.imshow(&#39;Detected Image&#39;, img) cv2.waitKey(0) cv2.destroyAllWindows() 3. 图像分割 (Image Segmentation)原理：图像分割的任务是将图像分成多个有意义的区域，每个区域对应图像中的一个物体或部分。常见的分割方法包括语义分割和实例分割，深度学习中常用U-Net和Mask R-CNN模型。 伪代码：python 复制编辑 # 伪代码：图像分割 def image_segmentation(image): # 数据预处理 preprocessed_image = preprocess(image) # 加载分割模型（如U-Net） model = create_unet_model() # 进行图像分割 segmentation_mask = model.predict(preprocessed_image) return segmentation_mask Python代码实现 (使用U-Net模型)：python 复制编辑 from tensorflow.keras.models import load_model import numpy as np import cv2 # 加载预训练的U-Net模型 model = load_model(&#39;unet_model.h5&#39;) # 读取图像并预处理 img = cv2.imread(&#39;image.jpg&#39;, cv2.IMREAD_GRAYSCALE) img = cv2.resize(img, (256, 256)) img = np.expand_dims(img, axis=-1) img = img / 255.0 # 预测分割结果 segmentation_result = model.predict(np.expand_dims(img, axis=0)) # 显示分割结果 segmentation_mask = segmentation_result[0, :, :, 0] # 只取第一个通道 cv2.imshow(&#39;Segmentation Mask&#39;, segmentation_mask) cv2.waitKey(0) cv2.destroyAllWindows() 4. 人脸识别 (Face Recognition)原理：人脸识别是通过检测图像中的人脸并对其进行身份验证或识别。常见的算法有Haar特征分类器、HOG+SVM以及基于深度学习的FaceNet和OpenFace。 伪代码：python 复制编辑 # 伪代码：人脸识别 def face_recognition(image): # 使用预训练的模型检测人脸 faces = detect_faces(image) # 对每个人脸进行识别 for face in faces: identity = recognize_face(face) return identity Python代码实现 (使用OpenCV和dlib)：python 复制编辑 import cv2 import dlib # 加载人脸检测器和人脸识别模型 detector = dlib.get_frontal_face_detector() predictor = dlib.shape_predictor(&#39;shape_predictor_68_face_landmarks.dat&#39;) face_rec_model = dlib.face_recognition_model_v1(&#39;dlib_face_recognition_resnet_model_v1.dat&#39;) # 读取图像 img = cv2.imread(&#39;image.jpg&#39;) # 检测人脸 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = detector(gray) # 获取并识别人脸特征 for face in faces: landmarks = predictor(gray, face) face_descriptor = face_rec_model.compute_face_descriptor(img, landmarks) print(face_descriptor) 5. 姿态估计 (Pose Estimation)原理：姿态估计的任务是预测图像中人体或物体的关键点位置，常用于人类动作分析。OpenPose和PoseNet是比较常用的姿态估计算法。 伪代码：python 复制编辑 # 伪代码：姿态估计 def pose_estimation(image): # 加载姿态估计模型 model = load_pose_estimation_model() # 对图像进行姿态估计 keypoints = model.estimate_pose(image) return keypoints Python代码实现 (使用OpenPose)：python 复制编辑 import cv2 import pyopenpose as op # 初始化OpenPose params = &#123;&#39;model_folder&#39;: &#39;models/&#39;&#125; opWrapper = op.WrapperPython() opWrapper.configure(params) opWrapper.start() # 读取图像 img = cv2.imread(&#39;image.jpg&#39;) # 进行姿态估计 datum = op.Datum() datum.cvInputData = img opWrapper.emplaceAndPop([datum]) # 显示结果 cv2.imshow(&#39;Pose Estimation&#39;, datum.cvOutputData) cv2.waitKey(0) cv2.destroyAllWindows() 6. 图像超分辨率 (Image Super-Resolution)原理：图像超分辨率任务的目的是将低分辨率的图像转换为高分辨率图像。常用的算法包括SRCNN、VDSR等，它们通常使用深度学习模型来生成细节。 伪代码：python 复制编辑 # 伪代码：图像超分辨率 def image_super_resolution(image): # 数据预处理 preprocessed_image = preprocess(image) # 加载超分辨率模型 model = load_sr_model() # 进行超分辨率处理 high_res_image = model.predict(preprocessed_image) return high_res_image Python代码实现 (使用ESRGAN)：python 复制编辑 import torch from model import ESRGAN # 假设你有ESRGAN模型定义 # 加载预训练模型 model = ESRGAN() model.load_state_dict(torch.load(&#39;esrgan.pth&#39;)) model.eval() # 读取低分辨率图像 lr_image = cv2.imread(&#39;low_res_image.jpg&#39;) # 转换为PyTorch张量并进行预处理 lr_image_tensor = torch.from_numpy(lr_image).float().permute(2, 0, 1).unsqueeze(0) / 255.0 # 使用ESRGAN进行超分辨率处理 with torch.no_grad(): sr_image_tensor = model(lr_image_tensor) # 转换回图像格式并显示 sr_image = sr_image_tensor.squeeze(0).permute(1, 2, 0).numpy() * 255.0 sr_image = sr_image.astype(np.uint8) cv2.imshow(&#39;Super Resolution&#39;, sr_image) cv2.waitKey(0) cv2.destroyAllWindows() 7. 光流估计 (Optical Flow Estimation)原理：光流估计用于分析视频中物体的运动，它估计的是像素在连续帧之间的位移。在运动分析、视频稳定、目标跟踪等领域有重要应用。常用的算法有Lucas-Kanade方法和Farneback方法。 伪代码：python 复制编辑 # 伪代码：光流估计 def optical_flow_estimation(prev_image, next_image): # 使用光流算法计算图像间的像素位移 flow = calculate_optical_flow(prev_image, next_image) return flow Python代码实现 (使用OpenCV的Farneback方法)：python 复制编辑 import cv2 import numpy as np # 读取前后两帧图像 prev_frame = cv2.imread(&#39;frame1.jpg&#39;, cv2.IMREAD_GRAYSCALE) next_frame = cv2.imread(&#39;frame2.jpg&#39;, cv2.IMREAD_GRAYSCALE) # 计算光流（Farneback方法） flow = cv2.calcOpticalFlowFarneback(prev_frame, next_frame, None, 0.5, 3, 15, 3, 5, 1.2, 0) # 显示光流 magnitude, angle = cv2.cartToPolar(flow[..., 0], flow[..., 1]) flow_image = np.zeros_like(prev_frame) flow_image[..., 0] = angle * 180 / np.pi / 2 flow_image[..., 1] = cv2.normalize(magnitude, None, 0, 255, cv2.NORM_MINMAX) flow_image[..., 2] = 255 # 显示结果 cv2.imshow(&#39;Optical Flow&#39;, flow_image) cv2.waitKey(0) cv2.destroyAllWindows() 8. 图像描述与生成 (Image Captioning)原理：图像描述任务是根据图像生成自然语言描述。该任务通常结合卷积神经网络（CNN）和循环神经网络（RNN）或Transformer模型。CNN用于从图像中提取特征，而RNN&#x2F;Transformer用于生成图像的描述。 伪代码：python 复制编辑 # 伪代码：图像描述生成 def image_captioning(image): # 提取图像特征 image_features = extract_features(image) # 使用RNN或Transformer生成描述 caption = generate_caption(image_features) return caption Python代码实现 (使用预训练模型)：python 复制编辑 import tensorflow as tf from tensorflow.keras.preprocessing import image import numpy as np # 加载预训练的图像描述模型（例如Show and Tell模型） model = tf.keras.models.load_model(&#39;image_captioning_model.h5&#39;) # 加载并预处理图像 img = image.load_img(&#39;image.jpg&#39;, target_size=(224, 224)) img_array = image.img_to_array(img) img_array = np.expand_dims(img_array, axis=0) # 提取图像特征 image_features = model.extract_features(img_array) # 生成描述 caption = model.generate_caption(image_features) print(caption) 9. 文本检测与识别 (Text Detection and Recognition)原理：文本检测任务是从图像中定位出文本区域，文本识别任务则是识别文本区域中的具体内容。常见的技术有EAST (Efficient and Accurate Scene Text detector) 和CRNN (Convolutional Recurrent Neural Network)。 伪代码：python 复制编辑 # 伪代码：文本检测与识别 def text_detection_and_recognition(image): # 使用EAST或其他文本检测方法定位文本区域 text_regions = detect_text_regions(image) # 对文本区域进行识别 recognized_text = recognize_text_in_regions(text_regions) return recognized_text Python代码实现 (使用OpenCV和EAST文本检测)：python 复制编辑 import cv2 import numpy as np # 加载EAST模型 net = cv2.dnn.readNet(&#39;frozen_east_text_detection.pb&#39;) # 读取输入图像 image = cv2.imread(&#39;text_image.jpg&#39;) height, width = image.shape[:2] # 预处理图像 blob = cv2.dnn.blobFromImage(image, 1.0, (width, height), (123.68, 116.78, 103.94), swapRB=True, crop=False) net.setInput(blob) # 获取文本检测结果 scores, geometry = net.forward([&#39;score1&#39;, &#39;geometry1&#39;]) # 解析结果并绘制文本框 # 具体的解析过程可参考OpenCV官方文档 总结这些常见的计算机视觉任务涵盖了从图像处理、目标检测到视频分析等多种应用。通过深度学习技术，尤其是卷积神经网络（CNN）、循环神经网络（RNN）、生成对抗网络（GAN）等，我们可以解决越来越复杂的视觉问题。每个任务都可以通过使用开源框架（如TensorFlow、PyTorch、OpenCV）来实现，部分任务（如图像分类、目标检测）已经有预训练模型可供使用，可以极大简化开发过程。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CV","slug":"CV","permalink":"http://example.com/tags/CV/"}]},{"title":"树莓派4b快速上手","slug":"03 【编程学习】/树莓派4b快速上手","date":"2024-09-21T08:38:51.937Z","updated":"2024-10-16T16:15:53.012Z","comments":true,"path":"2024/09/21/03 【编程学习】/树莓派4b快速上手/","link":"","permalink":"http://example.com/2024/09/21/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"","text":"01 组装树莓派4B散热片及九层亚克力外壳的正确打开方式_树莓派散热片怎么贴-CSDN博客 02 烧录系统使用SD卡读卡器插入连接电脑，然后去树莓派官网下载树莓派操作系统程序Raspberry Pi Imager Raspberry Pi OS – Raspberry Pi 03 开启wifi 和SSHstep1：开启ssh ： 在SD卡磁盘根目录下创建 文本文件，命名为ssh(删除后缀名)。 开启ssh step2：配置网络： 创建wpa_supplicant.conf文件， 文件中内容参考： 接口设置 ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 国家码设置 country=CN 网络信息配置 network=&#123; ssid=&quot;NTest&quot; # wifi账号 psk=&quot;12345678&quot; # wifi密码，一般要&gt;8个字符 key_mgmt=WPA-PSK # 密钥管理算法，通常家用路由都是WPA-PSK，企业路由是WPA-EAP # 如果要连接的wifi是没有密码的，需要配置为：key_mgmt=NONE disabled=1 # 使能 # 其他参数： scan_ssid=1 # 对于隐藏的SSID，需要配置此参数 priority=1 # 优先级，如果有多个wifi需要保存，在不同network字典中可以配置不同的优先级，数字越小，优先级越高 &#125; network=&#123; ssid=&quot;River_Test&quot; psk=&quot;12345678&quot; &#125; 04 通过路由器查看接入的树莓派ip地址，ssh 连接在windows 命令行终端 ssh user@ip 系统默认的用户名为：pi 密码是： raspberry 遇到的问题关于树莓派在interface options中找不到camera的情况_树莓派interface没有相机-CSDN博客 测试相机命令 libcamera-hello -t 0","categories":[{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"Rasberry Pi","slug":"Rasberry-Pi","permalink":"http://example.com/tags/Rasberry-Pi/"}]},{"title":"经典神经网络的分析与总结","slug":"经典神经图像分析与总结","date":"2024-09-12T02:32:50.457Z","updated":"2024-10-10T12:52:23.666Z","comments":true,"path":"2024/09/12/经典神经图像分析与总结/","link":"","permalink":"http://example.com/2024/09/12/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E5%9B%BE%E5%83%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/","excerpt":"经典图像分类 神经网络总结 在CNN网络结构的演化上，出现过许多优秀的CNN网络，CNN的经典结构始于1998年的LeNet，成于2012年历史性的AlexNet，从此盛于图像相关领域。","text":"经典图像分类 神经网络总结 在CNN网络结构的演化上，出现过许多优秀的CNN网络，CNN的经典结构始于1998年的LeNet，成于2012年历史性的AlexNet，从此盛于图像相关领域。 发展历史：Lenet –&gt; Alexnet –&gt; ZFnet –&gt; VGG –&gt; NIN –&gt; GoogLeNet –&gt;ResNet–&gt; DenseNet –&gt;ResNeXt —&gt; EfficientNet Alexnet –2012ImageNet图像识别竞赛一骑绝尘 AlexNet——验证了深度卷积神经网络的高效性 主体贡献 提出了一种卷积层加全连接层的卷积神经网络结构 首次使用ReLU函数做为神经网络的激活函数 首次提出Dropout正则化来控制过拟合 使用加入动量的小批量梯度下降算法加速了训练过程的收敛； 使用数据增强策略极大地抑制了训练过程的过拟合； 利用了GPU的并行计算能力，加速了网络的训练与推断。 VGG","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Lenet","slug":"Lenet","permalink":"http://example.com/tags/Lenet/"},{"name":"Alexnet","slug":"Alexnet","permalink":"http://example.com/tags/Alexnet/"},{"name":"VGG","slug":"VGG","permalink":"http://example.com/tags/VGG/"},{"name":"GoogleNet","slug":"GoogleNet","permalink":"http://example.com/tags/GoogleNet/"},{"name":"ResNet","slug":"ResNet","permalink":"http://example.com/tags/ResNet/"}]},{"title":"留学见闻录-- 教育理念对创新的影响","slug":"02 【生活】读书笔记/留学见闻录---教育理念对创新的影响","date":"2024-09-12T02:12:46.333Z","updated":"2024-09-19T04:12:34.304Z","comments":true,"path":"2024/09/12/02 【生活】读书笔记/留学见闻录---教育理念对创新的影响/","link":"","permalink":"http://example.com/2024/09/12/02%20%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%95%99%E5%AD%A6%E8%A7%81%E9%97%BB%E5%BD%95---%E6%95%99%E8%82%B2%E7%90%86%E5%BF%B5%E5%AF%B9%E5%88%9B%E6%96%B0%E7%9A%84%E5%BD%B1%E5%93%8D/","excerpt":"PBL和Logbook才是英美乃至西方教育体系真正的精华所在，其他都是旁支末节，建议国内尽早引进。","text":"PBL和Logbook才是英美乃至西方教育体系真正的精华所在，其他都是旁支末节，建议国内尽早引进。 https://m.huxiu.com/article/516917.html?f=pc_new_share_article_wechat 留学见闻录– 教育理念对创新的影响PBL，全名“problem base learning（问题导向型学习法）”，PBL在本科是最常见的。 但是PBL不写实验报告，取而代之的是写Logbook（工作记录本），这个Logbook这里先不提，一会儿重点介绍，它和PBL是西方工科教育的精华所在。 东亚国家普遍很擅长渐进型创新，但是原创型创新非常弱，弱到可以用零来形容。三星手机就是非常典型的代表，今天把手机屏幕做大一点，明天把摄像头像素加大一点，后天改善下电池的续航能力，大后天把手机厚度掏薄一点，顺便把重量做轻一点。 苹果和三星可以说是两种创新模式的典型代表，三星这么多年来，能拿的出手的原创型创新据我了解目前只有一个，就是折叠屏。相比之下苹果的原创就强很多，面部识别，指纹识别，全面屏，蓝牙耳机等等都是他第一个率先应用在手机上的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"","slug":"密封圈视觉计数研究方向的思考20240910","date":"2024-09-10T12:22:34.155Z","updated":"2024-10-15T04:35:54.577Z","comments":true,"path":"2024/09/10/密封圈视觉计数研究方向的思考20240910/","link":"","permalink":"http://example.com/2024/09/10/%E5%AF%86%E5%B0%81%E5%9C%88%E8%A7%86%E8%A7%89%E8%AE%A1%E6%95%B0%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91%E7%9A%84%E6%80%9D%E8%80%8320240910/","excerpt":"","text":"密封圈视觉计数研究方向的思考2024&#x2F;09&#x2F;10数据集的处理第一步： 绿色橡胶圈 最普通款 5类 每类110张图片 第二步： 扩大数据量 （blender数据仿真生成，程序手工组合数据） 550张数据 第三步 增加不同的密封圈类型的数据 和传统方法做对比做一个离散图分布 一个橡胶圈面积数量分布 2-5个橡胶圈的面积数量分布","categories":[],"tags":[]},{"title":"机器学习基础知识","slug":"机器学习基础知识","date":"2024-09-10T11:20:17.110Z","updated":"2024-10-15T04:18:31.210Z","comments":true,"path":"2024/09/10/机器学习基础知识/","link":"","permalink":"http://example.com/2024/09/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"机器学习， 一种数据驱动的方法。 机器学习的关键组件： 可以用来学习的数据（data）； 如何转换数据的模型（model）； 一个目标函数（objective function），用来量化模型的有效性； 调整模型参数以优化目标函数的算法（algorithm）。 相关名词解释：损失函数： 交叉熵损失 优化算法： SGD、 带动量的SGD以及ADAM 卷积 池化 下采样 机器学习的一般流程1 定义分析目标明确目标任务是第一个需求，也是选择合适的机器学习算法的关键所在。通过阐明业务需求以及要解决的实际问题，才能根据现有的数据进行模型的设计以及算法的选择。 在监督学习中，分类算法用于定性问题，而回归方法用于定量分析。 在无监督学习中，如果存在样本分割，则可以应用聚类算法。如果需要找出各种数据项之间的内部联系，则可以应用关联分析。 2 收集数据1.数据应具有代表性，并尽可能地覆盖区域，不然的话，可能出现过拟合和欠拟合的情况。 2.样本数据应平衡。在分类问题的范畴中，如果存在不同类别之间的样本比例较大的情况或者样本数据不平衡的现象，均会影响最终模型的性能。 3.评估数据的量级，包括特征的数量以及样本的数量。根据这些指标估计数据和分析对内存的消耗，并判断在训练过程中内存是否过大，如果内存过大则需要对算法进行优化、改进，或者通过对某些降维技术的使用实现内存消耗合理化，必要的话甚至还会采用一些分布式机器学习的技术。 3 整理预处理1.数据探索 首先通过对数据进行一定的探索，了解数据的基本结构，数据的统计信息，数据噪声和数据分布等相关信息。 为了更好地对数据的状况进行查看以及数据模式的获取，可以采用数据质量评估以及数据可视化等相关方法来评估数据的质量。 2.数据处理 经过步骤1，可能会发现很多数据质量的问题，例如缺失值，不规则的数据，数据的分布不平衡，数据异常和数据冗余等问题。这些问题的存在将严重降低数据的质量。 数据预处理的操作也是非常重要，在生产环境中的机器学习中，数据通常是原始的，未经过加工以及处理的，而数据预处理的工作通常占据着整个机器学习过程中的绝大部分时间。 常见的数据预处理的方法：缺失值处理，离散化，归一化，去除共线性等方法是机器学习算法。整理预处理 4 数据建模采用特征选择的方法，可以实现从大量的数据中提取适当的特征，并将选择好的特征应用于模型的训练中，以获得更高精度的模型。 筛选出显著特征需要对业务有非常充分的了解并分析数据。特征选择是否合适通常会对模型的精度有非常直接的影响。选择好的特征，即使采用较为简单的算法，也可以获得较为稳定且良好的模型。 特征有效性分析的技术：相关系数、平均互信息、后验概率、卡方检验、条件熵、逻辑回归权重等方法。 在训练模型之前，通常将数据集分为训练集与测试集，有的时候，会将训练集继续细分为训练集和验证集，以评估模型的泛化能力。 模型本身不存在好坏之分。在进行模型的选择时，通常，没有哪一种算法在任何情况下都能够表现良好，在实际进行算法的选择时，通常，采用几种不同的算法同时进行模型的训练，之后再比较它们之间的性能，并选择其中表现最佳的算法。 不同的模型采用不同的性能指标。 5 模型训练在模型训练的过程中，需要调整模型的超参数。 在训练的过程中，对机器学习算法的原理以及其推导的过程的要求越高，对机器学习算法的了解越深，就越容易找到问题出现的原因，从而进行合理的模型调整。 6 模型评估利用测试集数据对模型的精度进行评估与测验，以便评估训练模型对新数据的泛化能力。 假如评估的效果不是很理想，那么就需要分析模型效果不理想的原因并对训练模型进行一定的优化与改进，例如手动调整参数等改进方法。 评估不理想，需要首先诊断模型以确定模型调整的正确思路与方向。过度拟合和欠拟合问题的判断是模型诊断中的重要步骤。 典型方法：绘制学习曲线和交叉验证。 如何解决：出现过度拟合问题时，其模型的基本调整策略是在增加数据量的同时能够降低模型的复杂度，也可以采用正则化的方法来提高训练模型的泛化能力。 对于模型欠拟合的问题，其模型的基本调整策略是在增加特征数量和质量的同时也增加模型的复杂度。 误差分析是通过对产生误差的样本进行观察并且分析误差的原因。 误差分析的过程：由数据质量的验证，算法选择的验证，特征选择的验证，参数设置的验证等几部分。对数据质量的验证非常重要，通常对参数进行反复地调整，在调整了很长时间之后，才发现数据预处理效果不佳，数据的质量存在一定的问题。 调整模型后，需要对其进行重新训练以及模型评估。 建立机器学习模型的过程也是不断尝试的过程，直至最后模型达到最佳且最稳定的状态。 在工程实施方面，主要通过预处理、特征清理以及模型集成等方式来提高算法的精确度以及泛化能力。 通常，直接对参数进行调整的工作不是太多。因为当数据的量级达到一定的程度时，其训练的速度非常地缓慢，并且不能保证效果。 引用： https://blog.csdn.net/m0_65121454/article/details/128178708","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Blender 仿真快速入门","slug":"03 【编程学习】/Blender-仿真快速入门","date":"2024-09-08T16:00:51.172Z","updated":"2024-11-13T03:41:15.408Z","comments":true,"path":"2024/09/09/03 【编程学习】/Blender-仿真快速入门/","link":"","permalink":"http://example.com/2024/09/09/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/Blender-%E4%BB%BF%E7%9C%9F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"Blender是一款免费开源三维图形图像软件，提供从建模、动画、材质、渲染、到音频处理、视频剪辑等一系列动画短片制作解决方案。","text":"Blender是一款免费开源三维图形图像软件，提供从建模、动画、材质、渲染、到音频处理、视频剪辑等一系列动画短片制作解决方案。 Blender 仿真快速入门01 快捷键使用 02 blender python安装pip install bpy pip 失败时，尝试离线安装 pip install bpy-4.1.0-cp311-cp311-win_amd64.whl &amp;&amp; bpy_post_install 下载地址：https://pypi.tuna.tsinghua.edu.cn/simple/bpy/ 注意在指定python环境下下载 Blender Python 简易参考 - 知乎 (zhihu.com) blender 4.1 软件下载地址： Index of &#x2F;release&#x2F;Blender4.1&#x2F;","categories":[{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"}],"tags":[]},{"title":"写作--最高层次的思维锤炼","slug":"02 【生活】读书笔记/写作--最高层次的思维锤炼","date":"2024-08-14T04:07:44.354Z","updated":"2025-02-19T04:10:02.105Z","comments":true,"path":"2024/08/14/02 【生活】读书笔记/写作--最高层次的思维锤炼/","link":"","permalink":"http://example.com/2024/08/14/02%20%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%86%99%E4%BD%9C--%E6%9C%80%E9%AB%98%E5%B1%82%E6%AC%A1%E7%9A%84%E6%80%9D%E7%BB%B4%E9%94%A4%E7%82%BC/","excerpt":"阅读使人充实，讨论使人机敏，写作使人精确。——[弗朗西斯·培根]","text":"阅读使人充实，讨论使人机敏，写作使人精确。——[弗朗西斯·培根] 写作——最高层次的思维锤炼 阅读使人充实，讨论使人机敏，写作使人精确。——[弗朗西斯·培根] 最高层次的思维锤炼，大学却没有好好教过你 “因为你来到高等教育学府，是为了发掘真实的自我，每当你为了图省事而放弃真我时，你也在腐化你自己，这可不是无所谓的小事，你的所思所想也会成为你品格的一部分，伴随你的一生，塑造着你的价值观和世界观，指导着你的行为举止。所以要注意用词准确，专注的训练自己，让自己尽可能准确的表达，没有技能什么比这更实用 更高级了。正因为如此，人文社科才如此重要。你可能会想，人文社科有啥好学的。但如果你毕业后，口才 思维 写作能力俱佳，那不管你去哪，你都是向着最高处进发的，而且还有可能惠及周围的人，这就是我给大家的建议。”","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"毕业后理想的生活","slug":"02 【生活】读书笔记/毕业后理想的生活","date":"2024-08-01T04:01:35.727Z","updated":"2024-09-27T18:54:30.435Z","comments":true,"path":"2024/08/01/02 【生活】读书笔记/毕业后理想的生活/","link":"","permalink":"http://example.com/2024/08/01/02%20%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%AF%95%E4%B8%9A%E5%90%8E%E7%90%86%E6%83%B3%E7%9A%84%E7%94%9F%E6%B4%BB/","excerpt":"加密文章，输入密码方可查看","text":"cb4afab22cc7d56dbc63d3b0f77ff684c876f061e9fd20531b0052781681ded60f3d3d759c69d68444e058703c3ef647d4ebcc19280cd13e660e57c47702a38b9315261ca97e691665d0173d708fdf559287dc2933ef461dc9e5de03f2204c8eb379169e7df3d1906492455fbfe3e8f5159e3ad3925a84d1829b58ef0fdaa56052403fb8660fb2383affbf6b4c4b3086d61c846a67041de25da37942acc2b28f7d0bb07e2ec9fe80573ed7e41c90ba7bc43353a129664721f890678b05b404e0e87875c5fcb452954914b00e72c36a8fbcae7ab0aac3839e50b88e5c69d2fbf12beedb694262172456fa719d37d0ff17c5573d84bf0cbd0cedba7f90e04da502243df8845c8461ec0331a63e38d6055013faab7ffd6b1542061dbf9e4d3b989bce76119e0cb52313dcc33ff19ef791e20dcfafe329fa8be79ea7837ea078714fe3b4cfd59ae360c5793b335879914d33055c7b01d33b175629dce7f93534de196f3c191ecd9f3a3d9df34abad185d702da29299feac7fafa0c19652f6f72a0ec667fc45e1079660b7910df9a172cfe873215c3e62b2fbb41d7219e204e3cb9017ded6cc9d0db9168cded3623b085856bbff18a1b5d224d2d41620cd90c000ae2d7bff2d722af3ef6dd23a339311c4390c37bdf4321dfa332b23ff31662269712112b706fd2d3022fa6f4f7778dae1e107fc7033dd1e9622ff4c2ebd9090a80edc53b840d14c14878fe6607929522cb5bf28753701a47eff71999cde7c66a4636490dd03108d13467d04711ee41a5cdc53abd9d7bfd1fa3e1f11470c7a36f37331c90eb178de275ee39ef03e2a47d82d404612431a75b65e5609950e1fec14bae4d4c99c6a2a546d4e08312eb33d8080867c5d4b4d50ef111ba3a63344cbeef9bdcf90e659c3ca7dac3f08fe8ba5c37288f2c46cfd4b198e6dc628810e13660fdad61cc45ad0becb8ee7e50d4124d9a05bbc6106c55ad6ea125eab0043f92567b973076829c419e6fadf221f573087b20bd83ddb9b90f1966ffba0feb3280282a3954c3e0153d85b1fb58686e1b370b811ab45acba3387dfd25c01dffce24509cf488ee09f4c145d30b7ac04b4bbe67d11e6bbc4dd2ca6553d672e0734f5136caf6b8ee7bc091c6673d59ca2071b28a9b16bc706afffffc0735b0b5673296e1b7df54512f71a028c037ac396b0bab24afa5f8b251010526f7a3ae32cf3f2bd2cc9b508f7035180c44ff5c9b1a18ddbbc6dd650a25e24149c190b1cbbbdc1a0ca3b1f6688aa78d47ee05e186eed199b5eef1123d42db871b9061bbabf33cdb1066723ec5d466336ce543f439d5f45e05f23509e9ad8eef3d11f0656f8936526fea5d838f7563dfcc54c18b30530d507792f66c24804abaf635d44d84cad75eb1a2e22e30191c4aa3b483d583f56d4e699b626ff89265007cb97912583bd37faf6149edf0093fe4eafdd9a1297c84743156ada2c433957d6cabb75aa263c3b92fcfcc9043c845a8b647e4bdfd1e5e2509dd964052e63c724a05cae669dc4917c0f45417b7c94d7062107b2b24cfeef000482e1d052a4cb828e2dded51ddb934b64d8cbdee6f4c4e4ba3564c449746948ae82dc08e119f036dbd376fea53a64e756eef87739c3ebc7a0682199b0d06420d6865ad6a40f02718af599b5f9facacfbda671283cd8e9d756ac1189cf330c0a3ff96d42825d960f1586b59e9a9eb195a3cd06dc5e976e295dd9739b7fb5e851598578b01fa250b95314db39afab5639308042bf04e17e7a6cff0769a40c424cc4e302e5bf9c6530e0e308b07e129d14707caf37328b2698ea76ac8266e049093b76ad7531db311482eb580535c40447d7c 请输入密码查看文章。","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"http://example.com/tags/%E6%84%9F%E6%82%9F/"}]},{"title":"个人博客的完善计划","slug":"01 【工作】Logbook/个人博客的完善计划","date":"2024-07-30T02:34:06.105Z","updated":"2024-11-09T04:17:56.809Z","comments":true,"path":"2024/07/30/01 【工作】Logbook/个人博客的完善计划/","link":"","permalink":"http://example.com/2024/07/30/01%20%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91Logbook/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%AE%8C%E5%96%84%E8%AE%A1%E5%88%92/","excerpt":"www.cvhao.top","text":"www.cvhao.top 个人博客的完善计划 更新域名 解决评论问题 修改用户头像 添加标题栏logo 完善搜索功能 2024/4/25 更新 修改文章内代码样式 2024/11/09 更新 添加夜间模式 2024/9/23 新增 分享30篇技术文档 字体样式修改，文章内容排版优化 2024/10/15第一次优化 修改blog&#x2F;themes&#x2F;volantis&#x2F;_config.yml 文件 添加图片加载不出时的提醒 添加网站404 定制提醒页面 支持latex 公式。 在Front Matter 中添加 plugins: -mathjax 文章加密设置 2024/9/28新增 支持 jupyternotebook 参考文章：在Hexo博文中嵌入Jupyter notebook 支持emoji表情 博客以及笔记地址 博客地址 地址 备注 博客园 www.cnblogs.com/cvhao/ - vscode 博客园插件 测试可用 github+hexo www.cvhao.top 2024&#x2F;4 已更新 gittee+hexo www.haolee426.gittee.io 目前不可用 有道云 印象笔记 google Blog oppo备忘录 参考： https://hexo.io/zh-cn/ 主题配置 - Volantis","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"2025届计算机校招查漏补缺","slug":"计算机校招面经复习","date":"2024-07-29T14:13:27.000Z","updated":"2024-09-10T05:24:00.022Z","comments":true,"path":"2024/07/29/计算机校招面经复习/","link":"","permalink":"http://example.com/2024/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F%E5%A4%8D%E4%B9%A0/","excerpt":"https://csdiy.wiki/","text":"https://csdiy.wiki/ 计算机校招查漏补缺CS自学指南，北大CS GitHub共享库 https://csdiy.wiki/ 小林coding 小林coding (xiaolincoding.com) 面试笔记 CS-Notes 面试笔记 (cyc2018.xyz)","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"404智能视觉实验室新生指南","slug":"404 智能视觉实验室新生指南","date":"2024-07-15T12:20:00.000Z","updated":"2024-11-18T02:12:44.496Z","comments":true,"path":"2024/07/15/404 智能视觉实验室新生指南/","link":"","permalink":"http://example.com/2024/07/15/404%20%E6%99%BA%E8%83%BD%E8%A7%86%E8%A7%89%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%96%B0%E7%94%9F%E6%8C%87%E5%8D%97/","excerpt":"加密文章，输入密码方可查看","text":"7dd0d79e949636a8d4da2f399a01bfc540a5f0a870614cc0cd2218a4137f56d27b6fc9ca2bf6a37779fc4895b261ab76beaead3a2aafc6fb3c99ceb502ee44cb4dbd4ef005ef686bb19f30eb597c075c3a291446cea356bf6f6a56bb8d9c3499d3d9d1e35c716067e85459eacfa4bf2f6a111086ac9d5d0bb1be9a13d980a408c97cc389ab33b4b00c72c5189ae6cb757f5fdcab3e9223c33d20ac7bcac74e0495c0d23f234143f15bcf1d07c2850c8e476d3344089e854f2fded018aa912462163af652ad405eda9d1d70fcfdd7044cb57f36a5f1764d69ac028ef4a90044e5c72fc2a44bb1bded8aaa1d125df5090f56491d4cb4c61e5bf4ebe1cd294b999de75f34d2932dbd7f3f4b788dae20507fc29801f431ebb74f715cbb9e529d6cac6c3fe251e125033d0370d78903dca707c7fb51b8d166ce509aa58f432e07d3c94a0b9b9e3595ed9df83ee1e18b592681ae7404a613807f613deac655cc423e24e95645d84a9dc0888a4f6b97d60439bc48bd038fd4722f2568251b369b01283890497a08f8fdcba34b70e775b9f19c00961340a1f0b88764c5cc192842342f2583d560b9f8f1061980e21fcd0912da22e3cdb65d89f924dc92cf9bd2c4b8c2d5c9e53b7009c76da9b4b1b54c4313eb372a58f60eece3cfc162e98e2ef99c3f38ebc56050e9dee78e9bd5e9d3df2bc11b83c06419b659ba23391fed7d023544c90136b7b51c928baf15e8bea826493f9294122caa47bd1c82797fae6b367a3bc7405f49be9d5303c7e48fc57a1717aeb6fb95a1ecdeaa63bd08b82c95fccafec289cab3fa586fbf31d231e5fd58eaa9765e6fd6de85564371d2f2be2bb44f76e700b8595878e203c9a8746d2db65e0cd60f08f9cb33ed4833c3b2ff4691a8638fac8b340667186bbde220e6a54657104dbfe8b615f175729aa43c21b268f687db1e6eb77c10431af8bce9da9a64ec262d5dc483a2d6cee41274115bca44c753153affc76cd018331b4d0814d130477fd9873cf9eab14a3b08b2a3a19c4d81007e3770af93b8b649721e1fff7c17d84ea8c095f153029ad3f094424fd0a5c53c1ec0324f664e4c972a6d960401fcf7662cb61e86b0f10f0dfa1d16e18d1aa3490512789bc1e16bfe33bb100e74e122357a64a941dab129dba6ba99e35bb8d61adf8547c56183cada3d2d04a534207dd0fea4bee85e39d34370a58394116bbd96f2a463541cf29c9d8694050360d7884f28ff12ec45968f09c66a82e3d318374d03f321171926a3cd4c8e1baa8ad37329ca08f634fb4ba23fb6fbd39ac5d3d6b97aeb318ca21d6ca18de9f82ac977aa808776bec6cc23b642ea2142eb26a5c0c50ccfffd61fa29b57a03b300956a29207f2fe6626f95e36d3a4ae79747378f991003b607b95554473d31efc800b816ce75b02c2dba85302ff7b87433139ccdffa31757dc61bc47e008bd14ca9079e85871a1df82cda23ebfe083a8aaf45ed747113c40f1f9cbe614d509888149e9c256f97e7077dbbf5f1f62fa9d8c2dd6e8dd0c0b3de5f4009518d97f545c6d069167c03c79402d103a42a3e3cd50bed0a0706edc2df5b01cb1f41ebe30b877257255701778f55773707c399e96d232c2a947aad54c59231052e4325a75f147a57c003c308f86e304022d9e342c6239df9df73d2db96101e5cd96fb0eb44690f2235d1c7431bad3543860623f9b2fa0bd23dc9b24e1acb3ce726c52d798ba72a4852e9215faeb8b3787579fd9fd99d1fc248a99972bf5419c5cf98406d7e6c38fa324fc75aaac14f075c1d9a28452892dd217ab5cb1f1b29ffd6d089313f55913d0fca82351993caf8f7b960c68ee40584476c3a68fa34c94dcdfd698061023bf7507ceaf65a4e2d87e05093094442ea39e41909806d856be8035199b85c9a32def66f75d0445c7a3a46b5f5b9cc63428d0950f24af0f06f14e71da69d63373b082bd72867afa35a417af8aa47ecbc677624ee8277883997383b86f39bef61615ee2b235f6b6c5de0724228a962679f7c3ed9ce227c65c232d16112d4eb351cdbe862fdc4ac61fee66055cd161cafc9d39987ca5ac2ff4b2acd660ded31aafc472f6670441b503e0331abcbe7096049852d669835d619fe2850edcfa7de938c21afe524849657c2e05b0877ad839207bbfb7ae6d987d373a6ba43dedb80481eea8fae7a13c2a5f76feb9b1b941818342a76324941cbd37d465ebaa2dec254251dc0ca413ece1b569b7f62778caf1c2ead282b47a049b9e41cf99e20c9a89dfaa8ff82cfbef6c32cdbe150c690d3c4e3e4b93ffbe16db629eaf1f45440cff450623a5d9fa13384ad2af53c61461fe43eac75e71f299173cab7821ec12790eba0fd554001f7db4c512bf0e77b91e3bad1a902ab2bd0923ce17d2974c1b8d86f1d96557582e3f86e47d09bc46390e2afda4da60fbf33f563424a0a6921eaadbd6307fd425d74266430b221792af5860819ce58165265eaed8a58fd4ac82439c600ed318dce3229c841befec6f611866a5199b01e1e910d59da7d5ec44a786b2eaa2771b09683c0245f148c9f8acbc1de837b5e68218fb05f66807c9ac9f60e3a722c2781822446a02f229221cf313548f380ec0712a2fde049343ab7c36f7faea4a01c4248db73b4d46473a02e3cf04499149dc20a1053d9cc5372de86b64cd254d1cd1705080bd8685fcdd3c95f438a282338120b6d51d672805f605f9de71b486357b0061510c7b424070c7eb73925bfa51e279a3bafe520dcd736f4bd0cc17a8a51b406c9750b9d98f5d9f8e30cd32d9576d3a9799be6d9aadb8b0bba564572a7a47b8edd0ea7ac2618679a90010bca2706b74313abc5c8609558b5cf5e04acd192462463ba2f5872674700f5e104f4965f675cc349c8a1c33a2e0aa29319e0b222fb18481f1e7f8a3baa0b279174d7b9bd841fe1d5621932000fc47804232123576653614804d1db05920ade69ebb25ea997aa73e861d8a626b73b66ef7a5dc864ff8b5beeb60b7fa37dc5173fa5cb847787185e7012455109f2c28e91f67acce14cb303ff931eae509b98419410581261d06721b038028a185c8b1b90bdfe629713cc0e31452e589bcf454806988fa556226bfc623bb0fa0656a1b95bc996053234c8e1f3b1a0155d788d01a996219f93d2e3cdfd0ad975189b721d8f5cbf496ec5887169dbb3ea08b0498aaccf4393f24af98bba2d308b57fd2ae21227b1c9f2fc4f3a4efb6519597a34e5f08c351dfe705c37af4f7399be30efb5584e6ca610483f93516fff8722df300f8ea111eaead3eb63b70337a053f12445a10c125cf9b72df85c65aabaf262ebcd559ea01f43b854050663aefb426fcf3d5217686b3b8fb3e6f3e4ab4dccf59e9f0668f8d891e1fe3affe6fbcac39aa8665cbb095f639dcd06815bb15413adc61b71115d87518295746e578db75b438d037f7c545bc702fb5b8d01ce9ad3b2dc3ed88d3ee9633f9d69d4896e496b200c540ca0a397586f2456214f38326038ebe6b03b5bc358b1f58a8c99e3bc60039c9ddeb73feac5389ebbbaa6702a2d1c75683ae6a722e7cb3d5b3bf2ffa61287e5598a2395675866b281b623ba91abef05ba9e4a42a3873a1a2289d0619373749aaf695d68bfce12751a837b5719fc4e06bea1952b155e4a03bc81f60507a145e72e1ab494b40597ac891b7e8f3d25c5b78584e8eaa77a1c9ceb7d1ca092ae149c72169d1de239bbb03789254333bc465276398c3df08ba72d47bd25c82144f3c7f6c14a754adddf23251be7d49c795c29135b0537285c0aec92aad7416a0390b1d7dea9034697b3a6c96261560625a000c9b65624e068ebc5bd695de52c33af14fc26b23cd786e74d073a1cf88a89124ad882c6e28f51b25bd1a43a2a352df5a0ad07a762e77653b1fd1ec20cd74b293f891551890096560832dd4bf828518c9d9977e2144fd2b5a4f25ac98519d2ac159837ab5f98c9d99add2ab1e83ec55f483d8bb62ed41e1b7890413b11162e63d59f6d51e95b9d63e9b04c1e7efb542875c0db34467d1ed2bd2ca6ad9080b7e2e7e4395b8255edb71fb27f715ec8220742d3e8fe1b2bbf373420ef193ad3c1ce55230255f071b4c926c3f72b8fbe8bc1cbd8df2165db1d47000237d4d9e270bcf09a14e30793ed1ce74d557b60680f9c57e725afb69f78aa78ab9ceb4346444703c223e7403ca20ca3566764137a33167667c162224e62ab1af040fde0be398ef7cbebdf48e6a7bb89599408026cb5695d93d60e16c04abc62ffab66ed97e70b39723530ed638fe5190607313d0f1def69295ac070af8846c8c681a1775daff4deca5cb56156840561dc71b0e0cfe3f4c6f98c452a35009e1c19986b04569b48215c092bf703fc523a2bd286f1cec1cff00a57132148afbb90687dbd8f4bc35f77c69f0bdbb42d6be1b37cea629ac65e8ff90155e2a8f13b717bc8ddd513ce5e8fd109fc6ef247f2f9b60b07bde101823b3c8819ce9e75eea16f0825fdbae3a945a8cda8abe43b416d3d6bedba718468cf24a585ce495b746c826901a96571a7eab442b42680bcfcc104759e5fa611a1d7a529f13a6810ea409e2d22973ce3e8ef0036b598f8d32dfe437d3ed58b7d10d50fe9a57ef4aefa61f8628218a51ba78ca9d1a8fc1c628539f1fd2bc6cdc593a919bc1f9adada06a8c926c3d4b69e36fbcef058e3e5831a238bbbafc5263e506ff6a6c503e2deace2b83effe51bfef871af9641be8cb2ff10325995786ea0afc827e7d52fa8ae515167a1eb60e084fce3fea983360a2f6df9dc345b49b8da2916cca1bbb19b1bc3edbd684863812ffff0b6af4b36ff44143e32da112597c36777674571df2323b2fd8ed578c484a618c0d8d2cebdbdc60f3f8dbd245a64663f93b74b078301554cef0adc5f91392a1a4a190ad6b5376750cb229759b958b733c2459700febebff703860283d3367a1c8c1dd4f3d6dd5c027368cc6848cbbca7911f70f102783ddd73a85a200267c4daa31eadcdf3f504f6267b884e9d1862309b6e7cc2733a766cbe7d786b51c868440e34b0476ddd8be4f9ae90af5a14a05190d30d3b91cbb60d7f0858913f48dbee13efefd06593825625fad8cc533f7c43143bbab16630ffd06fb63358b769bd0e3e071a65973a51bbdce4ae552eea355e81bba169c4bb5f6f08106f615a9f60a906ed4fba18c0ceac3411da56ece3978fa8238433f1540d1e5dda18567bb2160af4753c861231d0afeee8185ba68d02ca5073211c36ab553b7a47413fff57b87e1fcf3a592a95118fe627e034aa7de7a3988c7be61e1c09f15326a0469517651fc9317eb6b5e1b664d0668e95eacba88e475b8fd8b414433abbcdd25f25be20903970149ed1841f72f7844d82191336677c2af7b72bfe42bd0c9e9f6cad488dcc07dd95ff387d81ad5d5e718668ec2708576cd0ab9ba56ac19811389e439614cb13aace56bd337b064c7ef6aa95f336f84c466a386632a98f044452594bd5d0b4827585d257745ec309f8f96ab912efb79c254c6cea6f7f81dcac33b2ddf73df3e6557cfdbf05902d7b8db10202d79c6274e6ef5d89a85d03bff628dd5b417a352097ae86b9ce7c56845f287528ffb7c96342aa97f7afd367d3115037a9627be2f424c108af72f296e6bdb614be01b5c972ab4ba9bc97414a53369f975158f206f118ffcfdb09b62bbdcca8c22bad6862705d0c359012f7097e62b593c42e0d9ee2c91adf40686445696e3509070297cddb3fbe97b0b204d8e5e9f3b577ef0c506a5151fac8142f43c6ace9347498ed5a7f0e04959cb31ddbd43479b86d53c4a4e485b20bc7dc2a4264cea0d102b4b5515b4a46e64eea5cb681a80a7a15c6999981d097a265874fbb7870c945399ece91ca1f2e9f2ded49d01a4d4376b507dc1c1936dbf418d71d1e25eb28a86fefe42a7cb44dade340364d31d18c90fa098315ef1bc31b421a50caaac1e3ef05c24f79da50ef64a09854073def7d06ca3243a1955fe04ef367e183ac295c756886e881af7ebdf9db964902c18a43cc7d2e922cd8f3663ba7f3ab81d5bc50790d12da94d2c7914cc1127adc75add5434b2c4709bc664733c5973301314a99494b3995500061b00bc6c84492524d97e9738aaf97b2363d90176d2a2b3646d4a50457d80bf937feb79757c7510ab2b89716f31336df6b39a33b93a1696c41f3e0f11b10dcb272277e13b8b2b0f2b48416a5af20c3f3591184815136450b55fb9b87d2490138e20c6d4932ac6f1598df41f7fac91d6f271bc8cf5003a6a1edb82b120181a40582066d781d4177e02781fea2873bbb9a42042f9e3bd6ee77322ddd5a98820164b5ead0b3a97995b9e8c1afe141df2da66d2c5eb09eff5b0fdc343dc5eb9323fbb36c0c1809585ca80318343288e1cec59cf6526c3e73ef897853ad0330b08add6bfc43484f772eefdf350a8b48c7ae961da0e85c48f30bfa21fed3f4502c4f88b53981cb5b457f7b34593f30454a9c63cf076c71d109d13233965191e529f959f530a83a567fe0cf8ec1c27ab005fc23a92dbd60bee9fca43b43f8f1d1807ce3c59034ca44a7eb4d713cd1eb59eb00591b48766e83245962fbde177c4573e327ca7615d2cdcf570fe8f1029d9b8de9206139a0a1bdc7fa7e602a42165fe966a819b421384bc3d04fc7d415fe960c804cab2318a2f7f396e892f7f3fe23756608b21ad773edc80f789a6394791980500688061d57d65fff179e4591bc6f46fc3e772abe94ae8f18dd08e3852e3a1170f339765b2ee8ed195a4ff92cdd6bd1c3cc045e9465d3c1c68ca5f762ad9a0922b5404f48bb3fedfcd5abbffe6424c287921fbedba4f027b5519c2741dd60a6a34539abca5bba6eaa0b5903c37566779ad1895b05c883e739a057f8ef2782c188badd1b5af6cd400a8f7fb8332d7f412525428c624d0cad44af816755b4fafea09a96a0d7a76b59b4cfa6906692c114d535718f0f46fb12e9cca0578ed6dfe9f6b7c92e5965db23957a06a2c9538fbc2df0ef3fb40cf8ffd2718853769028864da7f38089fd90618844fe27ab845ab9674210868041505bf52dc4c6c60d43152816ca80fe24ed6c01629bf2853de809b24932534a7565d6eecaa699cfc6945144236fdc8dce06607c9be8d49f28d1818c3b74eb47534881e361d67747cd0291e0310a33708c2d67252792bb5338e832f5c0c8d197ebccecfca42f74f5fd4dc155d8cf7b11693d7c085d1e885016ad7432f68bf65dc59d30af65c7f8b78449895fdaa37d52b946221de80804d1f18131cd26fc8c77e434f9818092f32567700697755706edb5e9154350afa415b5cb112e4f28e6bedb0c6b1e9d8cd1e129dc62d1d84d89f28f890175a0be1eae37bf258faab202955183abae77dc182e073c71699ce20fda86f563e958f04b7b2843da0574016bd61f66e23ccdc656edc0549a50e104d3165361086debe0aef833174ce13702c68c9b45c461f6fa4b3611d5cf9be18c08f2463989e93c05462ebe1448bef8b27a3b4a0d1c7819a690529744b44b7c717c1814fc571192807a511ee6db16a7d097ba7bac88c6a5b0e7d73ae03e1e3b115bc34e9c2506f81067cd068475757119b0ca16a001e9e49e46c6151cb2e9bf1071590ad55482fba2e3796d1a935c4351e0f31a913fccb0b8d3acb2c22518e4d67b64df665e240acea7b841ac2f534d9a02b929631da9fca2ad5bd0e83c56ec8120838a5cf94d23f259cc3c88208cb4ca4a5421da9cf9a19953b4c879b89a38f62e9a89d557bae04fa9126fc721a1081397be69f28e40dcad3b709d778014d9951059cfb9c85ba446360b2d1cdd542cc238f49b912cebd2ed73f57ca201c2ea6111ea0685e3166f088eadf10236aaead77c25b39f41c41cdaeccaa90d65fe1f961e309e95ca93b36fc327bd2ed067aa8c68aabcce6665c0a25fb02a95ed3814382cbc32a88a2a3a66e63cf1f0840d7159491da839af837777b0052d9b6ade38d91c24effb124d5cf4fb4ec46c5bc45ed61ac3c1775105f66b3f45c61a0ddd64b96965c45b7ceaf0499b7a1a0a6ed576758cca8142d86d3f55317ef4e1f07e97211685da818bf499f788ce90a4fd7ddbfac775d96752faa75d84cfcf39b66c7b0aab07c1b2efcbbb00be640b0f33a20e7e7f21c04c028474cc41896b4eddff2d94e71eed53404595de421948de9032e27dcfede19a512c5c9ec87d70a10318337695634a2678bbf9458380e8837417a1f25a3c4ad7129cdf97babc9ac7ba7b5f8ad926afd14ab6c8bd9f236fb578a2dbdeeb7a3cff43edf8121d888d79b5d8e562eaac3e9b57176a1ab9fc59d3f00b22eae7c05734ba2aeefd059e1f6a566c037c85e2d67c9202f5cea6463e6bdeabf509ef609014b449186c5e1acb18403271b6acbace17dd7d20d0f47692bee820b7bc6e1d5f9ef469908f7529ab438da3c44bbd2fe791202f1a4f5a091818449fe1a79da122ae261e8f26e41be6f633ec1d8aebcf7306ef9dfca3bbade0f6e75181a19538d0055979b4ad273d8eac8744cd1f6a420868b3f60260908093db56d518fe8bf27771a7494012893ad9a41ea55daae7113fc74b7713eab7dc0bc5f67712fbb7fd8b345999b4f41fcdfdce25a9d403ad5e8f0fcbddc5f3b7920e503d99a1196721f91353fa87f3b301e35bf885e3e9536b5c76f8aec23de212031708aa3deb68f09ddfb8d94820dc93169fb568631f4341ac907253b0b09750be2d87cd130fc8b79a6e6464572eb6be69e644bf3a28b34fb25ca3c84cface7a81b60c3f47ffed04d08f4c119fc2bfa14c550473619acb264a61231ec0cd4bdedb464591ba0d6cd4767452a3735aa1920a46628dd8de0a06e2f31abc19de38b07064ad5c662984591f54812e37d854ad0575ba76f1e9ae08533bfa8d0b7fb6aa8c4c23172944448d169365797325c28034e5b60b55afbdabefaf067c59941206796017789096c1396ba57318483dd4d7ea1d411835aa1986ae22c7a1a3ec2475c31ec2569943d84889cb8c6ca4ca3030983a3abdbd358acda36b0fb31c4f340b49cd1d11158f643cd2c1576612df2acd74b858fc158580bfcc4c9dea746d4d1896d3095f719a73963ff439eb35f134eefd8c997a318244e0cf036747381d8ee68788b9eacbbc0f618e87367b481de37ebd3d2290cecaf5a131beff4c77082780549247fab5fe6b6c286574717658fa055a657079d1c490991e3c3c8aa5bd8976309d417929a38d30cc950ebf21a21b36bd40fe0d6719d58aed5059a93389e946f40956ac7c069f26678e1099dbc68ac4e6e1d5a48e868b29168384e5ca25f2688f2ff20772c263910492b8e075aa4bed78bb41c03dd665563e66c3aa0402184c626ae7b7ed2939c9602913c0e833966904fb63782100a1e43d4c224f18a48dd42ed602e8a68cb6d2388a98f2070cf25fe229fb14d7103a662bcc912eb104dff1401615ed59ba8c448d4134177ece7d3a1d0db27a200d62a454692746754b8c42d148c5051712632d84f0a646ebf 请输入密码查看文章。","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"404实验室","slug":"404实验室","permalink":"http://example.com/tags/404%E5%AE%9E%E9%AA%8C%E5%AE%A4/"}]},{"title":"《神逻辑》破解逻辑缪误，分辨诡辩，反杀杠精","slug":"03 【编程学习】/《神逻辑》破解逻辑缪误，反杀杠精","date":"2024-07-03T08:01:02.000Z","updated":"2024-09-10T05:32:41.295Z","comments":true,"path":"2024/07/03/03 【编程学习】/《神逻辑》破解逻辑缪误，反杀杠精/","link":"","permalink":"http://example.com/2024/07/03/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/%E3%80%8A%E7%A5%9E%E9%80%BB%E8%BE%91%E3%80%8B%E7%A0%B4%E8%A7%A3%E9%80%BB%E8%BE%91%E7%BC%AA%E8%AF%AF%EF%BC%8C%E5%8F%8D%E6%9D%80%E6%9D%A0%E7%B2%BE/","excerpt":"预设谬误：为什么胖的人都比较懒？","text":"预设谬误：为什么胖的人都比较懒？ 破解逻辑缪误，分辨诡辩，反杀杠精【嘴笨的人进来学，如何一句话反杀杠精，破解有毒逻辑，见招拆招、以杠治杠】 https://www.bilibili.com/video/BV1t142127hk/?share_source=copy_web&amp;vd_source=2b642316ba0d5f71a2bf75410183788c 一 预设谬误同事：我发现领导总是针对你，是对你有意见吗？ 女友：我最近变胖了， 你还觉得我漂亮吗？ 预设前提 -&gt; 观点植入 质疑论据 忽略问题 回同事：你从哪看出来领导针对我了， 我倒觉得领导很照顾我。 回女友：你眼神不太好吧，我怎么看你廋了呢 隐藏的比较深的预设谬误： 为什么胖的人都比较懒？ 为什么有钱人都喜欢移居国外？ 二 稻草人谬误诡辩者通过歪曲，简化， 错误引用等手段把你的论点，包装成一个站不住脚，容易寄到的稻草人。 这种逻辑谬误操作简单，效果明显，简直是诡辩者的最爱。 例子 女网红被指蹭王婆流量，女网红则称这个世界对女性的恶意太大。 网友针对的是网红自己蹭流量这件事，女网红把蹭流量的原始论点曲解为性别歧视，然后想办法推翻去接后的新论点。 破解稻草人谬误可以顺应逻辑，用他们的方式打败他们。 示例 谬误 反击 你跟你女朋友说你工作太忙忘记回微信 她说她竟然还没你的工作重要 我这么努力工作都是为了养你啊 你说你用的是苹果收集 杠精说你不支持国产手机，你不爱国 你这么爱国，怎么不见你给国家多交税 你说经常吃外卖对身体不好 吃饭也能噎死人，你说干脆不吃好了 既然都要死，你还活着干嘛 三 轻率归纳 记者采访一个骑共享单车的人， 你多大？男生说四十多岁。 记者：广东说这边四十多岁的人，一般都开奔驰，宝马了你怎么还骑共享单车呢？ 反击： 四十多岁还有人去死了呢？你怎么不去死。 轻率归纳就是在没有充分证据的情况下，用一小部分以偏概全做出一般性，概括性的结论。 要推翻轻率归纳的逻辑谬误，你就得比对方更轻率， 用更小的群体甚至是极端个例来反杀他们。 示例 反击 读书无用，很多老板小学没毕业照样是老板 小学没毕业还有要饭的呢，你怎么不说 男人没一个好东西，被男朋友甩了吧 走路上还有可能被车撞，你怎么还出门 一个女孩头发染成这样，一看就不是正经人 一句人话你都不会说，一看你就不是人 四 诉诸无知诉诸无知性谬误：如果你个观点，你没办法证实，我就认为他是错的 子非鱼，安知鱼之乐。 子非吾，安非吾无不知鱼之乐 缺乏证据不能成为证伪的证据 在证据不足的情况下，谁证明谁就掉入了自证陷阱。 五 虚假两难谬误福尔摩斯说，当排除了所有可能性，只剩下一个时， 它就是真相，不管它看起来有多么不可能。 虚假两难的诡辩者，故意排除了其他选项，只保留两种情况，不管你选哪个都是坑。 反杀： 跳出来提出新的观点，或者根据他们的逻辑再设两难选项 示例 反击 女友说，连个包都不舍得给我买，是不是不爱我？ 如果买包就能得到爱情，会不会太草率？ 爱还有陪伴，关心和理解 父母说，才考九十八分是不是没认真学习？ 我就是好好学习才考的九十八分，不然就是68，58 了 同事说，三十多岁还没结婚，你是没人要吧？ 你这么早就结婚是怕自己没人要吧？ 六 诉诸主观情感 在诉诸主观情感的逻辑谬误中， 诡辩者往往预设动机合情的行为就是合理的这个错误的前提。他们可能不占理但他们会利用和煽动人的情绪，比如怜悯仇恨这些，让你觉得虽然自己有理但好像有点不道德。 道德绑架圣母biao 示例 反击 我都道歉了，你不要得理不饶人 知道自己不占理，你还有脸说 你这么有钱，就不能给灾区捐点 你这么好心，替我还房贷吧 你这么打年纪， 凑合凑合结婚得了 你这么大年纪，凑合凑合埋了得了 他还是个孩子，你就不能让着他点 我又不是他爹，凭什么让着他 你一个新人，天天到点就下班，你好意思吗？ 给这么点薪水还让我加班，你好意思吗？ 七 人身攻击清洁工看到一个人乱扔垃圾就上前提醒，这人说：我不仍你不就没事干了，你连扫地得工作都得丢。 反杀 火葬场的职工也闲着，你怎么不让他们也有点事干 治服人身攻击谬误的方法还得是人身攻击，这种逻辑谬误最直白也最不道德。 不管你论证的是什么，我就对人不对事 八 乱赋因果 示例 反击 这个字你都不认识，你肯定没上过大学吧 说出这种话，父母肯定没教你如何做人 早上出门看到黑猫，怪不得今天这么倒霉 我早上出门看到喜鹊，今天也没捡到钱啊 学霸每天喝牛奶， 所以喝牛奶你也能当学霸 我们班学霸姓赵，难不成我也得改姓 在没有足够证据的情况下推导结论，假因谬误 还有 后此谬误 以及相关性谬误。 九 滑坡谬误考不上好的小学意味着考不上好的初中，考不上好的初中意味着考不上好的高中，考不上好的高中意味着上不了好大学，人生就完了 诡辩者往往使用很长一串因果推论，看似没有毛病，实则在每个环节都夸大了因果强度，把可能导致的概率性事故故意说成是必然事件。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"回读《项脊轩志》记","slug":"02 【生活】读书笔记/回读《项脊轩志》记","date":"2024-05-21T08:39:25.000Z","updated":"2024-09-27T18:46:30.687Z","comments":true,"path":"2024/05/21/02 【生活】读书笔记/回读《项脊轩志》记/","link":"","permalink":"http://example.com/2024/05/21/02%20%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%9E%E8%AF%BB%E3%80%8A%E9%A1%B9%E8%84%8A%E8%BD%A9%E5%BF%97%E3%80%8B%E8%AE%B0/","excerpt":"加密文章，输入密码方可查看","text":"cb4afab22cc7d56dbc63d3b0f77ff68440736eab27c9245462500bf2a83ce7c1f4f57285174bc933c312755c55d3a95ce5d1a5a226d32f4e40ebc53d5a0077d6786598d8172afccbe3fa445d0995cb000d3001f10dcd44737f0a8a56eaab9f16e7141e7c4f663dafd54cfb65dfef834404c0f644e52ca5e596f293c0b4886fd64bd3ec80ade3e656e967db01e33c66542617a6e18d0ee186b45598d5fa0749ac72cfc35f308904218dbad7350ed7c5db59a68bf12f14418fb838827b27605c1c9527c0ae372d60b22299c24dd2db0d2c666d4eac484f662985fd67a355cea021c7b53bd81ad0bbf69ebf33a908e5cf6c627d721da5cc5bf56522d5573ffa957b378c91ad86117576c747a606abd82cce09aa3fa7db75c8dc0386b43f2ae1170414365dafb8e0c15f0db9bb47ab4220cf680375083c7d5b3b98d3ff714e6b721fc153b48af8d3cbcd019c02279b26e42400d8dd9034ff064a1767e6a15df1610b7ced203a36608d58c285152b7b64eeacfcac1626758257f6c1aeb22b1a34ac8dac97b011df8b47100eaf1f66d0b2c653901bf4f75ac7e65a6186ae89c6210168aabefb2cb7773b3cdd933649c12caa6dc75eb756f6a4b21d86fdc278e79e1656482b52ca5defe43346d73d367412b79f4b98475a8722c0d0494db49ca1f94ab617fdffa2bfb52e853da56ddc1c8654c9a7b41ca5f779b83a3881e807d1016284e0f6c587f7c4da766d6e36a7ea39170eef3a4e7ac1a6533670102fb7bc0a233db0f4d6fedfde38f93618691537fbf6d60b520ee3706eb608135b3590d1a36215acfd08d3cbb0a65f3c45e268ff19b03d7a7d8e1f95272d34eb7b755dcbc36d08ac1f5305a1d15809f2fb6ae4e9d2f938e4efb8961077238fbdd0d735391bb39f3e57b25ed8bdcdd42d289a960d177520d5180c665ae35a7384416ab04d23e01a455294707de4ec9a379446fd8abb16f7035da1e0240ed40b9e7929020f910acf2409b8553ebce30d608e39f1cdf8adcbc9fa2d35963981993d85365756441e1b276bf1034e2b52f6447eeb89bbb9df4be59db94f06fe67dba8b6c5395ec275476370efdc55b5f145a38e182498f7c8cc154f81cfb10ee300de50ff1a9777dd2408c688d35ca57ca82e2c24763ef7c3e1a425805c43edc1ffa101e083d14faaea11a4f8f4e91be4f396f741b800f604ac4c77c71b45630d4c2b6cba064f3b9f738f486cd04bdca4bf70b99a4662871b673d7bdfe4ff36bd459e991c0caa08387e9c2ac3b8ab6471d4397afd2bd6d08afc7ccf0ef73751c50c66ddb7a22fe5f9e7a155a895c64d6d4cca7b35a5ee366e17680da2d942d07a67e48afb6c52280ec544a60a3a6915fac93b26780885344c76387322f8ee8c62618132fb40b81a836180de309d18b09c9c4081a2243d7db553e8751a2ae90fde93f8f55fc134ff86ed42894b7ba296943876f35a64594974921add0bbb17812dd4afb9bad708db7eec3fda6aa6d971e1960e246e5ea4b552aa37a00f2b5f9b5b5d7ab8a35e3e79fa85eed44208c8ddceaa685ac46c6f19e57fdb978b0c02988c57c268f953bb3ebfcbe027a19f71bd8e02d120b2dbfa55d8c11abbad25b9a066bab72aef15d31cc473cf29774864517f235af9071bdcc533de8f79de49aa9cdf79d7c292eddaf8ebccdbbb2ac0cf21e4fc812c3bea7de5bf68c00c6c67f0fa5ed3ba8d4d4c5e55d0fa85bf11463e53cba77465f4c42c51fdd501349dd53fd71632d518533407a400bd1dea3f8d3d257d613d57c769b28790148955f82b651f54b8511d30af69b03b70f3a2736ee87839942f6d613ed3ce322d10e8cf9d959d025ec4bd952a7e961976aab9647615f08b2a67b057a41f99fa5b916e00e21865958b85b12b898199318dd2f7977a734c24551ecd920c0bee59db683cc5f77fd2348dae93e243b5641a9b80314908ba11e88d77975449361771e441e1f060e9cdf369253e969f4ee93ab03cf6134a96996dc65ffd6985fcc80f79f525c06151c316b9524c9b89caaa7e0a59df56f2ea8d17c6fda176955e3020d456257f6b67d4a23afa834f6c4a73680360a3abd09c6b2a851b65f4d1b22a1841f9210ce8312601a6784089f9200c352ed84d1a125212dad023db417cb598b9e163dff587ce2367d2932bad3d82a560265b51e49a4470039d064c7f66d13855d900c9fe3e04f5b3edf9cedc96cb6e561ab060780dd8495ac19f41011b8ae783cdaf0fc4871dceaffa2cd3dedfa02bc5e3a2037a487cdca2c9b1fde0a3287fe4f008a4da4c8cf0b530973641932ace2994e7f3403cabb9e4cd5ea55dafb6413af3e2c8c13fde19d278087c18c481499362720775ee42abd1140dcdb9a61477b943be52ee6255b0a18fbca81e6d660ae7205e2ab7f02f2f9be90852eb0bf718fbc3c430ea365d177d854136bace240b29bf99894cb618a908dd7e358bd7b68a1a19ff927e61d576eef6490449fffca4dbb385112303f55dee765ad12735ef982af117f36374c99591a4eed8d07d686bc8d617ef055cc6d6b15ccb8d8608ce907a6d27d492e8a4905da77ec872f68d7c47bd928369651a3c305335bd2f758712e3957f4f8b611105fb4ff4cc91998e491892a10f1c26a71f344f897470c4241c09c539aaeb96a7516f8f8805940021bdbfcd1e57cee218ebce9f8ab61310722eed2c1cdd5cc3397d8e2683fe3f52ff7950e70b0ecb652fb0e60759c4b663027b5836c10595117e38c719d761e69878efef256b2512014a3afca40a32e3eff3b7c708304ff6cb04db86594c913baa1209982650d92fa8dd697f431fc6deb7fc12adab86bb21437475fcec4d6e8ef157b3a4d0d5a791c627c30a1db9b269d55398af2fa48f002f12c2ac4d332a9876d19e9c0ee92889eb0465b2c91003f7cb158cdac39cb4f2769d87dee6daaf48002b3ae146 请输入密码查看文章。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"http://example.com/tags/%E6%84%9F%E6%82%9F/"}]},{"title":"人工智能时代 我们需要什么样的人才？","slug":"02 【生活】读书笔记/人工智能时代，我们需要什么样的人才","date":"2024-02-20T16:09:48.639Z","updated":"2024-09-10T05:16:49.238Z","comments":true,"path":"2024/02/21/02 【生活】读书笔记/人工智能时代，我们需要什么样的人才/","link":"","permalink":"http://example.com/2024/02/21/02%20%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA%E6%89%8D/","excerpt":"早睡早起，按时休息","text":"早睡早起，按时休息 人工智能时代 我们需要什么样的人才？人才教育第一点： 实事求是，不说假话。第二点： 见贤思齐，要有同理心，能见得别人好。第三点： 鼓励多元化的标准。鼓励生物多样性，无论是大树还是小草都应该能沐浴到对它来讲充沛的阳光。 第四点： 哪些能力是孩子应该注重培养的？ 语言能力。 逻辑能力 即兴的公众演讲和辩论 鼓励孩子们的想象力。须知 人类思维的边界就是宇宙的边界 ​ 鼓励多去提问。须知只要能问对问题，答案就有了一半。 多体验自然。 对年轻人： 极致的自律，才有极致的自由。 读书，学习，赚钱，规律的健身。早睡早起，孝敬父母，用炙热的心去爱人爱己。有同理心，用你毕生的精力去精通一个一个的专业领域，低级的欲望只需放纵即可获得，高级的欲望只有克制才能达到。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"latex入门手册","slug":"03 【编程学习】/Latex 简单入门","date":"2024-02-02T02:54:29.765Z","updated":"2024-10-14T18:23:44.015Z","comments":true,"path":"2024/02/02/03 【编程学习】/Latex 简单入门/","link":"","permalink":"http://example.com/2024/02/02/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/Latex%20%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/","excerpt":"Overleaf, Online LaTeX Editor","text":"Overleaf, Online LaTeX Editor 安装mac安装 mactex MacTeX - TeX Users Group (tug.org) latex语法入门Learn LaTeX in 30 minutes - Overleaf, 在线LaTeX编辑器 Tex编辑工具推荐1 在线latex编辑工具 Overleaf, Online LaTeX Editor 2 vscode 添加latex插件 分享latex + Beamer 组会汇报模版以及开题报告模版 conf-haolee&#x2F;Latex-Beamer-: Beamer模板以及latex 使用 (github.com)","categories":[{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"latex","slug":"latex","permalink":"http://example.com/tags/latex/"}]},{"title":"文件与文件夹命名规范","slug":"01 【工作】Logbook/文件与文件夹命名规范","date":"2023-12-25T08:09:43.363Z","updated":"2024-09-23T04:58:08.629Z","comments":true,"path":"2023/12/25/01 【工作】Logbook/文件与文件夹命名规范/","link":"","permalink":"http://example.com/2023/12/25/01%20%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91Logbook/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%B9%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/","excerpt":"MECE法则：相互独立、完全穷尽”，即所谓的 “无重复、无遗漏”","text":"MECE法则：相互独立、完全穷尽”，即所谓的 “无重复、无遗漏” 文件与文件夹命名规范1）文件命名规范命名结构：项目命名词（或项目编号）+文件命名词+文件作者+日期+版本号.文件后缀例如：2016年公司部门工作总结_营销部_大鹏_20170101_V1.0.doc文件名称由五部分组成： 第一部分为阐述文件主题，观其名知大意； 第二部分为文件所属类别，如在单位工作的写工作部分、学生人群可写班级等； 第三部分为文件创建者； 第四部分为当前文件的日期； 第五部分为文件阶段标识，用于版本管理。 待归档文件见下的临时文件命名： 按照用途简要描述如： 周六导师开会用，周五组会论文参阅资料，张三简历修改V1.0版本 2）文件夹命名规范命名结构：文件夹名称+开始日期+结束日期例如：Prj_PC PIS Project_20170101_ 第二个下划线后为空，等待工作结束后添加结束日期即可。文件夹的命名由三部分组成： 项目名称 项目开始日期 项目结束日期 3）GTD思想指导下的文件命名为了更好的整理自己的文件，可增加了几个特殊的符号，用于标识不同状态的文件：1、！（叹号）——标注重要的文件或者文件夹2、#（井号）——标注等待处理的文件或者文件夹3、@（@号）——标注正在处理的文件或者文件夹对那些处理完毕的文件，应该放在合适的文件夹当中，因此不作特殊符号的标注。这些符号的使用，是作为文件命名的首字应用，如此一个文件夹中，标注特殊符号的文件会排列在一块，查找和使用起来会比较方便。","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"Linux命令行编辑界面 快捷键","slug":"01 【工作】Logbook/命令行 界面快捷键","date":"2023-10-15T12:08:21.263Z","updated":"2024-10-15T12:24:34.323Z","comments":true,"path":"2023/10/15/01 【工作】Logbook/命令行 界面快捷键/","link":"","permalink":"http://example.com/2023/10/15/01%20%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91Logbook/%E5%91%BD%E4%BB%A4%E8%A1%8C%20%E7%95%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"https://blog.tangly1024.com/article/linux-shortkey","text":"https://blog.tangly1024.com/article/linux-shortkey 常用命令 序号 命令 解释 补充 1 Ctrl + C 中断当前正在运行的程序或命令。 2 Ctrl + D 输入文件结束符（EOF），通常用于退出终端会话。 3 Ctrl + Z 挂起当前正在运行的程序，将其放入后台暂停状态。 4 Ctrl + L 清屏，相当于执行 clear 命令。 5 Ctrl + A 将光标移动到命令行的开头。 6 Ctrl + E 将光标移动到命令行的结尾。 7 Ctrl + K 删除光标位置到行尾的所有字符。 8 Ctrl + U 删除光标位置到行首的所有字符。 9 Ctrl + R 在命令历史记录中搜索并执行之前执行的命令。 10 Ctrl + W 删除光标前一个单词。 11 Tab 在命令行中补全文件名或命令。 12 Ctrl + P 移动到上一个执行过的命令。 13 Ctrl + N 移动到下一个执行过的命令。 14 Ctrl + H 删除光标前一个字符（相当于退格键）。 15 Ctrl + J 执行当前输入的命令。 16 Ctrl + S 锁定终端（暂停输出）。 17 Ctrl + Q 解锁终端（恢复输出）。 18 Ctrl + T 交换光标前两个字符的位置。 19 Alt + F 将光标向前移动一个单词。 参考 https://blog.tangly1024.com/article/linux-shortkey","categories":[{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"}],"tags":[]},{"title":"vim速查手册","slug":"03 【编程学习】/Vim 手册","date":"2023-10-15T12:07:49.240Z","updated":"2024-10-15T12:46:25.164Z","comments":true,"path":"2023/10/15/03 【编程学习】/Vim 手册/","link":"","permalink":"http://example.com/2023/10/15/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/Vim%20%E6%89%8B%E5%86%8C/","excerpt":"Vim 练级手册","text":"Vim 练级手册 开始（1）新建文件 helloworld $ vim helloworld 然后我们会进入一个新的界面，并且左下角会有 &quot;helloworld&quot; [New File] 的字样，现在我们在文件中处于 normal 模式下。 首先声明，现在 helloworld 还并没有保存在硬盘中，我只是“打开”了一个叫 helloworld 的文件。 （2）输入信息 按下 i 键进入 insert 模式，左下角会显示 -- INSERT -- 的字样，继续输入文字 Hello World，随后按下 &lt;esc&gt;（就是键盘左上角的退出键）返回到 normal 模式，同时你会看到屏幕左下角的变化。 （3）退出 Vim 按下 : 键进入 command 模式，输入 w 然后按下回车键，左下角会显示 &quot;helloworld&quot; 1L, 12C written 的字样，代表我们已经把文本保存到硬盘上了，然后再次输入 :q 就会退出编辑器，连续操作也可以输入 :wq 来保存并退出。然后你可以查看刚编辑的文件 $ cat helloworld Hello World 先不要管里面提到这个模式那种模式，先照做，如果你顺利的完成上述的操作，那先给自己鼓个掌，不要惊讶，你已经做到了 100 万人都没做到的事，毕竟 Stack Overflow 也骄傲的宣称“我们已经帮助一百万人成功的退出了 Vim” 01 键位操作光标操作 只靠前面这点知识，我们仍然需要鼠标协助完成很多操作，并且可能还完成不好，接下来我们需要了解一些键盘移动光标的操作。 我们先下载一个文本用作练习 $ wget http://grepcode.com/file_/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/Object.java/\\?v\\=source -O Object.java $ vim Object.java 在 Vim 中光标操作基本都是在 normal 模式下完成的，如果你有时候搞不清，那就多按几次 &lt;esc&gt; 键。 上下左右 h, j, k, l 四个键代表了方向键 ← ↓ ↑ →，这个键位是我们前期经常用到的。在开始你会感觉非常别扭，为什么有了方向键还要这四个键位？想想你在键入信息后手挪到方向键，再挪回来的操作，每天的开发都会如此反复个几百次，节约掉这个时间，就是 Vim 高效的第一步。 另外借助数字键可以更快的做到光标跳转，5l 表示向右移动 5 个字符，5j 表示向下移动 5 行，其他依次类推 翻页 &lt;ctrl&gt; + f 的组合键可以向下翻一页，这类的组合键以后我会用 &lt;c-f&gt; 形式表示。 &lt;c-f&gt; &quot; 向下移动一页 &lt;c-d&gt; &quot; 向下移动半页 &lt;c-b&gt; &quot; 向上移动一页 &lt;c-u&gt; &quot; 向上移动半页 以上四个键位在翻页时会经常使用，但是刚入门的话，我还是不建议你全部记住，只记住翻半页或一页的两个键位，在配合 j, k 精确到目标行就可以了，在入门阶段你要尽量减少快捷键的记忆量，在大量刻意练习并熟能生巧后，再去扩展快捷键。 行首行尾 0 &quot; 快速跳到行首 $ &quot; 快速跳到行尾 g_ &quot; 快速跳到行尾最后一个非空字符（下一章我们会讨论它跟 $ 的区别） 在熟练应用 h, j, k, l 四个键位后，配合这两个键位可以让你几行之内的光标操作更加灵活 页头页尾 gg &quot; 快速跳到第一行 G &quot; 快速跳到最后一行 拿 Object.java 这个文本为例，如果你想马上去看最后几行写的是什么，你一定不想按不知道多少次的 &lt;c-f&gt; 组合键，但是如你所试，只需要 G 就可以了。 现在我们已经学到了很多键位操作，我真诚的希望你能先花上几个小时的时间去练习它，最好是在一个你真正需要编辑的文档上来使用，将光标移动到需要输入的位置，i 进入 insert 模式，完毕后 &lt;esc&gt; 返回 normal 模式，如此反复，在这个过程中，你一定会有这样的想法，还不够，这些还不够，我还需要更快捷的东西，比如，搜索。 参考 Vim 练级手册","categories":[{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"}]},{"title":"GPU显卡基础知识介绍","slug":"02 【生活】读书笔记/GPU显卡基础知识介绍","date":"2023-10-14T15:38:57.030Z","updated":"2024-10-14T18:38:08.140Z","comments":true,"path":"2023/10/14/02 【生活】读书笔记/GPU显卡基础知识介绍/","link":"","permalink":"http://example.com/2023/10/14/02%20%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/GPU%E6%98%BE%E5%8D%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/","excerpt":"RTX 4090 , A100, A800，V00","text":"RTX 4090 , A100, A800，V00 显卡基础介绍首先什么是显卡？ 显卡又称为视频加速卡。它是主机与显示器之间连接的“桥梁”，作用是控制电脑的图形输出，负责将CPU送来的的影象数据处理成显示器显示的图像，最后由显示器呈现在我们眼前。 简单来说，显卡主要就俩功能：处理图像然后输出图像，其原理是显卡接在电脑主板上，它将电脑的图像数据转换成图像让显示器显示出来；同时显卡具有图像处理能力，协助CPU工作，提高整体的运行速度。显示器的屏幕画质显示都是靠显卡来完成的，可以说，显卡决定屏幕显示，电脑如果没有显卡，屏幕就不会有图像显示。 显卡的分类1.集显（集成显卡） 是指上古时代集成在主板上的很弱的显卡，现在已经基本见不到了。 2.核显（核心显卡） 和CPU封装在一起的显卡，现在英特尔的酷睿，AMD的APU都是有这种核显的，常见的轻薄笔记本，基本都是用的核显。 3.独显（独立显卡） 就是我们pc里的这种独立形式的显卡，属于单独的一个部件，可以做到更高的性能，也能方便我们升级替换。 目前生产显卡的GPU芯片的厂家主要是AMD(超威半导体)和Nvidia(英伟达) A卡就是使用AMD芯片的显卡。 N卡就是使用NVIDIA芯片的显卡。 快速查看显卡使用情况：nvidia-smi 【待补充】 引用 https://post.smzdm.com/p/a96emzz0/","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"如何实现mes通信","slug":"01 【工作】Logbook/如何实现mes通信","date":"2023-10-14T15:36:38.206Z","updated":"2023-10-14T15:37:05.825Z","comments":true,"path":"2023/10/14/01 【工作】Logbook/如何实现mes通信/","link":"","permalink":"http://example.com/2023/10/14/01%20%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91Logbook/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mes%E9%80%9A%E4%BF%A1/","excerpt":"MES系统全称 **“Manufacturing Execution System” **即制造执行系统。他是一套面向制造企业车间执行层的生产信息化管理系统。","text":"MES系统全称 **“Manufacturing Execution System” **即制造执行系统。他是一套面向制造企业车间执行层的生产信息化管理系统。 什么是mes通信？MES（制造执行系统，Manufacturing Execution System）是一种用于制造企业的生产管理信息系统，它通过对生产过程的实时监控和管理，帮助企业提高生产效率、优化资源利用并保证产品质量。 MES 系统主要连接企业的上层管理系统（如 ERP，企业资源计划）和下层的生产设备、控制系统，起到数据采集、信息传递和指令执行的作用。 MES 的核心功能包括： 1 生产计划与调度：MES 帮助将企业的总体生产计划分解为车间级别的生产任务，并动态调整生产调度，以适应不断变化的生产条件。 2 资源管理：通过对人力、设备、物料等资源的监控和管理，MES 系统优化生产资源的使用。 3 生产过程监控：MES 能够实时跟踪生产过程中每个环节的执行情况，采集设备和工序的运行数据，以便及时发现并解决问题。 4 质量管理：MES 系统帮助实时监控产品质量，收集质量检测数据，并对不合格产品进行分析和处理，以提升产品的一致性和可靠性。 5 数据采集与分析：MES 系统通过数据采集功能，获取生产现场的设备、工艺、人员等数据，进行统计分析，帮助企业优化生产流程。 6 生产追溯：MES 记录整个生产过程的各个环节的信息，便于对产品的生产和质量问题进行追溯分析。通过实施 MES 系统，制造企业能够实现生产过程的透明化、精益化管理，从而提高生产效率、降低成本并提高产品质量。 [开发mes通信系统注意事项 待补充]","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"me s","slug":"me-s","permalink":"http://example.com/tags/me-s/"}]},{"title":"SSH远程连接快速上手","slug":"03 【编程学习】/SSH远程连接快速上手","date":"2023-09-21T10:02:25.850Z","updated":"2024-10-15T04:25:51.468Z","comments":true,"path":"2023/09/21/03 【编程学习】/SSH远程连接快速上手/","link":"","permalink":"http://example.com/2023/09/21/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/SSH%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"ssh user@ip SSH 协议通过对网络数据进行加密和验证， 在不安全的网络环境中提供了安全的登录和其他安全网络服务。","text":"ssh user@ip SSH 协议通过对网络数据进行加密和验证， 在不安全的网络环境中提供了安全的登录和其他安全网络服务。 01 SSH 基础知识SSH(Secure Shell)是一种加密的网络通信协议。 SSH 的主要作用： 远程登录 数据传输 密钥认证 以及隧道传输、端口转发、回话管理。 通信模式： 服务器-客户端模式(Server-Client) 02 SSH别名登录使用别名登录方式, 需要打开～&#x2F;.ssh&#x2F;config， 追加以下内容： Host raspberrypi #这里是别名 HostName 192.169.31.48 #这里是服务器IP【注意这里开头空两格不是tab键】 User haolee #这里是用户名 raspberrypi是haolee@192.168.31.48的别名 03 SSH远程免密连接 配置ssh 免密登录的原理： 把你本地的公钥添加到服务器的～&#x2F;.ssh&#x2F;authorized_keys文件里 【小知识】第6期 SSH免密登录的原理_哔哩哔哩_bilibili 什么叫SSH？原理详解，看这一篇就够了！-ssh的原理 (51cto.com) step1: 在本地生成密钥 ssh-keygen step2: 连接上服务器，进入 cd ~ 打开.ssh/authorized_keys，追加客户端下id-rsa.pub文件内容进去。 快捷命令: ssh-copy-id user@192.168.44.21 可能遇到的问题 解决：powershell无法使用ssh-copy-id命令 - octal_zhihao - 博客园 (cnblogs.com) 04 基于SSH命令行文件传输SCP 使用命令行实现文件传输， 使用一次命令传输一次 基本语法： scp [可选参数] source_file target_file 使用例子： 本地文件复制到远程： scp local_file remote_username@remote_ip:remote_file 远程目录复制到本地： scp -r remote_username@remote_ip:remote_dir local_dir 可选参数说明： -r : 递归复制整个目录 05 可视化客户端SSH连接&#x2F;FTP文件传输作用： 使用UI软件实现ssh 连接，文件传输，连接一次可以多次传输文件。 Windows软件： XFTP XShell Mac软件： Electerm Linux软件：Remmina 引用： SSH+免密登陆+VSCode远程开发+GitHub免密","categories":[{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"http://example.com/tags/SSH/"}]},{"title":"C++ 实现word读写","slug":"03 【编程学习】/C++ word读写方法总结","date":"2023-05-23T02:53:57.477Z","updated":"2024-09-22T15:33:04.610Z","comments":true,"path":"2023/05/23/03 【编程学习】/C++ word读写方法总结/","link":"","permalink":"http://example.com/2023/05/23/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/C++%20word%E8%AF%BB%E5%86%99%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"C++(Qt) 和 Word、Excel、PDF 交互总结 - kevinlq - 博客园 (cnblogs.com)","text":"C++(Qt) 和 Word、Excel、PDF 交互总结 - kevinlq - 博客园 (cnblogs.com) 1. XML 模板替换 标签替换 事先编辑好一份 Word 模板，需要替换内容的地方预留好位置，然后使用特殊字段进行标记，后面使用代码进行全量替换即可完成 strAllContent.replace(&quot;$VALUE0&quot;, &quot;1&quot;); strAllContent.replace(&quot;$VALUE1&quot;, QString::fromLocal8Bit(&quot;法外狂徒张三&quot;)); strAllContent.replace(&quot;$VALUE2&quot;, QString::fromLocal8Bit(&quot;考试不合格&quot;)); strAllContent.replace(&quot;$VALUE3&quot;, &quot;2&quot;); strAllContent.replace(&quot;$VALUE4&quot;, QString::fromLocal8Bit(&quot;李四&quot;)); strAllContent.replace(&quot;$VALUE5&quot;, QString::fromLocal8Bit(&quot;合格&quot;)); ... 2. COM组件方式 原理：采用 Micro Soft公开的接口进行通讯，进行读写时会打开一个 Word 进程来交互 Microsoft 组件对象模型（COM）定义了一个二进制互操作性标准，用于创建在运行时交互的可重用软件库。 Qt 为我们提供了专门进行交互的类和接口，使用 Qt ActiveX框架就可以很好的完成交互工作 上手简单，但是写入导出较慢 3. HTML方式 原理：这种方式得益于 Word支持 HTML格式导出渲染显示，那么反向也可以支持，需要我们拼接 HTML格式内容，然后写入文件保存成 .doc格式 插入的图片是本地图片文件的链接，导出的 word文档拷贝到其它电脑图片无法显示 优点：跨平台，不仅限于 Windows平台，代码可扩展性比较好导出速度快、代码可扩展；缺点：字符串拼接 HTML 容易出错，缺失标签导出后无法显示；插入的图片是本地图片文件的链接，导出的 word文档拷贝到其它电脑图片无法显示 4. 第三方库开源库 DuckXhttps://github.com/amiremohamadi/DuckX缺文档，缺例子，复杂 没发现插入图片的方法 DocxFactory https://github.com/DocxFactory/DocxFactory缺例子文档，时间太久, 官方文档已经打不开 minidocx https://github.com/totravel/minidocx轻量化，项目比较完整，说明比较详细，但是不能插入图片 TO DO 可以尝试扩展 商业类库aspose.wordshttps://products.aspose.com/words/zh/cpp/edit/docx/免费的导出的文档有水印，付费使用 5. 使用python库间接实现曲线救国： 调用Python-docx库https://zhuanlan.zhihu.com/p/564081044 https://github.com/kevinlq/QtPythonDocx#%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85有文档，有教程，有可运行的项目 需要配置对用python 环境","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"DuckX","slug":"DuckX","permalink":"http://example.com/tags/DuckX/"},{"name":"minidocx","slug":"minidocx","permalink":"http://example.com/tags/minidocx/"},{"name":"Python-docx","slug":"Python-docx","permalink":"http://example.com/tags/Python-docx/"}]},{"title":"C++项目 实现word读写（二）","slug":"03 【编程学习】/C++项目 实现word读写（二）","date":"2023-05-23T02:53:57.477Z","updated":"2024-09-22T15:39:47.744Z","comments":true,"path":"2023/05/23/03 【编程学习】/C++项目 实现word读写（二）/","link":"","permalink":"http://example.com/2023/05/23/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/C++%E9%A1%B9%E7%9B%AE%20%E5%AE%9E%E7%8E%B0word%E8%AF%BB%E5%86%99%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"C++(Qt) 和 Word、Excel、PDF 交互总结 - kevinlq - 博客园 (cnblogs.com)","text":"C++(Qt) 和 Word、Excel、PDF 交互总结 - kevinlq - 博客园 (cnblogs.com) 使用Python—docx库https://zhuanlan.zhihu.com/p/564081044 https://github.com/kevinlq/QtPythonDocx#%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85 参考开源项目： 有文档，有教程，有可运行的项目 需要配置对用python 环境","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"DuckX","slug":"DuckX","permalink":"http://example.com/tags/DuckX/"},{"name":"minidocx","slug":"minidocx","permalink":"http://example.com/tags/minidocx/"},{"name":"Python-docx","slug":"Python-docx","permalink":"http://example.com/tags/Python-docx/"}]},{"title":"QXlnt 实现Excel读取Demo","slug":"03 【编程学习】/QXlnt 实现Excel读取","date":"2023-04-25T11:53:17.000Z","updated":"2024-09-22T15:40:13.793Z","comments":true,"path":"2023/04/25/03 【编程学习】/QXlnt 实现Excel读取/","link":"","permalink":"http://example.com/2023/04/25/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/QXlnt%20%E5%AE%9E%E7%8E%B0Excel%E8%AF%BB%E5%8F%96/","excerpt":"介绍： QXlnt 是一个基于xlnt库的帮助程序项目，允许在Qt中使用xlnt。 xlnt库时一个现代C++库，用于操作内存中的电子表格并从xlsx文件中读取&#x2F;写入 。","text":"介绍： QXlnt 是一个基于xlnt库的帮助程序项目，允许在Qt中使用xlnt。 xlnt库时一个现代C++库，用于操作内存中的电子表格并从xlsx文件中读取&#x2F;写入 。 1 导入Qxlnt xlnt两个文件夹 从官网下载Qxlnt 库使用 QtExcel&#x2F;Qxlnt 复制Qxlnt ，xlnt两个文件夹到自己项目中 2 在项目.pro 文件中加入 3 替换进入Qxlnt ，打开Qxlnt.pri 将 ../xlnt/ 全部替换成 $$PWD/../xlnt/ 4 验证去官网复制个例子运行 5 成功写入 引用 xlnt 参考文档 QT-XLSX,Excel快速读写经验 | 码农家园 (codenong.com) 源码 地址： https://github.com/silent426/QtLearning.git","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"Qxlnt","slug":"Qxlnt","permalink":"http://example.com/tags/Qxlnt/"},{"name":"xlnt","slug":"xlnt","permalink":"http://example.com/tags/xlnt/"}]},{"title":"Qt 实现多线程","slug":"03 【编程学习】/Qt 实现多线程的几种方式","date":"2023-04-24T01:55:39.613Z","updated":"2024-09-22T15:40:00.977Z","comments":true,"path":"2023/04/24/03 【编程学习】/Qt 实现多线程的几种方式/","link":"","permalink":"http://example.com/2023/04/24/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/Qt%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"1，继承Qthread ,重写run方法。","text":"1，继承Qthread ,重写run方法。 发展史 version-4.6以前，只能继承QThread来实现 version-4.6以后，官方推荐使用继承QObject 来实现 Qthread 存在的问题：方法一：继承QthreadStep1. 需要创建一个线程类的子类，让其继承QT中的线程类QThread，比如： 1234class MyThread:public QThread&#123; ......&#125; step2. 重写父类中run() 方法，在该函数内部编写子线程要处理的具体的业务流程 123456789class MyThread:public QThread&#123; ...... protected: void run() &#123; ........ &#125;&#125; step3. 在主线程中创建子线程对象，new 一个就可以了 1MyThread * subThread = new MyThread; Step4. 启动子线程，调用 start () 方法 1subThread-&gt;start(); 开始实验： 用方法一继承Qthread的方式开辟子线程读取excel分别试验三个不同的读写excel文件 第一次 :one:创建线程子类 :two:重写父类中run()方法 :three:主线程中创建子类 :four:启动子线程 结果： 成功创建子线程，excel 读写函数chart() 被调用，但未见保存成功的文件 第二次 … 方法二：继承QObjectQt 提供了第二种线程的创建方式弥补了第一种方式的缺点，用起来更加灵活，但是这种方式写起来会相对复杂u一些，其操作步骤如下： step1 创建一个新类，让这个类从QObject派生 step2 在这个类中添加一个公共的成员函数，函数体就是我们要子线程中执行的业务逻辑 1234567class MyWork:public QObject&#123;public: ....... // 函数名自己指定, 叫什么都可以, 参数可以根据实际需求添加 void working();&#125; step3 在主线程中创建一个 QThread 对象，这就是子线程的对象 1QThread* sub = new QThread; step4 在主线程中创建工作的类对象（千万不要指定给创建的对象指定父对象） 12MyWork* work = new MyWork(this); // errorMyWork* work = new MyWork; // ok Step5 将 MyWork 对象移动到创建的子线程对象中，需要调用 QObject 类提供的 moveToThread() 方法 1234// void QObject::moveToThread(QThread *targetThread);// 如果给work指定了父对象, 这个函数调用就失败了// 提示： QObject::moveToThread: Cannot move objects with a parentwork-&gt;moveToThread(sub); // 移动到子线程中工作 step6 启动子线程，调用 start(), 这时候线程启动了，但是移动到线程中的对象并没有工作 Step7 调用 MyWork 类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的 开始实验：第一次 excel chart()函数 过程 略 结果 同方法一的结果 保存文件失败 总结：参考： Qt 中多线程的使用 | 爱编程的大丙 (subingwen.cn)","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Qxlsx 实现Excel读写","slug":"03 【编程学习】/Qxlsx 实现Excel读写","date":"2023-04-21T08:42:07.388Z","updated":"2024-09-22T15:40:28.478Z","comments":true,"path":"2023/04/21/03 【编程学习】/Qxlsx 实现Excel读写/","link":"","permalink":"http://example.com/2023/04/21/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/Qxlsx%20%E5%AE%9E%E7%8E%B0Excel%E8%AF%BB%E5%86%99/","excerpt":"Qxlsx 是一个第三方的Excel文件读写库，使用C++ 与 Qt开发。","text":"Qxlsx 是一个第三方的Excel文件读写库，使用C++ 与 Qt开发。 1. 介绍 Qxlsx 是一个第三方的Excel文件读写库，使用C++ 与 Qt开发。 由于QtXlsx2014 年不再维护，该项目2017年起，基于Qtxlsx开发。 GitHub库：QtExcel&#x2F;QXlsx 前身：Qtxlsx两种方法开始使用Qtxlsx写一个新Excel 文件 方法1：使用Xlsx作为Qt5的插件模块 要使用perl 方法2: 直接使用源代码 window 平台尝试可以写入新Excel文件 Qt 官网的介绍： Handling Microsoft Excel file format - Qt Wiki 2. 如何使用？安装设置：How to setup QXlsx project -qmake 如果出错，可将其中8，9，10步骤可更改为： 复制QXlsx文件夹 到项目文件根目录下： 在.pro文件中添加include 构建项目后即可导入头文件 wiki 手册：:one: 读单元格数据 :two: 写单元格数据 … 详情：Home · QtExcel&#x2F;QXlsx Wiki (github.com) Qxlsx 例子应用： 1 直接读取Excel calendar Excel日历 创建了12个sheet表单 设置了单元格大小 修改单元格格式 合并单元格 单元格字体颜色，加粗 QXlsx&#x2F;calendar chart 饼图，三维饼图 柱形图，三维柱形图 组合图，三维折线图 面积图，三维面积图 散点图，圆环图 chart chartsheet生成图与原始数据分别存在两个Excel表中 chartsheet datavalidation 数据验证限制，限制单元格内数值输入的范围 datavalidation documentpropery ​ 设置文件的属性，创建人，公司，关键词，描述 extract data导出软件Excel单元格内容在控制台显示 formula hyperlink image Merge cells numberformat 2 在android上显示 3 加载到网络服务器上 4 显示到控制台 5 加载显示到Qt小组件上（目前未开源） https://j2doll.tistory.com/654 3. Qxlsx存在的一些问题：1 不支持QT4 2 不支持密码函数 ，可以使用Qxlnt补充 3 不支持Excel中的公式，可以使用Qxlnt补充⚠️（本身也能使用公式，见官网例子） QXlsx&#x2F;formulas.cpp at master 4 不支持打印到打印机 5 部分支持图表，还有一些bug 尚未修复 6 只有部分功能与 QtXlsxWriter兼容 有关详细信息，请参阅链接。 https://github.com/dbzhang800/QtXlsxWriter https://github.com/VSRonin/QtXlsxWriter 7 QXlsx 不支持严格格式？（非过渡模式） 有关详细信息，请参阅链接。https://github.com/QtExcel/QXlsx/issues/68#issuecomment-587438003 8 Qxlsx 不提供线程安全，在 QXlsx 库之外使用 QMutex 9 不支持多线程和并发。使用您自己的锁、互斥锁和信号量。 例子可运行源码地址： https://github.com/silent426/QtLearning.git","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Qxlsx","slug":"Qxlsx","permalink":"http://example.com/tags/Qxlsx/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"Git 入门笔记","slug":"03 【编程学习】/Git 与 Github 入门使用","date":"2023-04-13T03:45:01.000Z","updated":"2024-09-23T15:00:59.729Z","comments":true,"path":"2023/04/13/03 【编程学习】/Git 与 Github 入门使用/","link":"","permalink":"http://example.com/2023/04/13/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/Git%20%E4%B8%8E%20Github%20%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/","excerpt":"命令：git commit git pull git push","text":"命令：git commit git pull git push 一 如何将本地的新项目提交到GitHub如何通过git 提交代码到远程仓库？ 1.初始化本地仓库1git init 2.将所有文件添加到本地仓库（也可添加你所需的文件）1git add . 3.将项目提交到本地git仓库 （“first commit” 是备注信息）1git commit -m &quot;first commit&quot; 4.本地git仓库与远程仓库关联（两种方式：1.https方式；2.SSL方式）1git remote add origin https://github.com/JianhaoChung/DGL_GCNER.git 或 1git remote add origin git@github.com:JianhaoChung/DGL_GCNER.git 5.将项目推送到远程仓库1git push -u origin master 二 Git更新本地项目上传到github1、添加到本地仓库1git add . 2 添加提交描述1git commit -m ‘second commit’ 3 提交前先从远程仓库主分支中拉取请求1git pull origin master 4 把本地仓库代码提交1git push -u origin master 引用 视频同步笔记：狂神聊Git (qq.com) git 小游戏 三 GitHub 免密Push","categories":[{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"}]},{"title":"生活不会像你想象的那么糟","slug":"02 【生活】读书笔记/《一生》莫泊桑","date":"2023-04-13T03:45:01.000Z","updated":"2024-09-10T10:47:17.603Z","comments":true,"path":"2023/04/13/02 【生活】读书笔记/《一生》莫泊桑/","link":"","permalink":"http://example.com/2023/04/13/02%20%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E4%B8%80%E7%94%9F%E3%80%8B%E8%8E%AB%E6%B3%8A%E6%A1%91/","excerpt":"生活不可能像你想象得那么好，但也不会像你想象得那么糟","text":"生活不可能像你想象得那么好，但也不会像你想象得那么糟 生活不可能像你想象得那么好，但也不会像你想象得那么糟。我觉得人的脆弱和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面，有时，也发现自己咬着牙走了很长的路。 这段话出自法国小说家·莫泊桑长篇小说《一生》","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Hexo发布指南及入门","slug":"01 【工作】Logbook/Hexo发布指南及入门","date":"2023-04-13T03:45:01.000Z","updated":"2024-11-09T03:53:19.518Z","comments":true,"path":"2023/04/13/01 【工作】Logbook/Hexo发布指南及入门/","link":"","permalink":"http://example.com/2023/04/13/01%20%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91Logbook/Hexo%E5%8F%91%E5%B8%83%E6%8C%87%E5%8D%97%E5%8F%8A%E5%85%A5%E9%97%A8/","excerpt":"hexo g 生成静态文件; hexo s 启动服务; hexo d 远程部署 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"hexo g 生成静态文件; hexo s 启动服务; hexo d 远程部署 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 1.创建文章hexo new firstnote.md 时 使用分类 和标签 hexo g 生成静态文件 hexo s 启动服务 hexo d 远程部署 引用 指令 | Hexo 2. hexo 主题修改 volantis开启搜索（Search）6.0默认开启 需要先安装插件 npm i hexo-generator-json-content 如需配置，如下 search: enable: true service: hexo 开启公式渲染https://volantis.js.org/v6/page-settings/#%E6%B8%B2%E6%9F%93%E5%85%AC%E5%BC%8F Hexo-Volantis主题优化 - 小TiD笔记 (tidnotes.top) Volantis 主题用户手册 在Hexo博文中嵌入Jupyter notebook Hexo博客搭建 美化篇 Volantis hexo部署与调试$ hexo clean //清除静态页面缓存（清除 public 文件夹) $ hexo g //在本地生成静态页面（生成 public 文件夹） $ hexo s //启动本地服务 http://localhost:4000，进行预览调试 $ hexo d //远程部署，同步到 GitHub $ npm install hexo-deployer-git --save //自动部署 $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d //发布 hexo 相关功能设置在hexo文件夹下右键点击Git Base here后键入$hexo new page “name”，source&#x2F;_post 文件夹中生成name.md文件，打开后即可编辑，编辑格式如下： title: 文章名 date: 2017-10-31 20:38:17 //发表日期 updated: 2017-10-31 21:58:03 //更新日期 categories: Life //文章分类 tags: [tag1,tag2] //文章标签，多标签时使用英文逗号隔开 photos: //如果使用Fancybox（文章头部展示图片），如此设置 //注意冒号后面有空格 开启文章搜索摘要居中显示图片/&lt;div align=&quot;center&quot;&gt; &lt;img src=https://---.png width=400px /&gt; &lt;/div&gt; &lt;!-- more --&gt; 文章摘要部分在要显示的文字末尾添加如下代码实现文章在主页的折叠显示。 &lt;!-- more --&gt; 文章加密# 安装插件 npm install --save hexo-blog-encrypt 修改文章信息头如下： title: Hello World tags: - 加密文章tag date: 2020-03-13 21:12:21 password: muyiio abstract: 这里有东西被加密了，需要输入密码查看哦。 message: 您好，这里需要密码。 wrong_pass_message: 抱歉，这个密码看着不太对，请再试试。 wrong_hash_message: 抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。 --- 对博客根目录_config添加如下字段： # 安全 encrypt: # hexo-blog-encrypt abstract: 这里有东西被加密了，需要输入密码查看哦。 message: 您好, 这里需要密码. tags: - &#123;name: tagName, password: 密码A&#125; - &#123;name: tagName, password: 密码B&#125; template: &lt;div id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;&#123;&#123;hbeWrongPassMessage&#125;&#125;&quot; data-whm=&quot;&#123;&#123;hbeWrongHashMessage&#125;&#125;&quot;&gt;&lt;div class=&quot;hbe-input-container&quot;&gt;&lt;input type=&quot;password&quot; id=&quot;hbePass&quot; placeholder=&quot;&#123;&#123;hbeMessage&#125;&#125;&quot; /&gt;&lt;label&gt;&#123;&#123;hbeMessage&#125;&#125;&lt;/label&gt;&lt;div class=&quot;bottom-line&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script id=&quot;hbeData&quot; type=&quot;hbeData&quot; data-hmacdigest=&quot;&#123;&#123;hbeHmacDigest&#125;&#125;&quot;&gt;&#123;&#123;hbeEncryptedData&#125;&#125;&lt;/script&gt;&lt;/div&gt; wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. 引用 Hexo与MarkDown_hexo markdown_小老弟偶的博客-CSDN博客 对 Hexo 博客文章进行加密","categories":[{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"C++程序命名规范","slug":"03 【编程学习】/C++程序命名规范","date":"2023-04-12T12:39:43.000Z","updated":"2024-09-22T15:33:49.686Z","comments":true,"path":"2023/04/12/03 【编程学习】/C++程序命名规范/","link":"","permalink":"http://example.com/2023/04/12/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/C++%E7%A8%8B%E5%BA%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/","excerpt":"程序中最重要的一致性规则是命名管理。 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义： 类型，变量，函数，常量，宏等等。","text":"程序中最重要的一致性规则是命名管理。 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义： 类型，变量，函数，常量，宏等等。 C++程序命名规定 #学习笔记 程序中最重要的一致性规则是命名管理。 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义： 类型，变量，函数，常量，宏等等。 通用总则：函数命名，变量命名，文件命名要有描述性； 少用缩写。 函数命名大驼峰，不用下划线。 变量命名全小写，单词间下划线连接，类的成员变量以下划线结尾_ 1 文件命名文件名要全部小写， 可以包含下划线（_）或者连字符（_），按照项目的约定，如果没有约定，最好是“_”。 2. 类型命名总述 类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum. 所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如: 12345678910111213// 类和结构体class UrlTable &#123; ...class UrlTableTester &#123; ...struct UrlTableProperties &#123; ...// 类型定义typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;// using 别名using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;// 枚举enum UrlTableErrors &#123; ... 3. 变量命名总述 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_. 4. 常量命名总述 声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如: 1const int kDaysInAWeek = 7; 5. 函数命名一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 StartRpc() 而非 StartRPC()). 6. 命名空间命名总述 命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突. 7. 枚举命名总述 枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME. 8. 宏命名总述 你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: MY_MACRO_THAT_SCARES_SMALL_CHILDREN. 引用：C++ 风格指南 - 内容目录 — Google 开源项目风格指南 (zh-google-styleguide.readthedocs.io)","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"books","slug":"books","permalink":"http://example.com/tags/books/"}]},{"title":"机器视觉之【工业相机】基础知识","slug":"01 【工作】Logbook/机器视觉之【工业相机】基础知识","date":"2022-09-22T13:44:11.075Z","updated":"2024-09-22T15:30:26.251Z","comments":true,"path":"2022/09/22/01 【工作】Logbook/机器视觉之【工业相机】基础知识/","link":"","permalink":"http://example.com/2022/09/22/01%20%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91Logbook/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E4%B9%8B%E3%80%90%E5%B7%A5%E4%B8%9A%E7%9B%B8%E6%9C%BA%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"机器视觉之【工业相机】基础知识什么是工业相机？工业相机是专门为工业领域中的自动化检测、生产线监控和质量控制等任务设计的摄像设备。与消费级相机不同，工业相机注重的是图像的精确性、稳定性和可靠性，通常需要在恶劣环境中长时间运行，并能够处理高速或高精度的图像采集任务。 相机分类 按照输出色彩可以分为黑白相机、彩色相机； 按照输出信号可以分为模拟相机、数字相机； 按照芯片类型可以分为CCD相机、CMOS相机； 按照传感器的结构特性可以分为线阵相机、面阵相机； 基本概念靶面：感光元件的大小，一般以英寸为单位表示，该尺寸是对角长度；常见的靶面尺寸有2&#x2F;3，1&#x2F;1.8，1&#x2F;2，1&#x2F;3，1&#x2F;4等。 分辨率：相机采集到的图像的横向分辨率和纵向分辨率，常见的数字相机分辨率有30万( 640x480 ) 、130万(1280x960)、200万(1600x1200)、500万像素(2592x1944)； 像元尺寸：单个像元的大小，一般为靶面&#x2F;分辨率； 帧率：每秒钟最多能采集到的图像数量。 曝光时间：表示CCD 或CMOS 感光元件中蓄积电荷的时间。曝光时间越短，进光量越少；曝光时间越长，进光量越多。最大曝光时间由帧率决定。 增益：所谓增益，是指将图像信号进行电子增幅的过程。 待补充 3D相机 智能相机 扩展 工业相机的相关知识点 - 知乎 (zhihu.com)","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"机器视觉之【相机镜头】基础知识","slug":"01 【工作】Logbook/机器视觉之【相机镜头】基础知识","date":"2022-09-22T13:43:57.481Z","updated":"2024-10-14T16:30:54.051Z","comments":true,"path":"2022/09/22/01 【工作】Logbook/机器视觉之【相机镜头】基础知识/","link":"","permalink":"http://example.com/2022/09/22/01%20%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91Logbook/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E4%B9%8B%E3%80%90%E7%9B%B8%E6%9C%BA%E9%95%9C%E5%A4%B4%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"机器视觉之【相机镜头】基础知识光学镜头 焦距 Focal Length光学系统主点到焦点的距离。 景深 Depth of field, DOF是指在摄影机镜头或其他成像器前沿能够取得清晰图像的成像所测定的被摄物体前后距离范围。 孔径角：物镜光轴上的物体点与物镜前透镜的有效直接直径所形成的角度。数值孔径 NA: 物镜前透镜与被检物体之间介质的折射率n和孔径角θ的正弦的乘积。 分辨率 Resolution分辨率定位为: 能被分辨开来的两个物点之间的最小距离，称为镜头的物方分辨率，记为Resolution(物) 单位μm只有镜头分辨率和相机分辨率匹配，才能得到最佳成像效果。 像方分辨率 &#x3D; 2 * 像元尺寸时，说明此时镜头分辨率与相机完全匹配。 畸变 Distortion畸变也称失真，是由于光阑球差的影响，不同视场的主光线通过光学系统后与高斯像面的交点高度不等于理想像高，二者之差就是畸变。畸变通常有两种计算方法：光学畸变和TV失真。Optical distortion &#x3D; Δy&#x2F;y * 100 [%] MTF 远心镜头与远心度当人眼观察同一个物体，近距离时，感觉物体比较大，远距离时，感觉物体比较小，这种现象叫做透视误差.用远心镜头来消除透视误差。 视场 FOV视场也称为视野，是指能被视觉系统观察到的物方可视范围。 放大倍率机器视觉行业里提到的镜头光学放大倍率通常是指垂轴放大倍率，即像和物的大小之比。$$光学放大倍率&#x3D; \\frac{y’}{y} &#x3D; \\frac{相机芯片尺寸}{视场}$$ 工作距离及物像距离工作距离(WD)是指镜头最下端机械面到物体的距离。物像距离(O&#x2F;I)是指物平面到相机芯片间的距离。物像距离&#x3D;工作距离+镜头本体长度+法兰距。 法兰距离和镜头接口所谓法兰距离，就是指相机机身与镜头接触的机械面到相机芯片之间的距离。镜头的后截距需和相机的法兰距离对应，才能让光线聚焦在相机芯片上。 F NumberF Number 称为F数，也常记为Fno.或F&#x2F;#，表示镜头通光能力的参数。 Fno.数值越小，镜头通光能力越强，即通俗的称为“越亮”。 镜头像圈像圈（image circle）是指入射光线通过镜头后，在焦平面上呈现出的圆形的明亮清晰的影像幅面，也称像面大小。镜头像圈由镜头光学结构决定，一旦设计完成，其对应的像圈就确定了。镜头与相机搭配时，必须使镜头的像圈直径≥相机靶面的对角线长度（如右图所示）。否则，相机靶面的四角会形成暗区（如左图所示）从而影响成像质量，这种现象称为渐晕。 如何对焦使图像清晰常见的镜头有定焦镜头和定倍镜头。 定倍镜头的工作距离和光圈一般是固定的，调整图像清晰度，主要是靠调整镜头与物体的工作距离。定焦镜头调整清晰图像的过程： 将镜头光圈调到最大，即F值最小。 降低曝光时间或光源亮度，使图像亮度合适。既不过暗也不过曝。 调整镜头的对焦环，使图像清晰成像。 将镜头光圈调整到合适的位置。 重新调整曝光时间或光源亮度，使图像亮度合适。 引用 https://www.cnblogs.com/cvhao/p/15903581.html","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"机器视觉之【光源选型】基础知识","slug":"01 【工作】Logbook/机器视觉之 【光源选型】基础知识","date":"2022-09-22T13:43:28.642Z","updated":"2024-09-22T15:21:13.164Z","comments":true,"path":"2022/09/22/01 【工作】Logbook/机器视觉之 【光源选型】基础知识/","link":"","permalink":"http://example.com/2022/09/22/01%20%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91Logbook/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E4%B9%8B%20%E3%80%90%E5%85%89%E6%BA%90%E9%80%89%E5%9E%8B%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"机器视觉之【光源】基础知识光源的作用 照亮目标，提高亮度； 凸显出缺陷和背景的差异，提高图像对比度，形成有利于图像处理的效果； 克服环境光干扰，保证图像稳定性； 光源分类常见的光源类型有LED、荧光灯、卤素灯。 实际应用中，由于 LED 光源的优势，形状设计灵活，使用寿命长，响应速度快，综 合性价比高，单色性好，颜色多样化的特点，在机器视觉中应用最广泛。平时所说的光 源，非特别强调，都是指 LED 光源。 好的图像效果 均匀性 幅图像的背景的灰度值不能有过大的差异；图像不均匀影响处理效果。右边图片 整个背景灰度值相近，处理起来相对左边要简单的多。 对比度 对比度好：图像中需要提取的特征和背景的灰度值差值要大（黑白相机） 边缘过度像素 放大目标与背景的边缘部分，过度像素不超过 3 个，图像效果比较稳定，超过 3 个以上，定位结果的稳定性会受到影响。 常见的LED光源类型 环形高角度光源 环形低角度光源 条形光源 点光源 同轴光源 背光光源 球积分光源 AOI专用光源 光源选型要领条形光源： 条光照射宽度最好大于检测的距离，否则可能会照射距离远造成亮度 差，或者是距离近而辐射面积不够。 条光长度能够照明所需打亮的位置即可，无需太长造成安装不便，同 时也增加成本，一般情况下，光源的安装高度会影响到所选用条光的 长度，高度越高，光源长度要求越长，否则图像量测亮度要比中间暗。 如果照明目标是高反光物体，最好加上漫射板，如果是黑色等暗色不 反光产品，也可以拆掉漫射板以提高亮度。 环形光 1） 了解光源安装距离，过滤掉某些角度光源；例如要求光源安装尺寸高，就可以过滤掉大角度光源，选择用小角度光源，同样，安装高度越 高，要求光源的直径越大 2）目标面积小，且主要特性在表面中间，可选择小尺寸 0 角度或小角度 光源。 3）目标需要表现的特征如果在边缘，可选择 90 度角环光，或大尺寸高 角度环形光 4）检测表面划伤，可选择 90 度角环光，尽量选择波长短的光源。 条形组合光 1）条形组合光在选择时，不一定要按照资料上的型号来选型，因为被测 的目标形状、大小各不一样，所以可以按照目标尺寸来选择不同的条形 光源进行组合。 2）组合光在选择时，一定要考虑光源的安装高度，再根据四边被测特征 点的长度宽度选择相对应的条形光进行组合。 背光源&#x2F;平行背光源 1） 选择背光源时，根据物体的大小选择合适大小的背光源，以免增加成 本造成浪费 2） 背光源四周由于有外壳遮挡，因此其亮度会低于中间部位，选择背光 源时，尽量不要使目标正好位于背光源边缘。 3） 背光源一般在检测轮廓时，可以尽量使用波长短的光源，波长短的光 源其衍射性弱，图像边缘不容易产生重影，对比度更高 4） 背光源与目标之间的距离可以通过调整来达到最佳的效果，并非离 得越近效果越好，也非越远越好。 5） 检测液位可以将背光源侧立使用 6） 圆轴类的产品，螺旋状的产品尽量使用平行背光源。 同轴光 1） 选择同轴光时主要看其发光面积，根据目标的大小来选择合适发光 面积的同轴光 2） 同轴光的发光面积最好比目标尺寸大 1.5~2 倍左右，因为同轴光的光 路设计是让光路通过一片 45 度半反半透镜改变，光源靠近灯板的地 方会比远离灯板的亮度高，因此尽量选择大一点的发光面避免光线 左右不均匀。 3） 同轴光在安装时尽量不要离目标太高，越高，要求选用的同轴光越大， 才能保证均匀性。 平行同轴光 1） 平行同轴光光路设计独特，主要适用于检测各种划痕 2） 平行同轴光与同轴光表现的特点不一样，不能替代同轴光使用 3） 平行同轴光检测划伤之类的产品，尽量不要选择波长长的光源。 其他光源 1） 了解特征点面积大小，选择合适尺寸的光源 2） 了解产品特性，选择不同类型的光源 3） 了解产品的材质，选择不同颜色的光源 4） 了解安装空间及其他可能会产生障碍的情况，选择合适的光源。 扩展 技巧篇 | 机器视觉光源最佳选型攻略（附案例） - 知乎 (zhihu.com)","categories":[{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"python 语言基础","slug":"03 【编程学习】/python 语言基础","date":"2021-10-15T10:39:51.000Z","updated":"2024-11-08T10:30:01.671Z","comments":true,"path":"2021/10/15/03 【编程学习】/python 语言基础/","link":"","permalink":"http://example.com/2021/10/15/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/python%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","excerpt":"Python 是一门优雅而健壮的编程语言，它继承了传统编译语言的强大性和通用性，同时也借鉴了脚本语言和解释语言的易用性。","text":"Python 是一门优雅而健壮的编程语言，它继承了传统编译语言的强大性和通用性，同时也借鉴了脚本语言和解释语言的易用性。 第一步：搭建编程环境， 建议直接安装Anaconda。 01 Python语言介绍Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。 int* func() &#123; int* a = new int(10); return a; &#125; int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 02 变量与简单数据类型2.1 变量变量的命名规范与使用 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为message_1，但不能将其命名为1_message。 变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message 可行，但变量名greeting message会引发错误。 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词， 如print（请参见附录A.4）。 变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length 比length_of_persons_name好。 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。 要创建良好的变量名，需要经过一定的实践，在程序复杂而有趣时尤其如此。随着你编写的程序越来越多，并开始阅读别人编写的代码，将越来越善于创建有意义的变量名。 2.2 字符串字符串就是一系列字符。在Python中，用引号括起的都是字符串，其中的引号可以是单引号， 也可以是双引号，如下所示. &quot;This is a string.&quot; &#39;This is also a string.&#39; 使用方法修改字符串的大小写对于字符串，可执行的最简单的操作之一是修改其中的单词的大小写。 name = &quot;ada lovelace&quot; print(name.title()) # 输出：Ada Lovelace 在name.title()中，name后 面的句点（.）让Python对变量name执行方法title()指定的操作。 name = &quot;Ada Lovelace&quot; print(name.upper()) # 输出 ADA LOVELACE print(name.lower()) # 输出 ada lovelace 存储数据时，方法lower()很有用。很多时候，你无法依靠用户来提供正确的大小写，因此 需要将字符串先转换为小写，再存储它们。以后需要显示这些信息时，再将其转换为最合适的大 小写方式。 合并（拼接）字符串Python使用加号（+）来合并字符串。 使用制表符或换行符来添加空白在编程中，空白泛指任何非打印字符，如空格、制表符和换行符。你可使用空白来组织输出， 以使其更易读。 删除空白Python能够找出字符串开头和末尾多余的空白。要确保字符串末尾没有空白，可使用方法 rstrip()。 为删除这个字符串中的空白，你需要将其末尾的空白剔除，再将结果存回到原来的变量中。 favorite_language = &#39;python &#39; favorite_language = favorite_language.rstrip() favorite_language # 输出&#39;python&#39; 此外，你还可以剔除字符串开头的空白，或同时剔除字符串两端的空白。为此，可分别使用方法 lstrip()和strip()： 2.3 数字整数浮点数Python将带小数点的数字都称为浮点数。大多数编程语言都使用了这个术语，它指出了这样 一个事实：小数点可出现在数字的任何位置。每种编程语言都须细心设计，以妥善地处理浮点数， 确保不管小数点出现在什么位置，数字的行为都是正常的。 使用函数str()避免类型错误函数str()数字转字符串。 03 列表类型的介绍与操作列表由一系列按特定顺序排列的元素组成。 在Python中，用方括号（[]）来表示列表，并用逗号来分隔其中的元素。 下面是一个简单的 列表示例，这个列表包含几种自行车： bicycles = [&#39;trek&#39;, &#39;cannondale&#39;, &#39;redline&#39;, &#39;specialized&#39;] print(bicycles) 访问列表元素列表是有序集合，因此要访问列表的任何元素，只需将该元素的位置或索引告诉Python即可。 在Python中，第一个列表元素的索引为0，而不是1。在大多数编程语言中都是如此，这与列表操作的底层实现相关。 Python为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为-1，可让Python返 回最后一个列表元素 修改列表元素motorcycles = [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;] print(motorcycles) motorcycles[0] = &#39;ducati&#39; 在列表中添加元素motorcycles.append(&#39;ducati&#39;) # 列表末尾添加元素 在列表中插入元素 motorcycles.insert(0, &#39;ducati&#39;) #使用方法insert()可在列表的任何位置添加新元素。 从列表中删除元素 使用del语句删除元素 del motorcycles[0] 使用方法pop()删除元素 有时候，你要将元素从列表中删除，并接着使用它的值。 popped_motorcycle = motorcycles.pop() 弹出列表中任何位置处的元素 first_owned = motorcycles.pop(0) 根据值删除元素 motorcycles.remove(&#39;ducati&#39;) 方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值。 组织列表04 字典类型的介绍与操作 在Python中，字典是一系列键—值对。每个键都与一个值相关联，你可以使用键来访问与之 相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对 象用作字典中的值。 05 流程控制在Python中检查是否相等时区分大小写，例如，两个大小写不同的值会被视为不相等： 使用and检查多个条件 使用or检查多个条件 要判断特定的值是否已包含在列表中，可使用关键字in。 检查特定值是否不包含在列表中,可使用关键字not in。 经常需要检查超过两个的情形，为此可使用Python提供的if-elif-else结构。 06 用户输入与循环使用函数input()时，Python将用户输入解读为字符串。请看下面让用户输入其年龄的解释器 会话： &gt;&gt;&gt; &gt;&gt;&gt; age = input(&quot;How old are you? &quot;) How old are you? 21 &gt;&gt;&gt; age &#39;21&#39; 使用int()来获取数值输入 , int() 强制类型转换为整型 07 函数def greet_user(): &quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot; print(&quot;Hello!&quot;) greet_user() 编写函数时，可给每个形参指定默认值。 如果要描述的动物不是小狗，可使用类似于下面的函数调用： def describe_pet(pet_name, animal_type=&#39;dog&#39;): &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot; print(&quot;\\nI have a &quot; + animal_type + &quot;.&quot;) print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;) describe_pet(pet_name=&#39;willie&#39;) describe_pet(pet_name=&#39;harry&#39;, animal_type=&#39;hamster&#39;) 由于显式地给animal_type提供了实参，因此Python将忽略这个形参的默认值。 使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。 这让Python依然能够正确地解读位置实参。 将实参变成可选的有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息。可使用默认值来让实参变成可选的。 例如，假设我们要扩展函数get_formatted_name()，使其还处理中间名。为此，可将其修改 成类似于下面这样： def get_formatted_name(first_name, last_name, middle_name=&#39;&#39;): &quot;&quot;&quot;返回整洁的姓名&quot;&quot;&quot; if middle_name: full_name = first_name + &#39; &#39; + middle_name + &#39; &#39; + last_name else: full_name = first_name + &#39; &#39; + last_name Python将非空字符串解读为True. 函数返回值函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。 函数传递列表 在函数中修改列表 禁止函数修改列表 有时候，可向函数传 递列表的副本而不是原件；这样函数所做的任何修改都只影响副本，而丝毫不影响原件。 要将列表的副本传递给函数，可以像下面这样做： function_name(list_name[:]) 切片表示法[:]创建列表的副本。 虽然向函数传递列表的副本可保留原始列表的内容，但除非有充分的理由需要传递副本，否 则还是应该将原始列表传递给函数，因为让函数使用现成列表可避免花时间和内存创建副本，从 而提高效率，在处理大型列表时尤其如此。 传递任意数量的实参有时候，你预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任 意数量的实参。 例如，来看一个制作比萨的函数，它需要接受很多配料，但你无法预先确定顾客要多少种配 料。下面的函数只有一个形参*toppings，但不管调用语句提供了多少实参，这个形参都将它们 统统收入囊中： def make_pizza(*toppings): &quot;&quot;&quot;打印顾客点的所有配料&quot;&quot;&quot; print(toppings) make_pizza(&#39;pepperoni&#39;) make_pizza(&#39;mushrooms&#39;, &#39;green peppers&#39;, &#39;extra cheese&#39;) 结合使用位置实参和任意数量实参如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最 后。 使用任意数量的关键字实参有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种 情况下，可将函数编写成能够接受任意数量的键—值对——调用语句提供了多少就接受多少。一 个这样的示例是创建用户简介：你知道你将收到有关用户的信息，但不确定会是什么样的信息。 在下面的示例中，函数build_profile()接受名和姓，同时还接受任意数量的关键字实参： def build_profile(first, last, **user_info): &quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切&quot;&quot;&quot; profile = &#123;&#125; profile[&#39;first_name&#39;] = first profile[&#39;last_name&#39;] = last .... 将函数存储在模块中import语句允许在当前运行的程序文件中使用模块中的代码。 导入特定的函数from module_name import function_name 使用as给函数指定别名08 类面向对象编程是最有效的软件编写方法之一。 使用类几乎可以模拟任何东西。下面来编写一个表示小狗的简单类Dog——它表示的不是特 定的小狗，而是任何小狗。 根据约定，在Python中，首字母大写的名称指的是类。 方法__init__() 类中的函数称为方法；你前面学到的有关函数的一切都适用于方法，就目前而言，唯一重要 的差别是调用方法的方式。 在这个方法的名称中，开头和末尾各有两个下划线，这是一种约 定，旨在避免Python默认方法与普通方法发生名称冲突。 09 文件与异常9.1 读取文件with open(&#39;pi_digits.txt&#39;) as file_object: contents = file_object.read() print(contents) 相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因为read()到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在print语句中使用rstrip()： with open(&#39;pi_digits.txt&#39;) as file_object: contents = file_object.read() print(contents.rstrip()) 9.2 文件路径绝对路径 or 相对路径 Linux系统下路径 file_path = &#39;/home/ehmatthes/other_files/text_files/filename.txt&#39; with open(file_path) as file_object: Window系统下路径 file_path = &#39;C:\\Users\\ehmatthes\\other_files\\text_files\\filename.txt&#39; with open(file_path) as file_object: 注意：Windows系统有时能够正确地解读文件路径中的斜杠。如果你使用的是Windows系统，且 结果不符合预期，请确保在文件路径中使用的是反斜杠。 注意：读取文本文件时，Python将其中的所有文本都解读为字符串。如果你读取的是数字，并 要将其作为数值使用，就必须使用函数int()将其转换为整数，或使用函数float()将其转 换为浮点数。 圆周率值中包含你的生日吗？ 练习圆周率中包含你的生日吗_-CSDN博客 9.3 写入文件filename = &#39;programming.txt&#39; with open(filename, &#39;w&#39;) as file_object: file_object.write(&quot;I love programming.\\n&quot;) file_object.write(&quot;I love creating new games.\\n&quot;) 如果你要给文件添加内容，而不是覆盖原有的内容，可以附加模式打开文件。 filename = &#39;programming.txt&#39; with open(filename, &#39;a&#39;) as file_object: file_object.write(&quot;I also love finding meaning in large datasets.\\n&quot;) file_object.write(&quot;I love creating apps that can run in a browser.\\n&quot;) 最终的结果是，文件原来的内容还在，它们后面是我们刚添加的内容。 9.4 异常Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。 异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告 诉Python发生异常时怎么办。 处理ZeroDivisionError异常： try: print(5/0) except ZeroDivisionError: print(&quot;You can&#39;t divide by zero!&quot;) 9.5 存储数据用户关闭程序时，你几乎总是要保存他们提供的信息；一种简单的方式是使用模块json来存储数据。 JSON（JavaScript Object Notation）格式最初是为JavaScript开发的，但随后成了一种常见 格式，被包括Python在内的众多语言采用。 使用json.dump()和 json.load()对于用户生成的数据，使用json保存它们大有裨益，因为如果不以某种方式进行存储，等程 序停止运行时用户的信息将丢失。。下面来看一个这样的例子：用户首次运行程序时被提示输入自己的名字，这样再次运行程序时就记住他了。 filename = &#39;username.json&#39; try: with open(filename) as f_obj: username = json.load(f_obj) except FileNotFoundError: username = input(&quot;What is your name? &quot;) with open(filename, &#39;w&#39;) as f_obj: json.dump(username, f_obj) print(&quot;We&#39;ll remember you when you come back, &quot; + username + &quot;!&quot;) else: print(&quot;Welcome back, &quot; + username + &quot;!&quot;) 重构你经常会遇到这样的情况：代码能够正确地运行，但可做进一步的改进——将代码划分为 一系列完成具体工作的函数。这样的过程被称为重构。重构让代码更清晰、更易于理解、更容易扩展。 todo 10 测试代码 toto 11 实战项目集合 使用help() 和dir() 查看python 源码 Python自带的help()函数可以为我们提供函数的文档字符串以及函数的一些基本信息。 dir()函数可以列出对象的所有属性和方法，包括内置函数。 参考 Python编程 从入门到实战 利用Python 进行数据分析 Python之路V2.0.pdf 免费电子书，分析文本用Free eBooks | Project Gutenberg","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"json","slug":"json","permalink":"http://example.com/tags/json/"}]},{"title":"C++ 提高编程","slug":"03 【编程学习】/C++提高编程","date":"2019-02-13T01:05:24.146Z","updated":"2024-09-22T15:41:17.526Z","comments":true,"path":"2019/02/13/03 【编程学习】/C++提高编程/","link":"","permalink":"http://example.com/2019/02/13/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/","excerpt":"","text":"C++提高编程 本阶段主要针对C++&#x3D;&#x3D;泛型编程&#x3D;&#x3D;和&#x3D;&#x3D;STL&#x3D;&#x3D;技术做详细讲解，探讨C++更深层的使用 1 模板1.1 模板的概念模板就是建立通用的模具，大大提高复用性 例如生活中的模板 一寸照片模板： PPT模板： 模板的特点： 模板不可以直接使用，它只是一个框架 模板的通用并不是万能的 1.2 函数模板 C++另一种编程思想称为 &#x3D;&#x3D;泛型编程&#x3D;&#x3D; ，主要利用的技术就是模板 C++提供两种模板机制:函数模板和类模板 1.2.1 函数模板语法函数模板作用： 建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。 语法： 12template&lt;typename T&gt;函数声明或定义 解释： template — 声明创建模板 typename — 表面其后面的符号是一种数据类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//交换整型函数void swapInt(int&amp; a, int&amp; b) &#123; int temp = a; a = b; b = temp;&#125;//交换浮点型函数void swapDouble(double&amp; a, double&amp; b) &#123; double temp = a; a = b; b = temp;&#125;//利用模板提供通用的交换函数template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;void test01()&#123; int a = 10; int b = 20; //swapInt(a, b); //利用模板实现交换 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap&lt;int&gt;(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 函数模板利用关键字 template 使用函数模板有两种方式：自动类型推导、显示指定类型 模板的目的是为了提高复用性，将类型参数化 1.2.2 函数模板注意事项注意事项： 自动类型推导，必须推导出一致的数据类型T,才可以使用 模板必须要确定出T的数据类型，才可以使用 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//利用模板提供通用的交换函数template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; mySwap(a, b); // 正确，可以推导出一致的T //mySwap(a, c); // 错误，推导不出一致的T类型&#125;// 2、模板必须要确定出T的数据类型，才可以使用template&lt;class T&gt;void func()&#123; cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;&#125;void test02()&#123; //func(); //错误，模板不能独立使用，必须确定出T的类型 func&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结： 使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型 1.2.3 函数模板案例案例描述： 利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//交换的函数模板template&lt;typename T&gt;void mySwap(T &amp;a, T&amp;b)&#123; T temp = a; a = b; b = temp;&#125;template&lt;class T&gt; // 也可以替换成typename//利用选择排序，进行对数组从大到小的排序void mySort(T arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; int max = i; //最大数的下标 for (int j = i + 1; j &lt; len; j++) &#123; if (arr[max] &lt; arr[j]) &#123; max = j; &#125; &#125; if (max != i) //如果最大数的下标不是i，交换两者 &#123; mySwap(arr[max], arr[i]); &#125; &#125;&#125;template&lt;typename T&gt;void printArray(T arr[], int len) &#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; //测试char数组 char charArr[] = &quot;bdcfeagh&quot;; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num);&#125;void test02()&#123; //测试int数组 int intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num);&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：模板可以提高代码复用，需要熟练掌握 1.2.4 普通函数与函数模板的区别普通函数与函数模板区别： 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换 示例： 1234567891011121314151617181920212223242526272829303132333435//普通函数int myAdd01(int a, int b)&#123; return a + b;&#125;//函数模板template&lt;class T&gt;T myAdd02(T a, T b) &#123; return a + b;&#125;//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的&#x27;c&#x27;隐式转换为int类型 &#x27;c&#x27; 对应 ASCII码 99 //myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换 myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T 1.2.5 普通函数与函数模板的调用规则调用规则如下： 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配,优先调用函数模板 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//普通函数与函数模板调用规则void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b) &#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b, T c) &#123; cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; &#125;void test01()&#123; //1、如果函数模板和普通函数都可以实现，优先调用普通函数 // 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 int a = 10; int b = 20; myPrint(a, b); //调用普通函数 //2、可以通过空模板参数列表来强制调用函数模板 myPrint&lt;&gt;(a, b); //调用函数模板 //3、函数模板也可以发生重载 int c = 30; myPrint(a, b, c); //调用重载的函数模板 //4、 如果函数模板可以产生更好的匹配,优先调用函数模板 char c1 = &#x27;a&#x27;; char c2 = &#x27;b&#x27;; myPrint(c1, c2); //调用函数模板&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性 1.2.6 模板的局限性局限性： 模板的通用性并不是万能的 例如： 12345template&lt;class T&gt;void f(T a, T b)&#123; a = b; &#125; 在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了 再例如： 12345template&lt;class T&gt;void f(T a, T b)&#123; if(a &gt; b) &#123; ... &#125; &#125; 在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行 因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;using namespace std;#include &lt;string&gt;class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;//普通函数模板template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123; if (a == b) &#123; return true; &#125; else &#123; return false; &#125;&#125;//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型//具体化优先于常规模板template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)&#123; if ( p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) &#123; return true; &#125; else &#123; return false; &#125;&#125;void test01()&#123; int a = 10; int b = 20; //内置数据类型可以直接使用通用的函数模板 bool ret = myCompare(a, b); if (ret) &#123; cout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl; &#125;&#125;void test02()&#123; Person p1(&quot;Tom&quot;, 10); Person p2(&quot;Tom&quot;, 10); //自定义数据类型，不会调用普通的函数模板 //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型 bool ret = myCompare(p1, p2); if (ret) &#123; cout &lt;&lt; &quot;p1 == p2 &quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结： 利用具体化的模板，可以解决自定义类型的通用化 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板 1.3 类模板1.3.1 类模板语法类模板作用： 建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。 语法： 12template&lt;typename T&gt;类 解释： template — 声明创建模板 typename — 表面其后面的符号是一种数据类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType&gt; class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;void test01()&#123; // 指定NameType 为string类型，AgeType 为 int类型 Person&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999); P1.showPerson();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板 1.3.2 类模板与函数模板区别类模板与函数模板区别主要有两点： 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;//1、类模板没有自动类型推导的使用方式void test01()&#123; // Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导 Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板 p.showPerson();&#125;//2、类模板在模板参数列表中可以有默认参数void test02()&#123; Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数 p.showPerson();&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结： 类模板使用只能用显示指定类型方式 类模板中的模板参数列表可以有默认参数 1.3.3 类模板中成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的： 普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Person1&#123;public: void showPerson1() &#123; cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl; &#125;&#125;;class Person2&#123;public: void showPerson2() &#123; cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl; &#125;&#125;;template&lt;class T&gt;class MyClass&#123;public: T obj; //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成 void fun1() &#123; obj.showPerson1(); &#125; void fun2() &#123; obj.showPerson2(); &#125;&#125;;void test01()&#123; MyClass&lt;Person1&gt; m; m.fun1(); //m.fun2();//编译会出错，说明函数调用才会去创建成员函数&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建 1.3.4 类模板对象做函数参数学习目标： 类模板实例化出的对象，向函数传参的方式 一共有三种传入方式： 指定传入的类型 — 直接显示对象的数据类型 参数模板化 — 将对象中的参数变为模板进行传递 整个类模板化 — 将这个对象类型 模板化进行传递 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;//1、指定传入的类型void printPerson1(Person&lt;string, int&gt; &amp;p) &#123; p.showPerson();&#125;void test01()&#123; Person &lt;string, int &gt;p(&quot;孙悟空&quot;, 100); printPerson1(p);&#125;//2、参数模板化template &lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123; p.showPerson(); cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;void test02()&#123; Person &lt;string, int &gt;p(&quot;猪八戒&quot;, 90); printPerson2(p);&#125;//3、整个类模板化template&lt;class T&gt;void printPerson3(T &amp; p)&#123; cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl; p.showPerson();&#125;void test03()&#123; Person &lt;string, int &gt;p(&quot;唐僧&quot;, 30); printPerson3(p);&#125;int main() &#123; test01(); test02(); test03(); system(&quot;pause&quot;); return 0;&#125; 总结： 通过类模板创建的对象，可以有三种方式向函数中进行传参 使用比较广泛是第一种：指定传入的类型 1.3.5 类模板与继承当类模板碰到继承时，需要注意一下几点： 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;class T&gt;class Base&#123; T m;&#125;;//class Son:public Base //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承class Son :public Base&lt;int&gt; //必须指定一个类型&#123;&#125;;void test01()&#123; Son c;&#125;//类模板继承类模板 ,可以用T2指定父类中的T类型template&lt;class T1, class T2&gt;class Son2 :public Base&lt;T2&gt;&#123;public: Son2() &#123; cout &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; typeid(T2).name() &lt;&lt; endl; &#125;&#125;;void test02()&#123; Son2&lt;int, char&gt; child1;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：如果父类是类模板，子类需要指定出父类中T的数据类型 1.3.6 类模板成员函数类外实现学习目标：能够掌握类模板中的成员函数类外实现 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;string&gt;//类模板中成员函数类外实现template&lt;class T1, class T2&gt;class Person &#123;public: //成员函数类内声明 Person(T1 name, T2 age); void showPerson();public: T1 m_Name; T2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123; cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123; Person&lt;string, int&gt; p(&quot;Tom&quot;, 20); p.showPerson();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：类模板中成员函数类外实现时，需要加上模板参数列表 1.3.7 类模板分文件编写学习目标： 掌握类模板成员函数分文件编写产生的问题以及解决方式 问题： 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到 解决： 解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 示例： person.hpp中代码： 123456789101112131415161718192021222324252627#pragma once#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;template&lt;class T1, class T2&gt;class Person &#123;public: Person(T1 name, T2 age); void showPerson();public: T1 m_Name; T2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123; cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125; 类模板分文件编写.cpp中代码 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;//#include &quot;person.h&quot;#include &quot;person.cpp&quot; //解决方式1，包含cpp源文件//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp#include &quot;person.hpp&quot;void test01()&#123; Person&lt;string, int&gt; p(&quot;Tom&quot;, 10); p.showPerson();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp 1.3.8 类模板与友元学习目标： 掌握类模板配合友元函数的类内和类外实现 全局函数类内实现 - 直接在类内声明友元即可 全局函数类外实现 - 需要提前让编译器知道全局函数的存在 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;string&gt;//2、全局函数配合友元 类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元template&lt;class T1, class T2&gt; class Person;//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt; &amp; p)&#123; cout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1, class T2&gt;class Person&#123; //1、全局函数配合友元 类内实现 friend void printPerson(Person&lt;T1, T2&gt; &amp; p) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl; &#125; //全局函数配合友元 类外实现 friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);public: Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;private: T1 m_Name; T2 m_Age;&#125;;//1、全局函数在类内实现void test01()&#123; Person &lt;string, int &gt;p(&quot;Tom&quot;, 20); printPerson(p);&#125;//2、全局函数在类外实现void test02()&#123; Person &lt;string, int &gt;p(&quot;Jerry&quot;, 30); printPerson2(p);&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别 1.3.9 类模板案例案例描述: 实现一个通用的数组类，要求如下： 可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量 示例： myArray.hpp中代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#pragma once#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class MyArray&#123;public: //构造函数 MyArray(int capacity) &#123; this-&gt;m_Capacity = capacity; this-&gt;m_Size = 0; pAddress = new T[this-&gt;m_Capacity]; &#125; //拷贝构造 MyArray(const MyArray &amp; arr) &#123; this-&gt;m_Capacity = arr.m_Capacity; this-&gt;m_Size = arr.m_Size; this-&gt;pAddress = new T[this-&gt;m_Capacity]; for (int i = 0; i &lt; this-&gt;m_Size; i++) &#123; //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值， // 普通类型可以直接= 但是指针类型需要深拷贝 this-&gt;pAddress[i] = arr.pAddress[i]; &#125; &#125; //重载= 操作符 防止浅拷贝问题 MyArray&amp; operator=(const MyArray&amp; myarray) &#123; if (this-&gt;pAddress != NULL) &#123; delete[] this-&gt;pAddress; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; &#125; this-&gt;m_Capacity = myarray.m_Capacity; this-&gt;m_Size = myarray.m_Size; this-&gt;pAddress = new T[this-&gt;m_Capacity]; for (int i = 0; i &lt; this-&gt;m_Size; i++) &#123; this-&gt;pAddress[i] = myarray[i]; &#125; return *this; &#125; //重载[] 操作符 arr[0] T&amp; operator [](int index) &#123; return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理 &#125; //尾插法 void Push_back(const T &amp; val) &#123; if (this-&gt;m_Capacity == this-&gt;m_Size) &#123; return; &#125; this-&gt;pAddress[this-&gt;m_Size] = val; this-&gt;m_Size++; &#125; //尾删法 void Pop_back() &#123; if (this-&gt;m_Size == 0) &#123; return; &#125; this-&gt;m_Size--; &#125; //获取数组容量 int getCapacity() &#123; return this-&gt;m_Capacity; &#125; //获取数组大小 int getSize() &#123; return this-&gt;m_Size; &#125; //析构 ~MyArray() &#123; if (this-&gt;pAddress != NULL) &#123; delete[] this-&gt;pAddress; this-&gt;pAddress = NULL; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; &#125; &#125;private: T * pAddress; //指向一个堆空间，这个空间存储真正的数据 int m_Capacity; //容量 int m_Size; // 大小&#125;; 类模板案例—数组类封装.cpp中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &quot;myArray.hpp&quot;#include &lt;string&gt;void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//测试内置数据类型void test01()&#123; MyArray&lt;int&gt; array1(10); for (int i = 0; i &lt; 10; i++) &#123; array1.Push_back(i); &#125; cout &lt;&lt; &quot;array1打印输出：&quot; &lt;&lt; endl; printIntArray(array1); cout &lt;&lt; &quot;array1的大小：&quot; &lt;&lt; array1.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;array1的容量：&quot; &lt;&lt; array1.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; MyArray&lt;int&gt; array2(array1); array2.Pop_back(); cout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl; printIntArray(array2); cout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl;&#125;//测试自定义数据类型class Person &#123;public: Person() &#123;&#125; Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;public: string m_Name; int m_Age;&#125;;void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)&#123; for (int i = 0; i &lt; personArr.getSize(); i++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; personArr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; personArr[i].m_Age &lt;&lt; endl; &#125;&#125;void test02()&#123; //创建数组 MyArray&lt;Person&gt; pArray(10); Person p1(&quot;孙悟空&quot;, 30); Person p2(&quot;韩信&quot;, 20); Person p3(&quot;妲己&quot;, 18); Person p4(&quot;王昭君&quot;, 15); Person p5(&quot;赵云&quot;, 24); //插入数据 pArray.Push_back(p1); pArray.Push_back(p2); pArray.Push_back(p3); pArray.Push_back(p4); pArray.Push_back(p5); printPersonArray(pArray); cout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl;&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结： 能够利用所学知识点实现通用的数组 2 STL初识2.1 STL的诞生 长久以来，软件界一直希望建立一种可重复利用的东西 C++的面向对象和泛型编程思想，目的就是复用性的提升 大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作 为了建立数据结构和算法的一套标准,诞生了STL 2.2 STL基本概念 STL(Standard Template Library,标准模板库) STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator) 容器和算法之间通过迭代器进行无缝连接。 STL 几乎所有的代码都采用了模板类或者模板函数 2.3 STL六大组件STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。 算法：各种常用的算法，如sort、find、copy、for_each等 迭代器：扮演了容器与算法之间的胶合剂。 仿函数：行为类似函数，可作为算法的某种策略。 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。 2.4 STL中容器、算法、迭代器容器：置物之所也 STL容器就是将运用最广泛的一些数据结构实现出来 常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等 这些容器分为序列式容器和关联式容器两种: ​ 序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。​ 关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系 算法：问题之解法也 有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms) 算法分为:质变算法和非质变算法。 质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等 迭代器：容器和算法之间粘合剂 提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。 每个容器都有自己专属的迭代器 迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针 迭代器种类： 种类 功能 支持运算 输入迭代器 对数据的只读访问 只读，支持++、&#x3D;&#x3D;、！&#x3D; 输出迭代器 对数据的只写访问 只写，支持++ 前向迭代器 读写操作，并能向前推进迭代器 读写，支持++、&#x3D;&#x3D;、！&#x3D; 双向迭代器 读写操作，并能向前和向后操作 读写，支持++、–， 随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D; 常用的容器中迭代器种类为双向迭代器，和随机访问迭代器 2.5 容器算法迭代器初识了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力 STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器 2.5.1 vector存放内置数据类型容器： vector 算法： for_each 迭代器： vector&lt;int&gt;::iterator 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;vector&gt;#include &lt;algorithm&gt;void MyPrint(int val)&#123; cout &lt;&lt; val &lt;&lt; endl;&#125;void test01() &#123; //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型 vector&lt;int&gt; v; //向容器中放数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素 //v.begin()返回迭代器，这个迭代器指向容器中第一个数据 //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置 //vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型 vector&lt;int&gt;::iterator pBegin = v.begin(); vector&lt;int&gt;::iterator pEnd = v.end(); //第一种遍历方式： while (pBegin != pEnd) &#123; cout &lt;&lt; *pBegin &lt;&lt; endl; pBegin++; &#125; //第二种遍历方式： for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; cout &lt;&lt; endl; //第三种遍历方式： //使用STL提供标准遍历算法 头文件 algorithm for_each(v.begin(), v.end(), MyPrint);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 2.5.2 Vector存放自定义数据类型学习目标：vector中存放自定义数据类型，并打印输出 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;vector&gt;#include &lt;string&gt;//自定义数据类型class Person &#123;public: Person(string name, int age) &#123; mName = name; mAge = age; &#125;public: string mName; int mAge;&#125;;//存放对象void test01() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); Person p5(&quot;eee&quot;, 50); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl; &#125;&#125;//放对象指针void test02() &#123; vector&lt;Person*&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); Person p5(&quot;eee&quot;, 50); v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); v.push_back(&amp;p4); v.push_back(&amp;p5); for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; Person * p = (*it); cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 2.5.3 Vector容器嵌套容器学习目标：容器中嵌套容器，我们将所有数据进行遍历输出 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;vector&gt;//容器嵌套容器void test01() &#123; vector&lt; vector&lt;int&gt; &gt; v; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; v3; vector&lt;int&gt; v4; for (int i = 0; i &lt; 4; i++) &#123; v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); &#125; //将容器元素插入到vector v中 v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123; cout &lt;&lt; *vit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 3 STL- 常用容器3.1 string容器3.1.1 string基本概念本质： string是C++风格的字符串，而string本质上是一个类 string和char * 区别： char * 是一个指针 string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。 特点： string 类内部封装了很多成员方法 例如：查找find，拷贝copy，删除delete 替换replace，插入insert string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责 3.1.2 string构造函数构造函数原型： string(); &#x2F;&#x2F;创建一个空的字符串 例如: string str; string(const char* s); &#x2F;&#x2F;使用字符串s初始化 string(const string&amp; str); &#x2F;&#x2F;使用一个string对象初始化另一个string对象 string(int n, char c); &#x2F;&#x2F;使用n个字符c初始化 示例： 123456789101112131415161718192021222324252627#include &lt;string&gt;//string构造void test01()&#123; string s1; //创建空字符串，调用无参构造函数 cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; s1 &lt;&lt; endl; const char* str = &quot;hello world&quot;; string s2(str); //把c_string转换成了string cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl; string s3(s2); //调用拷贝构造函数 cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl; string s4(10, &#x27;a&#x27;); cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：string的多种构造方式没有可比性，灵活使用即可 3.1.3 string赋值操作功能描述： 给string字符串进行赋值 赋值的函数原型： string&amp; operator=(const char* s); &#x2F;&#x2F;char*类型字符串 赋值给当前的字符串 string&amp; operator=(const string &amp;s); &#x2F;&#x2F;把字符串s赋给当前的字符串 string&amp; operator=(char c); &#x2F;&#x2F;字符赋值给当前的字符串 string&amp; assign(const char *s); &#x2F;&#x2F;把字符串s赋给当前的字符串 string&amp; assign(const char *s, int n); &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串 string&amp; assign(const string &amp;s); &#x2F;&#x2F;把字符串s赋给当前字符串 string&amp; assign(int n, char c); &#x2F;&#x2F;用n个字符c赋给当前字符串 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041//赋值void test01()&#123; string str1; str1 = &quot;hello world&quot;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; string str2; str2 = str1; cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl; string str3; str3 = &#x27;a&#x27;; cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl; string str4; str4.assign(&quot;hello c++&quot;); cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl; string str5; str5.assign(&quot;hello c++&quot;,5); cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl; string str6; str6.assign(str5); cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl; string str7; str7.assign(5, &#x27;x&#x27;); cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： ​ string的赋值方式很多，operator= 这种方式是比较实用的 3.1.4 string字符串拼接功能描述： 实现在字符串末尾拼接字符串 函数原型： string&amp; operator+=(const char* str); &#x2F;&#x2F;重载+&#x3D;操作符 string&amp; operator+=(const char c); &#x2F;&#x2F;重载+&#x3D;操作符 string&amp; operator+=(const string&amp; str); &#x2F;&#x2F;重载+&#x3D;操作符 string&amp; append(const char *s); &#x2F;&#x2F;把字符串s连接到当前字符串结尾 string&amp; append(const char *s, int n); &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾 string&amp; append(const string &amp;s); &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str) string&amp; append(const string &amp;s, int pos, int n);&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾 示例： 12345678910111213141516171819202122232425262728293031323334//字符串拼接void test01()&#123; string str1 = &quot;我&quot;; str1 += &quot;爱玩游戏&quot;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; str1 += &#x27;:&#x27;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; string str2 = &quot;LOL DNF&quot;; str1 += str2; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; string str3 = &quot;I&quot;; str3.append(&quot; love &quot;); str3.append(&quot;game abcde&quot;, 4); //str3.append(str2); str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾 cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：字符串拼接的重载版本很多，初学阶段记住几种即可 3.1.5 string查找和替换功能描述： 查找：查找指定字符串是否存在 替换：在指定的位置替换字符串 函数原型： int find(const string&amp; str, int pos = 0) const; &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; &#x2F;&#x2F;查找字符c第一次出现位置 int rfind(const string&amp; str, int pos = npos) const; &#x2F;&#x2F;查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const; &#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const; &#x2F;&#x2F;从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; &#x2F;&#x2F;查找字符c最后一次出现位置 string&amp; replace(int pos, int n, const string&amp; str); &#x2F;&#x2F;替换从pos开始n个字符为字符串str string&amp; replace(int pos, int n,const char* s); &#x2F;&#x2F;替换从pos开始的n个字符为字符串s 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142//查找和替换void test01()&#123; //查找 string str1 = &quot;abcdefgde&quot;; int pos = str1.find(&quot;de&quot;); if (pos == -1) &#123; cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl; &#125; pos = str1.rfind(&quot;de&quot;); cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;&#125;void test02()&#123; //替换 string str1 = &quot;abcdefgde&quot;; str1.replace(1, 3, &quot;1111&quot;); cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;&#125;int main() &#123; //test01(); //test02(); system(&quot;pause&quot;); return 0;&#125; 总结： find查找是从左往后，rfind从右往左 find找到字符串后返回查找的第一个字符位置，找不到返回-1 replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串 3.1.6 string字符串比较功能描述： 字符串之间的比较 比较方式： 字符串比较是按字符的ASCII码进行对比 &#x3D; 返回 0 &gt; 返回 1 &lt; 返回 -1 函数原型： int compare(const string &amp;s) const; &#x2F;&#x2F;与字符串s比较 int compare(const char *s) const; &#x2F;&#x2F;与字符串s比较 示例： 12345678910111213141516171819202122232425262728293031//字符串比较void test01()&#123; string s1 = &quot;hello&quot;; string s2 = &quot;aello&quot;; int ret = s1.compare(s2); if (ret == 0) &#123; cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl; &#125; else if (ret &gt; 0) &#123; cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大 3.1.7 string字符存取string中单个字符存取方式有两种 char&amp; operator[](int n); &#x2F;&#x2F;通过[]方式取字符 char&amp; at(int n); &#x2F;&#x2F;通过at方法获取字符 示例： 1234567891011121314151617181920212223242526272829303132void test01()&#123; string str = &quot;hello world&quot;; for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //字符修改 str[0] = &#x27;x&#x27;; str.at(1) = &#x27;x&#x27;; cout &lt;&lt; str &lt;&lt; endl; &#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at 3.1.8 string插入和删除功能描述： 对string字符串进行插入和删除字符操作 函数原型： string&amp; insert(int pos, const char* s); &#x2F;&#x2F;插入字符串 string&amp; insert(int pos, const string&amp; str); &#x2F;&#x2F;插入字符串 string&amp; insert(int pos, int n, char c); &#x2F;&#x2F;在指定位置插入n个字符c string&amp; erase(int pos, int n = npos); &#x2F;&#x2F;删除从Pos开始的n个字符 示例： 12345678910111213141516171819//字符串插入和删除void test01()&#123; string str = &quot;hello&quot;; str.insert(1, &quot;111&quot;); cout &lt;&lt; str &lt;&lt; endl; str.erase(1, 3); //从1号位置开始3个字符 cout &lt;&lt; str &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：插入和删除的起始下标都是从0开始 3.1.9 string子串功能描述： 从字符串中获取想要的子串 函数原型： string substr(int pos = 0, int n = npos) const; &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串 示例： 1234567891011121314151617181920212223//子串void test01()&#123; string str = &quot;abcdefg&quot;; string subStr = str.substr(1, 3); cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl; string email = &quot;hello@sina.com&quot;; int pos = email.find(&quot;@&quot;); string username = email.substr(0, pos); cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息 3.2 vector容器3.2.1 vector基本概念功能： vector数据结构和数组非常相似，也称为单端数组 vector与普通数组区别： 不同之处在于数组是静态空间，而vector可以动态扩展 动态扩展： 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间 vector容器的迭代器是支持随机访问的迭代器 3.2.2 vector构造函数功能描述： 创建vector容器 函数原型： vector&lt;T&gt; v; &#x2F;&#x2F;采用模板实现类实现，默认构造函数 vector(v.begin(), v.end()); &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。 vector(const vector &amp;vec); &#x2F;&#x2F;拷贝构造函数。 示例： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt; v2(v1.begin(), v1.end()); printVector(v2); vector&lt;int&gt; v3(10, 100); printVector(v3); vector&lt;int&gt; v4(v3); printVector(v4);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：vector的多种构造方式没有可比性，灵活使用即可 3.2.3 vector赋值操作功能描述： 给vector容器进行赋值 函数原型： vector&amp; operator=(const vector &amp;vec);&#x2F;&#x2F;重载等号操作符 assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123; vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt;v2; v2 = v1; printVector(v2); vector&lt;int&gt;v3; v3.assign(v1.begin(), v1.end()); printVector(v3); vector&lt;int&gt;v4; v4.assign(10, 100); printVector(v4);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： vector赋值方式比较简单，使用operator&#x3D;，或者assign都可以 3.2.4 vector容量和大小功能描述： 对vector容器的容量和大小操作 函数原型： empty(); &#x2F;&#x2F;判断容器是否为空 capacity(); &#x2F;&#x2F;容器的容量 size(); &#x2F;&#x2F;返回容器中元素的个数 resize(int num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 ​ &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 ​ &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); if (v1.empty()) &#123; cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#125; //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充 v1.resize(15,10); printVector(v1); //resize 重新指定大小 ，若指定的更小，超出部分元素被删除 v1.resize(5); printVector(v1);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 判断是否为空 — empty 返回元素个数 — size 返回容器容量 — capacity 重新指定大小 — resize 3.2.5 vector插入和删除功能描述： 对vector容器进行插入、删除操作 函数原型： push_back(ele); &#x2F;&#x2F;尾部插入元素ele pop_back(); &#x2F;&#x2F;删除最后一个元素 insert(const_iterator pos, ele); &#x2F;&#x2F;迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele erase(const_iterator pos); &#x2F;&#x2F;删除迭代器指向的元素 erase(const_iterator start, const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素 clear(); &#x2F;&#x2F;删除容器中所有元素 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; vector&lt;int&gt; v1; //尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入 v1.insert(v1.begin(), 100); printVector(v1); v1.insert(v1.begin(), 2, 1000); printVector(v1); //删除 v1.erase(v1.begin()); printVector(v1); //清空 v1.erase(v1.begin(), v1.end()); v1.clear(); printVector(v1);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 尾插 — push_back 尾删 — pop_back 插入 — insert (位置迭代器) 删除 — erase （位置迭代器） 清空 — clear 3.2.6 vector数据存取功能描述： 对vector中的数据的存取操作 函数原型： at(int idx); &#x2F;&#x2F;返回索引idx所指的数据 operator[]; &#x2F;&#x2F;返回索引idx所指的数据 front(); &#x2F;&#x2F;返回容器中第一个数据元素 back(); &#x2F;&#x2F;返回容器中最后一个数据元素 示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl; cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 除了用迭代器获取vector容器中元素，[ ]和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.2.7 vector互换容器功能描述： 实现两个容器内元素进行互换 函数原型： swap(vec); &#x2F;&#x2F; 将vec与本身的元素互换 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt;v2; for (int i = 10; i &gt; 0; i--) &#123; v2.push_back(i); &#125; printVector(v2); //互换容器 cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl; v1.swap(v2); printVector(v1); printVector(v2);&#125;void test02()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; v.resize(3); cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; //收缩内存 vector&lt;int&gt;(v).swap(v); //匿名对象 cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：swap可以使两个容器互换，可以达到实用的收缩内存效果 3.2.8 vector预留空间功能描述： 减少vector在动态扩展容量时的扩展次数 函数原型： reserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。 示例： 123456789101112131415161718192021222324252627282930#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt; v; //预留空间 v.reserve(100000); int num = 0; int* p = NULL; for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); if (p != &amp;v[0]) &#123; p = &amp;v[0]; num++; &#125; &#125; cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：如果数据量较大，可以一开始利用reserve预留空间 3.3 deque容器3.3.1 deque容器基本概念功能： 双端数组，可以对头端进行插入删除操作 deque与vector区别： vector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度回比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关 deque内部工作原理: deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据 中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间 deque容器的迭代器也是支持随机访问的 3.3.2 deque构造函数功能描述： deque容器构造 函数原型： deque&lt;T&gt; deqT; &#x2F;&#x2F;默认构造形式 deque(beg, end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。 deque(const deque &amp;deq); &#x2F;&#x2F;拷贝构造函数 示例： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//deque构造void test01() &#123; deque&lt;int&gt; d1; //无参构造函数 for (int i = 0; i &lt; 10; i++) &#123; d1.push_back(i); &#125; printDeque(d1); deque&lt;int&gt; d2(d1.begin(),d1.end()); printDeque(d2); deque&lt;int&gt;d3(10,100); printDeque(d3); deque&lt;int&gt;d4 = d3; printDeque(d4);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：deque容器和vector容器的构造方式几乎一致，灵活使用即可 3.3.3 deque赋值操作功能描述： 给deque容器进行赋值 函数原型： deque&amp; operator=(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符 assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123; deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) &#123; d1.push_back(i); &#125; printDeque(d1); deque&lt;int&gt;d2; d2 = d1; printDeque(d2); deque&lt;int&gt;d3; d3.assign(d1.begin(), d1.end()); printDeque(d3); deque&lt;int&gt;d4; d4.assign(10, 100); printDeque(d4);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：deque赋值操作也与vector相同，需熟练掌握 3.3.4 deque大小操作功能描述： 对deque容器的大小进行操作 函数原型： deque.empty(); &#x2F;&#x2F;判断容器是否为空 deque.size(); &#x2F;&#x2F;返回容器中元素的个数 deque.resize(num); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。 ​ &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。 deque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。 ​ &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//大小操作void test01()&#123; deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) &#123; d1.push_back(i); &#125; printDeque(d1); //判断容器是否为空 if (d1.empty()) &#123; cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl; //统计大小 cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl; &#125; //重新指定大小 d1.resize(15, 1); printDeque(d1); d1.resize(5); printDeque(d1);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： deque没有容量的概念 判断是否为空 — empty 返回元素个数 — size 重新指定个数 — resize 3.3.5 deque 插入和删除功能描述： 向deque容器中插入和删除数据 函数原型： 两端插入操作： push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据 push_front(elem); &#x2F;&#x2F;在容器头部插入一个数据 pop_back(); &#x2F;&#x2F;删除容器最后一个数据 pop_front(); &#x2F;&#x2F;删除容器第一个数据 指定位置操作： insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。 clear(); &#x2F;&#x2F;清空容器的所有数据 erase(beg,end); &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//两端操作void test01()&#123; deque&lt;int&gt; d; //尾插 d.push_back(10); d.push_back(20); //头插 d.push_front(100); d.push_front(200); printDeque(d); //尾删 d.pop_back(); //头删 d.pop_front(); printDeque(d);&#125;//插入void test02()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.insert(d.begin(), 1000); printDeque(d); d.insert(d.begin(), 2,10000); printDeque(d); deque&lt;int&gt;d2; d2.push_back(1); d2.push_back(2); d2.push_back(3); d.insert(d.begin(), d2.begin(), d2.end()); printDeque(d);&#125;//删除void test03()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.erase(d.begin()); printDeque(d); d.erase(d.begin(), d.end()); d.clear(); printDeque(d);&#125;int main() &#123; //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0;&#125; 总结： 插入和删除提供的位置是迭代器！ 尾插 — push_back 尾删 — pop_back 头插 — push_front 头删 — pop_front 3.3.6 deque 数据存取功能描述： 对deque 中的数据的存取操作 函数原型： at(int idx); &#x2F;&#x2F;返回索引idx所指的数据 operator[]; &#x2F;&#x2F;返回索引idx所指的数据 front(); &#x2F;&#x2F;返回容器中第一个数据元素 back(); &#x2F;&#x2F;返回容器中最后一个数据元素 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//数据存取void test01()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); for (int i = 0; i &lt; d.size(); i++) &#123; cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; d.size(); i++) &#123; cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl; cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 除了用迭代器获取deque容器中元素，[ ]和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.3.7 deque 排序功能描述： 利用算法实现对deque容器进行排序 算法： sort(iterator beg, iterator end) &#x2F;&#x2F;对beg和end区间内元素进行排序 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;deque&gt;#include &lt;algorithm&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); sort(d.begin(), d.end()); printDeque(d);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：sort算法非常实用，使用时包含头文件 algorithm即可 3.4 案例-评委打分3.4.1 案例描述有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。 3.4.2 实现步骤 创建五名选手，放到vector中 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中 sort算法对deque容器中分数排序，去除最高和最低分 deque容器遍历一遍，累加总分 获取平均分 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//选手类class Person&#123;public: Person(string name, int score) &#123; this-&gt;m_Name = name; this-&gt;m_Score = score; &#125; string m_Name; //姓名 int m_Score; //平均分&#125;;void createPerson(vector&lt;Person&gt;&amp;v)&#123; string nameSeed = &quot;ABCDE&quot;; for (int i = 0; i &lt; 5; i++) &#123; string name = &quot;选手&quot;; name += nameSeed[i]; int score = 0; Person p(name, score); //将创建的person对象 放入到容器中 v.push_back(p); &#125;&#125;//打分void setScore(vector&lt;Person&gt;&amp;v)&#123; for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; //将评委的分数 放入到deque容器中 deque&lt;int&gt;d; for (int i = 0; i &lt; 10; i++) &#123; int score = rand() % 41 + 60; // 60 ~ 100 d.push_back(score); &#125; //cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl; //for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) //&#123; // cout &lt;&lt; *dit &lt;&lt; &quot; &quot;; //&#125; //cout &lt;&lt; endl; //排序 sort(d.begin(), d.end()); //去除最高和最低分 d.pop_back(); d.pop_front(); //取平均分 int sum = 0; for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) &#123; sum += *dit; //累加每个评委的分数 &#125; int avg = sum / d.size(); //将平均分 赋值给选手身上 it-&gt;m_Score = avg; &#125;&#125;void showScore(vector&lt;Person&gt;&amp;v)&#123; for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 平均分： &quot; &lt;&lt; it-&gt;m_Score &lt;&lt; endl; &#125;&#125;int main() &#123; //随机数种子 srand((unsigned int)time(NULL)); //1、创建5名选手 vector&lt;Person&gt;v; //存放选手容器 createPerson(v); //测试 //for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) //&#123; // cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl; //&#125; //2、给5名选手打分 setScore(v); //3、显示最后得分 showScore(v); system(&quot;pause&quot;); return 0;&#125; 总结： 选取不同的容器操作数据，可以提升代码的效率 3.5 stack容器3.5.1 stack 基本概念概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口 栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为 栈中进入数据称为 — 入栈 push 栈中弹出数据称为 — 出栈 pop 生活中的栈： 3.5.2 stack 常用接口功能描述：栈容器常用的对外接口 构造函数： stack&lt;T&gt; stk; &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式 stack(const stack &amp;stk); &#x2F;&#x2F;拷贝构造函数 赋值操作： stack&amp; operator=(const stack &amp;stk); &#x2F;&#x2F;重载等号操作符 数据存取： push(elem); &#x2F;&#x2F;向栈顶添加元素 pop(); &#x2F;&#x2F;从栈顶移除第一个元素 top(); &#x2F;&#x2F;返回栈顶元素 大小操作： empty(); &#x2F;&#x2F;判断堆栈是否为空 size(); &#x2F;&#x2F;返回栈的大小 示例： 12345678910111213141516171819202122232425262728293031#include &lt;stack&gt;//栈容器常用接口void test01()&#123; //创建栈容器 栈容器必须符合先进后出 stack&lt;int&gt; s; //向栈中添加元素，叫做 压栈 入栈 s.push(10); s.push(20); s.push(30); while (!s.empty()) &#123; //输出栈顶元素 cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl; //弹出栈顶元素 s.pop(); &#125; cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 入栈 — push 出栈 — pop 返回栈顶 — top 判断栈是否为空 — empty 返回栈大小 — size 3.6 queue 容器3.6.1 queue 基本概念概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口 队列容器允许从一端新增元素，从另一端移除元素 队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为 队列中进数据称为 — 入队 push 队列中出数据称为 — 出队 pop 生活中的队列： 3.6.2 queue 常用接口功能描述：栈容器常用的对外接口 构造函数： queue&lt;T&gt; que; &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式 queue(const queue &amp;que); &#x2F;&#x2F;拷贝构造函数 赋值操作： queue&amp; operator=(const queue &amp;que); &#x2F;&#x2F;重载等号操作符 数据存取： push(elem); &#x2F;&#x2F;往队尾添加元素 pop(); &#x2F;&#x2F;从队头移除第一个元素 back(); &#x2F;&#x2F;返回最后一个元素 front(); &#x2F;&#x2F;返回第一个元素 大小操作： empty(); &#x2F;&#x2F;判断堆栈是否为空 size(); &#x2F;&#x2F;返回栈的大小 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;queue&gt;#include &lt;string&gt;class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;void test01() &#123; //创建队列 queue&lt;Person&gt; q; //准备数据 Person p1(&quot;唐僧&quot;, 30); Person p2(&quot;孙悟空&quot;, 1000); Person p3(&quot;猪八戒&quot;, 900); Person p4(&quot;沙僧&quot;, 800); //向队列中添加元素 入队操作 q.push(p1); q.push(p2); q.push(p3); q.push(p4); //队列不提供迭代器，更不支持随机访问 while (!q.empty()) &#123; //输出队头元素 cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl; cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl; cout &lt;&lt; endl; //弹出队头元素 q.pop(); &#125; cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 入队 — push 出队 — pop 返回队头元素 — front 返回队尾元素 — back 判断队是否为空 — empty 返回队列大小 — size 3.7 list容器3.7.1 list基本概念功能：将数据进行链式存储 链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的 链表的组成：链表由一系列结点组成 结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域 STL中的链表是一个双向循环链表 由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器 list的优点： 采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 list的缺点： 链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大 List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。 总结：STL中List和vector是两个最常被使用的容器，各有优缺点 3.7.2 list构造函数功能描述： 创建list容器 函数原型： list&lt;T&gt; lst; &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式： list(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。 list(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数。 示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); list&lt;int&gt;L2(L1.begin(),L1.end()); printList(L2); list&lt;int&gt;L3(L2); printList(L3); list&lt;int&gt;L4(10, 1000); printList(L4);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：list构造方式同其他几个STL常用容器，熟练掌握即可 3.7.3 list 赋值和交换功能描述： 给list容器进行赋值，以及交换list容器 函数原型： assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。 list&amp; operator=(const list &amp;lst); &#x2F;&#x2F;重载等号操作符 swap(lst); &#x2F;&#x2F;将lst与本身的元素互换。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//赋值和交换void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); //赋值 list&lt;int&gt;L2; L2 = L1; printList(L2); list&lt;int&gt;L3; L3.assign(L2.begin(), L2.end()); printList(L3); list&lt;int&gt;L4; L4.assign(10, 100); printList(L4);&#125;//交换void test02()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); list&lt;int&gt;L2; L2.assign(10, 100); cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl; printList(L1); printList(L2); cout &lt;&lt; endl; L1.swap(L2); cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl; printList(L1); printList(L2);&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：list赋值和交换操作能够灵活运用即可 3.7.4 list 大小操作功能描述： 对list容器的大小进行操作 函数原型： size(); &#x2F;&#x2F;返回容器中元素的个数 empty(); &#x2F;&#x2F;判断容器是否为空 resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 ​ &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。 resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//大小操作void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); if (L1.empty()) &#123; cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl; &#125; //重新指定大小 L1.resize(10); printList(L1); L1.resize(2); printList(L1);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 判断是否为空 — empty 返回元素个数 — size 重新指定个数 — resize 3.7.5 list 插入和删除功能描述： 对list容器进行数据的插入和删除 函数原型： push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素 pop_back();&#x2F;&#x2F;删除容器中最后一个元素 push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素 pop_front();&#x2F;&#x2F;从容器开头移除第一个元素 insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。 clear();&#x2F;&#x2F;移除容器的所有数据 erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。 remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; list&lt;int&gt; L; //尾插 L.push_back(10); L.push_back(20); L.push_back(30); //头插 L.push_front(100); L.push_front(200); L.push_front(300); printList(L); //尾删 L.pop_back(); printList(L); //头删 L.pop_front(); printList(L); //插入 list&lt;int&gt;::iterator it = L.begin(); L.insert(++it, 1000); printList(L); //删除 it = L.begin(); L.erase(++it); printList(L); //移除 L.push_back(10000); L.push_back(10000); L.push_back(10000); printList(L); L.remove(10000); printList(L); //清空 L.clear(); printList(L);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 尾插 — push_back 尾删 — pop_back 头插 — push_front 头删 — pop_front 插入 — insert 删除 — erase 移除 — remove 清空 — clear 3.7.6 list 数据存取功能描述： 对list容器中数据进行存取 函数原型： front(); &#x2F;&#x2F;返回第一个元素。 back(); &#x2F;&#x2F;返回最后一个元素。 示例： 12345678910111213141516171819202122232425262728293031#include &lt;list&gt;//数据存取void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据 //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据 cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl; cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl; //list容器的迭代器是双向迭代器，不支持随机访问 list&lt;int&gt;::iterator it = L1.begin(); //it = it + 1;//错误，不可以跳跃访问，即使是+1&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： list容器中不可以通过[]或者at方式访问数据 返回第一个元素 — front 返回最后一个元素 — back 3.7.7 list 反转和排序功能描述： 将容器中的元素反转，以及将容器中的数据进行排序 函数原型： reverse(); &#x2F;&#x2F;反转链表 sort(); &#x2F;&#x2F;链表排序 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;bool myCompare(int val1 , int val2)&#123; return val1 &gt; val2;&#125;//反转和排序void test01()&#123; list&lt;int&gt; L; L.push_back(90); L.push_back(30); L.push_back(20); L.push_back(70); printList(L); //反转容器的元素 L.reverse(); printList(L); //排序 L.sort(); //默认的排序规则 从小到大 printList(L); L.sort(myCompare); //指定规则，从大到小 printList(L);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 反转 — reverse 排序 — sort （成员函数） 3.7.8 排序案例案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高 排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;list&gt;#include &lt;string&gt;class Person &#123;public: Person(string name, int age , int height) &#123; m_Name = name; m_Age = age; m_Height = height; &#125;public: string m_Name; //姓名 int m_Age; //年龄 int m_Height; //身高&#125;;bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123; if (p1.m_Age == p2.m_Age) &#123; return p1.m_Height &gt; p2.m_Height; &#125; else &#123; return p1.m_Age &lt; p2.m_Age; &#125;&#125;void test01() &#123; list&lt;Person&gt; L; Person p1(&quot;刘备&quot;, 35 , 175); Person p2(&quot;曹操&quot;, 45 , 180); Person p3(&quot;孙权&quot;, 40 , 170); Person p4(&quot;赵云&quot;, 25 , 190); Person p5(&quot;张飞&quot;, 35 , 160); Person p6(&quot;关羽&quot;, 35 , 200); L.push_back(p1); L.push_back(p2); L.push_back(p3); L.push_back(p4); L.push_back(p5); L.push_back(p6); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl; &#125; cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl; L.sort(ComparePerson); //排序 for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序 高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂 3.8 set&#x2F; multiset 容器3.8.1 set基本概念简介： 所有元素都会在插入时自动被排序 本质： set&#x2F;multiset属于关联式容器，底层结构是用二叉树实现。 set和multiset区别： set不允许容器中有重复的元素 multiset允许容器中有重复的元素 3.8.2 set构造和赋值功能描述：创建set容器以及赋值 构造： set&lt;T&gt; st; &#x2F;&#x2F;默认构造函数： set(const set &amp;st); &#x2F;&#x2F;拷贝构造函数 赋值： set&amp; operator=(const set &amp;st); &#x2F;&#x2F;重载等号操作符 示例： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//构造和赋值void test01()&#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //拷贝构造 set&lt;int&gt;s2(s1); printSet(s2); //赋值 set&lt;int&gt;s3; s3 = s2; printSet(s3);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： set容器插入数据时用insert set容器插入数据的数据会自动排序 3.8.3 set大小和交换功能描述： 统计set容器大小以及交换set容器 函数原型： size(); &#x2F;&#x2F;返回容器中元素的数目 empty(); &#x2F;&#x2F;判断容器是否为空 swap(st); &#x2F;&#x2F;交换两个集合容器 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//大小void test01()&#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); if (s1.empty()) &#123; cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl; &#125;&#125;//交换void test02()&#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); set&lt;int&gt; s2; s2.insert(100); s2.insert(300); s2.insert(200); s2.insert(400); cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl; printSet(s1); printSet(s2); cout &lt;&lt; endl; cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl; s1.swap(s2); printSet(s1); printSet(s2);&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结： 统计大小 — size 判断是否为空 — empty 交换容器 — swap 3.8.4 set插入和删除功能描述： set容器进行插入数据和删除数据 函数原型： insert(elem); &#x2F;&#x2F;在容器中插入元素。 clear(); &#x2F;&#x2F;清除所有元素 erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem); &#x2F;&#x2F;删除容器中值为elem的元素。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //删除 s1.erase(s1.begin()); printSet(s1); s1.erase(30); printSet(s1); //清空 //s1.erase(s1.begin(), s1.end()); s1.clear(); printSet(s1);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 插入 — insert 删除 — erase 清空 — clear 3.8.5 set查找和统计功能描述： 对set容器进行查找数据以及统计数据 函数原型： find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); &#x2F;&#x2F;统计key的元素个数 示例： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;set&gt;//查找和统计void test01()&#123; set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); //查找 set&lt;int&gt;::iterator pos = s1.find(30); if (pos != s1.end()) &#123; cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl; &#125; //统计 int num = s1.count(30); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 查找 — find （返回的是迭代器） 统计 — count （对于set，结果为0或者1） 3.8.6 set和multiset区别学习目标： 掌握set和multiset的区别 区别： set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;set&gt;//set和multiset区别void test01()&#123; set&lt;int&gt; s; pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert(10); if (ret.second) &#123; cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl; &#125; ret = s.insert(10); if (ret.second) &#123; cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl; &#125; //multiset multiset&lt;int&gt; ms; ms.insert(10); ms.insert(10); for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 如果不允许插入重复数据可以利用set 如果需要插入重复数据利用multiset 3.8.7 pair对组创建功能描述： 成对出现的数据，利用对组可以返回两个数据 两种创建方式： pair&lt;type, type&gt; p ( value1, value2 ); pair&lt;type, type&gt; p = make_pair( value1, value2 ); 示例： 1234567891011121314151617181920#include &lt;string&gt;//对组创建void test01()&#123; pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl; pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 两种方式都可以创建对组，记住一种即可 3.8.8 set容器排序学习目标： set容器默认排序规则为从小到大，掌握如何改变排序规则 主要技术点： 利用仿函数，可以改变排序规则 示例一 set存放内置数据类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;set&gt;class MyCompare &#123;public: bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125;&#125;;void test01() &#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(40); s1.insert(20); s1.insert(30); s1.insert(50); //默认从小到大 for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //指定排序规则 set&lt;int,MyCompare&gt; s2; s2.insert(10); s2.insert(40); s2.insert(20); s2.insert(30); s2.insert(50); for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：利用仿函数可以指定set容器的排序规则 示例二 set存放自定义数据类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;set&gt;#include &lt;string&gt;class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;class comparePerson&#123;public: bool operator()(const Person&amp; p1, const Person &amp;p2) &#123; //按照年龄进行排序 降序 return p1.m_Age &gt; p2.m_Age; &#125;&#125;;void test01()&#123; set&lt;Person, comparePerson&gt; s; Person p1(&quot;刘备&quot;, 23); Person p2(&quot;关羽&quot;, 27); Person p3(&quot;张飞&quot;, 25); Person p4(&quot;赵云&quot;, 21); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 对于自定义数据类型，set必须指定排序规则才可以插入数据 3.9 map&#x2F; multimap容器3.9.1 map基本概念简介： map中所有元素都是pair pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 本质： map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。 优点： 可以根据key值快速找到value值 map和multimap区别： map不允许容器中有重复key值元素 multimap允许容器中有重复key值元素 3.9.2 map构造和赋值功能描述： 对map容器进行构造和赋值操作 函数原型： 构造： map&lt;T1, T2&gt; mp; &#x2F;&#x2F;map默认构造函数: map(const map &amp;mp); &#x2F;&#x2F;拷贝构造函数 赋值： map&amp; operator=(const map &amp;mp); &#x2F;&#x2F;重载等号操作符 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; map&lt;int,int&gt;m; //默认构造 m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); printMap(m); map&lt;int, int&gt;m2(m); //拷贝构造 printMap(m2); map&lt;int, int&gt;m3; m3 = m2; //赋值 printMap(m3);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：map中所有元素都是成对出现，插入数据时候要使用对组 3.9.3 map大小和交换功能描述： 统计map容器大小以及交换map容器 函数原型： size(); &#x2F;&#x2F;返回容器中元素的数目 empty(); &#x2F;&#x2F;判断容器是否为空 swap(st); &#x2F;&#x2F;交换两个集合容器 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); if (m.empty()) &#123; cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl; &#125;&#125;//交换void test02()&#123; map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); map&lt;int, int&gt;m2; m2.insert(pair&lt;int, int&gt;(4, 100)); m2.insert(pair&lt;int, int&gt;(5, 200)); m2.insert(pair&lt;int, int&gt;(6, 300)); cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl; printMap(m); printMap(m2); cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl; m.swap(m2); printMap(m); printMap(m2);&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结： 统计大小 — size 判断是否为空 — empty 交换容器 — swap 3.9.4 map插入和删除功能描述： map容器进行插入数据和删除数据 函数原型： insert(elem); &#x2F;&#x2F;在容器中插入元素。 clear(); &#x2F;&#x2F;清除所有元素 erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(key); &#x2F;&#x2F;删除容器中值为key的元素。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; //插入 map&lt;int, int&gt; m; //第一种插入方式 m.insert(pair&lt;int, int&gt;(1, 10)); //第二种插入方式 m.insert(make_pair(2, 20)); //第三种插入方式 m.insert(map&lt;int, int&gt;::value_type(3, 30)); //第四种插入方式 m[4] = 40; printMap(m); //删除 m.erase(m.begin()); printMap(m); m.erase(3); printMap(m); //清空 m.erase(m.begin(),m.end()); m.clear(); printMap(m);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： map插入方式很多，记住其一即可 插入 — insert 删除 — erase 清空 — clear 3.9.5 map查找和统计功能描述： 对map容器进行查找数据以及统计数据 函数原型： find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); &#x2F;&#x2F;统计key的元素个数 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;map&gt;//查找和统计void test01()&#123; map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); //查找 map&lt;int, int&gt;::iterator pos = m.find(3); if (pos != m.end()) &#123; cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl; &#125; //统计 int num = m.count(3); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 查找 — find （返回的是迭代器） 统计 — count （对于map，结果为0或者1） 3.9.6 map容器排序学习目标： map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则 主要技术点: 利用仿函数，可以改变排序规则 示例： 123456789101112131415161718192021222324252627282930313233#include &lt;map&gt;class MyCompare &#123;public: bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125;&#125;;void test01() &#123; //默认从小到大排序 //利用仿函数实现从大到小排序 map&lt;int, int, MyCompare&gt; m; m.insert(make_pair(1, 10)); m.insert(make_pair(2, 20)); m.insert(make_pair(3, 30)); m.insert(make_pair(4, 40)); m.insert(make_pair(5, 50)); for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 利用仿函数可以指定map容器的排序规则 对于自定义数据类型，map必须要指定排序规则,同set容器 3.10 案例-员工分组3.10.1 案例描述 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给10名员工分配部门和工资 通过multimap进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息 3.10.2 实现步骤 创建10名员工，放到vector中 遍历vector容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中 分部门显示员工信息 案例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;ctime&gt;/*- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作- 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发- 随机给10名员工分配部门和工资- 通过multimap进行信息的插入 key(部门编号) value(员工)- 分部门显示员工信息*/#define CEHUA 0#define MEISHU 1#define YANFA 2class Worker&#123;public: string m_Name; int m_Salary;&#125;;void createWorker(vector&lt;Worker&gt;&amp;v)&#123; string nameSeed = &quot;ABCDEFGHIJ&quot;; for (int i = 0; i &lt; 10; i++) &#123; Worker worker; worker.m_Name = &quot;员工&quot;; worker.m_Name += nameSeed[i]; worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999 //将员工放入到容器中 v.push_back(worker); &#125;&#125;//员工分组void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)&#123; for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; //产生随机部门编号 int deptId = rand() % 3; // 0 1 2 //将员工插入到分组中 //key部门编号，value具体员工 m.insert(make_pair(deptId, *it)); &#125;&#125;void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)&#123; // 0 A B C 1 D E 2 F G ... cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl; multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA); int count = m.count(CEHUA); // 统计具体人数 int index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; &#125; cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl; pos = m.find(MEISHU); count = m.count(MEISHU); // 统计具体人数 index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; &#125; cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl; pos = m.find(YANFA); count = m.count(YANFA); // 统计具体人数 index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; &#125;&#125;int main() &#123; srand((unsigned int)time(NULL)); //1、创建员工 vector&lt;Worker&gt;vWorker; createWorker(vWorker); //2、员工分组 multimap&lt;int, Worker&gt;mWorker; setGroup(vWorker, mWorker); //3、分组显示员工 showWorkerByGourp(mWorker); ////测试 //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++) //&#123; // cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl; //&#125; system(&quot;pause&quot;); return 0;&#125; 总结： 当数据以键值对形式存在，可以考虑用map 或 multimap 4 STL- 函数对象4.1 函数对象4.1.1 函数对象概念概念： 重载函数调用操作符的类，其对象常称为函数对象 函数对象使用重载的()时，行为类似函数调用，也叫仿函数 本质： 函数对象(仿函数)是一个类，不是一个函数 4.1.2 函数对象使用特点： 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 函数对象超出普通函数的概念，函数对象可以有自己的状态 函数对象可以作为参数传递 示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;string&gt;//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值class MyAdd&#123;public : int operator()(int v1,int v2) &#123; return v1 + v2; &#125;&#125;;void test01()&#123; MyAdd myAdd; cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;&#125;//2、函数对象可以有自己的状态class MyPrint&#123;public: MyPrint() &#123; count = 0; &#125; void operator()(string test) &#123; cout &lt;&lt; test &lt;&lt; endl; count++; //统计使用次数 &#125; int count; //内部自己的状态&#125;;void test02()&#123; MyPrint myPrint; myPrint(&quot;hello world&quot;); myPrint(&quot;hello world&quot;); myPrint(&quot;hello world&quot;); cout &lt;&lt; &quot;myPrint调用次数为： &quot; &lt;&lt; myPrint.count &lt;&lt; endl;&#125;//3、函数对象可以作为参数传递void doPrint(MyPrint &amp;mp , string test)&#123; mp(test);&#125;void test03()&#123; MyPrint myPrint; doPrint(myPrint, &quot;Hello C++&quot;);&#125;int main() &#123; //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0;&#125; 总结： 仿函数写法非常灵活，可以作为参数进行传递。 4.2 谓词4.2.1 谓词概念概念： 返回bool类型的仿函数称为谓词 如果operator()接受一个参数，那么叫做一元谓词 如果operator()接受两个参数，那么叫做二元谓词 4.2.2 一元谓词示例： 123456789101112131415161718192021222324252627282930313233343536#include &lt;vector&gt;#include &lt;algorithm&gt;//1.一元谓词struct GreaterFive&#123; bool operator()(int val) &#123; return val &gt; 5; &#125;&#125;;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) &#123; cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：参数只有一个的谓词，称为一元谓词 4.2.3 二元谓词示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;vector&gt;#include &lt;algorithm&gt;//二元谓词class MyCompare&#123;public: bool operator()(int num1, int num2) &#123; return num1 &gt; num2; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.push_back(50); //默认从小到大 sort(v.begin(), v.end()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：参数只有两个的谓词，称为二元谓词 4.3 内建函数对象4.3.1 内建函数对象意义概念： STL内建了一些函数对象 分类: 算术仿函数 关系仿函数 逻辑仿函数 用法： 这些仿函数所产生的对象，用法和一般函数完全相同 使用内建函数对象，需要引入头文件 #include&lt;functional&gt; 4.3.2 算术仿函数功能描述： 实现四则运算 其中negate是一元运算，其他都是二元运算 仿函数原型： template&lt;class T&gt; T plus&lt;T&gt; &#x2F;&#x2F;加法仿函数 template&lt;class T&gt; T minus&lt;T&gt; &#x2F;&#x2F;减法仿函数 template&lt;class T&gt; T multiplies&lt;T&gt; &#x2F;&#x2F;乘法仿函数 template&lt;class T&gt; T divides&lt;T&gt; &#x2F;&#x2F;除法仿函数 template&lt;class T&gt; T modulus&lt;T&gt; &#x2F;&#x2F;取模仿函数 template&lt;class T&gt; T negate&lt;T&gt; &#x2F;&#x2F;取反仿函数 示例： 123456789101112131415161718192021222324#include &lt;functional&gt;//negatevoid test01()&#123; negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl;&#125;//plusvoid test02()&#123; plus&lt;int&gt; p; cout &lt;&lt; p(10, 20) &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：使用内建函数对象时，需要引入头文件 #include &lt;functional&gt; 4.3.3 关系仿函数功能描述： 实现关系对比 仿函数原型： template&lt;class T&gt; bool equal_to&lt;T&gt; &#x2F;&#x2F;等于 template&lt;class T&gt; bool not_equal_to&lt;T&gt; &#x2F;&#x2F;不等于 template&lt;class T&gt; bool greater&lt;T&gt; &#x2F;&#x2F;大于 template&lt;class T&gt; bool greater_equal&lt;T&gt; &#x2F;&#x2F;大于等于 template&lt;class T&gt; bool less&lt;T&gt; &#x2F;&#x2F;小于 template&lt;class T&gt; bool less_equal&lt;T&gt; &#x2F;&#x2F;小于等于 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class MyCompare&#123;public: bool operator()(int v1,int v2) &#123; return v1 &gt; v2; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(40); v.push_back(20); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //自己实现仿函数 //sort(v.begin(), v.end(), MyCompare()); //STL内建仿函数 大于仿函数 sort(v.begin(), v.end(), greater&lt;int&gt;()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：关系仿函数中最常用的就是greater&lt;&gt;大于 4.3.4 逻辑仿函数功能描述： 实现逻辑运算 函数原型： template&lt;class T&gt; bool logical_and&lt;T&gt; &#x2F;&#x2F;逻辑与 template&lt;class T&gt; bool logical_or&lt;T&gt; &#x2F;&#x2F;逻辑或 template&lt;class T&gt; bool logical_not&lt;T&gt; &#x2F;&#x2F;逻辑非 示例： 123456789101112131415161718192021222324252627282930313233343536#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01()&#123; vector&lt;bool&gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //逻辑非 将v容器搬运到v2中，并执行逻辑非运算 vector&lt;bool&gt; v2; v2.resize(v.size()); transform(v.begin(), v.end(), v2.begin(), logical_not&lt;bool&gt;()); for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：逻辑仿函数实际应用较少，了解即可 5 STL- 常用算法概述: 算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。 &lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等 &lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数 &lt;functional&gt;定义了一些模板类,用以声明函数对象。 5.1 常用遍历算法学习目标： 掌握常用的遍历算法 算法简介： for_each &#x2F;&#x2F;遍历容器 transform &#x2F;&#x2F;搬运容器到另一个容器中 5.1.1 for_each功能描述： 实现遍历容器 函数原型： for_each(iterator beg, iterator end, _func); &#x2F;&#x2F; 遍历算法 遍历容器元素 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; _func 函数或者函数对象 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;vector&gt;//普通函数void print01(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;//函数对象class print02 &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;//for_each算法基本用法void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //遍历算法 for_each(v.begin(), v.end(), print01); cout &lt;&lt; endl; for_each(v.begin(), v.end(), print02()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握 5.1.2 transform功能描述： 搬运容器到另一个容器中 函数原型： transform(iterator beg1, iterator end1, iterator beg2, _func); &#x2F;&#x2F;beg1 源容器开始迭代器 &#x2F;&#x2F;end1 源容器结束迭代器 &#x2F;&#x2F;beg2 目标容器开始迭代器 &#x2F;&#x2F;_func 函数或者函数对象 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;vector&gt;#include&lt;algorithm&gt;//常用遍历算法 搬运 transformclass TransForm&#123;public: int operator()(int val) &#123; return val; &#125;&#125;;class MyPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;vTarget; //目标容器 vTarget.resize(v.size()); // 目标容器需要提前开辟空间 transform(v.begin(), v.end(), vTarget.begin(), TransForm()); for_each(vTarget.begin(), vTarget.end(), MyPrint());&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运 5.2 常用查找算法学习目标： 掌握常用的查找算法 算法简介： find &#x2F;&#x2F;查找元素 find_if &#x2F;&#x2F;按条件查找元素 adjacent_find &#x2F;&#x2F;查找相邻重复元素 binary_search &#x2F;&#x2F;二分查找法 count &#x2F;&#x2F;统计元素个数 count_if &#x2F;&#x2F;按条件统计元素个数 5.2.1 find功能描述： 查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end() 函数原型： find(iterator beg, iterator end, value); &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; value 查找的元素 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; //查找容器中是否有 5 这个元素 vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125;class Person &#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; //重载== bool operator==(const Person&amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false; &#125;public: string m_Name; int m_Age;&#125;;void test02() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125; 总结： 利用find可以在容器中找指定的元素，返回值是迭代器 5.2.2 find_if功能描述： 按条件查找元素 函数原型： find_if(iterator beg, iterator end, _Pred); &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数） 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;//内置数据类型class GreaterFive&#123;public: bool operator()(int val) &#123; return val &gt; 5; &#125;&#125;;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125;//自定义数据类型class Person &#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;public: string m_Name; int m_Age;&#125;;class Greater20&#123;public: bool operator()(Person &amp;p) &#123; return p.m_Age &gt; 20; &#125;&#125;;void test02() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20()); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略 5.2.3 adjacent_find功能描述： 查找相邻重复元素 函数原型： adjacent_find(iterator beg, iterator end); &#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 示例： 1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(5); v.push_back(2); v.push_back(4); v.push_back(4); v.push_back(3); //查找相邻重复元素 vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); if (it == v.end()) &#123; cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法 5.2.4 binary_search功能描述： 查找指定元素是否存在 函数原型： bool binary_search(iterator beg, iterator end, value); &#x2F;&#x2F; 查找指定的元素，查到 返回true 否则false &#x2F;&#x2F; 注意: 在无序序列中不可用 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; value 查找的元素 示例： 12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //二分查找 bool ret = binary_search(v.begin(), v.end(),2); if (ret) &#123; cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列 5.2.5 count功能描述： 统计元素个数 函数原型： count(iterator beg, iterator end, value); &#x2F;&#x2F; 统计元素出现次数 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; value 统计的元素 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;algorithm&gt;#include &lt;vector&gt;//内置数据类型void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count(v.begin(), v.end(), 4); cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; bool operator==(const Person &amp; p) &#123; if (this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; string m_Name; int m_Age;&#125;;void test02()&#123; vector&lt;Person&gt; v; Person p1(&quot;刘备&quot;, 35); Person p2(&quot;关羽&quot;, 35); Person p3(&quot;张飞&quot;, 35); Person p4(&quot;赵云&quot;, 30); Person p5(&quot;曹操&quot;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); Person p(&quot;诸葛亮&quot;,35); int num = count(v.begin(), v.end(), p); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结： 统计自定义数据类型时候，需要配合重载 operator== 5.2.6 count_if功能描述： 按条件统计元素个数 函数原型： count_if(iterator beg, iterator end, _Pred); &#x2F;&#x2F; 按条件统计元素出现次数 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; _Pred 谓词 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;algorithm&gt;#include &lt;vector&gt;class Greater4&#123;public: bool operator()(int val) &#123; return val &gt;= 4; &#125;&#125;;//内置数据类型void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count_if(v.begin(), v.end(), Greater4()); cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;class AgeLess35&#123;public: bool operator()(const Person &amp;p) &#123; return p.m_Age &lt; 35; &#125;&#125;;void test02()&#123; vector&lt;Person&gt; v; Person p1(&quot;刘备&quot;, 35); Person p2(&quot;关羽&quot;, 35); Person p3(&quot;张飞&quot;, 35); Person p4(&quot;赵云&quot;, 30); Person p5(&quot;曹操&quot;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); int num = count_if(v.begin(), v.end(), AgeLess35()); cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：按值统计用count，按条件统计用count_if 5.3 常用排序算法学习目标： 掌握常用的排序算法 算法简介： sort &#x2F;&#x2F;对容器内元素进行排序 random_shuffle &#x2F;&#x2F;洗牌 指定范围内的元素随机调整次序 merge &#x2F;&#x2F; 容器元素合并，并存储到另一容器中 reverse &#x2F;&#x2F; 反转指定范围的元素 5.3.1 sort功能描述： 对容器内元素进行排序 函数原型： sort(iterator beg, iterator end, _Pred); &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; _Pred 谓词 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;vector&gt;void myPrint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01() &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //sort默认从小到大排序 sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; //从大到小排序 sort(v.begin(), v.end(), greater&lt;int&gt;()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：sort属于开发中最常用的算法之一，需熟练掌握 5.3.2 random_shuffle功能描述： 洗牌 指定范围内的元素随机调整次序 函数原型： random_shuffle(iterator beg, iterator end); &#x2F;&#x2F; 指定范围内的元素随机调整次序 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; srand((unsigned int)time(NULL)); vector&lt;int&gt; v; for(int i = 0 ; i &lt; 10;i++) &#123; v.push_back(i); &#125; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //打乱顺序 random_shuffle(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子 5.3.3 merge功能描述： 两个容器元素合并，并存储到另一容器中 函数原型： merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); &#x2F;&#x2F; 容器元素合并，并存储到另一容器中 &#x2F;&#x2F; 注意: 两个容器必须是有序的 &#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器 示例： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10 ; i++) &#123; v1.push_back(i); v2.push_back(i + 1); &#125; vector&lt;int&gt; vtarget; //目标容器需要提前开辟空间 vtarget.resize(v1.size() + v2.size()); //合并 需要两个有序序列 merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin()); for_each(vtarget.begin(), vtarget.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：merge合并的两个容器必须的有序序列 5.3.4 reverse功能描述： 将容器内元素进行反转 函数原型： reverse(iterator beg, iterator end); &#x2F;&#x2F; 反转指定范围的元素 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 示例： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl; reverse(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：reverse反转区间内元素，面试题可能涉及到 5.4 常用拷贝和替换算法学习目标： 掌握常用的拷贝和替换算法 算法简介： copy &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中 replace &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素 replace_if &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素 swap &#x2F;&#x2F; 互换两个容器的元素 5.4.1 copy功能描述： 容器内指定范围的元素拷贝到另一容器中 函数原型： copy(iterator beg, iterator end, iterator dest); &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; dest 目标起始迭代器 示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i + 1); &#125; vector&lt;int&gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：利用copy算法在拷贝时，目标容器记得提前开辟空间 5.4.2 replace功能描述： 将容器内指定范围的旧元素修改为新元素 函数原型： replace(iterator beg, iterator end, oldvalue, newvalue); &#x2F;&#x2F; 将区间内旧元素 替换成 新元素 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; oldvalue 旧元素 &#x2F;&#x2F; newvalue 新元素 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中的20 替换成 2000 cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl; replace(v.begin(), v.end(), 20,2000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：replace会替换区间内满足条件的元素 5.4.3 replace_if功能描述: 将区间内满足条件的元素，替换成指定元素 函数原型： replace_if(iterator beg, iterator end, _pred, newvalue); &#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; _pred 谓词 &#x2F;&#x2F; newvalue 替换的新元素 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;class ReplaceGreater30&#123;public: bool operator()(int val) &#123; return val &gt;= 30; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中大于等于的30 替换成 3000 cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl; replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件 5.4.4 swap功能描述： 互换两个容器的元素 函数原型： swap(container c1, container c2); &#x2F;&#x2F; 互换两个容器的元素 &#x2F;&#x2F; c1容器1 &#x2F;&#x2F; c2容器2 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+100); &#125; cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl; swap(v1, v2); for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：swap交换容器时，注意交换的容器要同种类型 5.5 常用算术生成算法学习目标： 掌握常用的算术生成算法 注意： 算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt; 算法简介： accumulate &#x2F;&#x2F; 计算容器元素累计总和 fill &#x2F;&#x2F; 向容器中添加元素 5.5.1 accumulate功能描述： 计算区间内 容器元素累计总和 函数原型： accumulate(iterator beg, iterator end, value); &#x2F;&#x2F; 计算容器元素累计总和 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; value 起始值 示例： 12345678910111213141516171819202122#include &lt;numeric&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt;= 100; i++) &#123; v.push_back(i); &#125; int total = accumulate(v.begin(), v.end(), 0); cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：accumulate使用时头文件注意是 numeric，这个算法很实用 5.5.2 fill功能描述： 向容器中填充指定的元素 函数原型： fill(iterator beg, iterator end, value); &#x2F;&#x2F; 向容器中填充元素 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; value 填充的值 示例： 123456789101112131415161718192021222324252627282930313233#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.resize(10); //填充 fill(v.begin(), v.end(), 100); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：利用fill可以将容器区间内元素填充为 指定的值 5.6 常用集合算法学习目标： 掌握常用的集合算法 算法简介： set_intersection &#x2F;&#x2F; 求两个容器的交集 set_union &#x2F;&#x2F; 求两个容器的并集 set_difference &#x2F;&#x2F; 求两个容器的差集 5.6.1 set_intersection功能描述： 求两个容器的交集 函数原型： set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); &#x2F;&#x2F; 求两个集合的交集 &#x2F;&#x2F; 注意:两个集合必须是有序序列 &#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个里面较小的值给目标容器开辟空间 vTarget.resize(min(v1.size(), v2.size())); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 求交集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器中取小值 set_intersection返回值既是交集中最后一个元素的位置 5.6.2 set_union功能描述： 求两个集合的并集 函数原型： set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); &#x2F;&#x2F; 求两个集合的并集 &#x2F;&#x2F; 注意:两个集合必须是有序序列 &#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个容器的和给目标容器开辟空间 vTarget.resize(v1.size() + v2.size()); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 求并集的两个集合必须的有序序列 目标容器开辟空间需要两个容器相加 set_union返回值既是并集中最后一个元素的位置 5.6.3 set_difference功能描述： 求两个集合的差集 函数原型： set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); &#x2F;&#x2F; 求两个集合的差集 &#x2F;&#x2F; 注意:两个集合必须是有序序列 &#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个里面较大的值给目标容器开辟空间 vTarget.resize( max(v1.size() , v2.size())); //返回目标容器的最后一个元素的迭代器地址 cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl; vector&lt;int&gt;::iterator itEnd = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl; itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 求差集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器取较大值 set_difference返回值既是差集中最后一个元素的位置","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++ 提高编程 修改2","slug":"C++提高编程修改2","date":"2019-02-13T01:05:24.146Z","updated":"2024-11-08T11:00:56.106Z","comments":true,"path":"2019/02/13/C++提高编程修改2/","link":"","permalink":"http://example.com/2019/02/13/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E4%BF%AE%E6%94%B92/","excerpt":"","text":"C++提高编程 本阶段主要针对C++&#x3D;&#x3D;泛型编程&#x3D;&#x3D;和&#x3D;&#x3D;STL&#x3D;&#x3D;技术做详细讲解，探讨C++更深层的使用 1 模板1.1 模板的概念模板就是建立通用的模具，大大提高复用性 例如生活中的模板 一寸照片模板： PPT模板： 模板的特点： 模板不可以直接使用，它只是一个框架 模板的通用并不是万能的 1.2 函数模板 C++另一种编程思想称为 &#x3D;&#x3D;泛型编程&#x3D;&#x3D; ，主要利用的技术就是模板 C++提供两种模板机制:函数模板和类模板 1.2.1 函数模板语法函数模板作用： 建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。 语法： template&lt;typename T&gt; 函数声明或定义 解释： template — 声明创建模板 typename — 表面其后面的符号是一种数据类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 示例： //交换整型函数 void swapInt(int&amp; a, int&amp; b) &#123; int temp = a; a = b; b = temp; &#125; //交换浮点型函数 void swapDouble(double&amp; a, double&amp; b) &#123; double temp = a; a = b; b = temp; &#125; //利用模板提供通用的交换函数 template&lt;typename T&gt; void mySwap(T&amp; a, T&amp; b) &#123; T temp = a; a = b; b = temp; &#125; void test01() &#123; int a = 10; int b = 20; //swapInt(a, b); //利用模板实现交换 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap&lt;int&gt;(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 函数模板利用关键字 template 使用函数模板有两种方式：自动类型推导、显示指定类型 模板的目的是为了提高复用性，将类型参数化 1.2.2 函数模板注意事项注意事项： 自动类型推导，必须推导出一致的数据类型T,才可以使用 模板必须要确定出T的数据类型，才可以使用 示例： //利用模板提供通用的交换函数 template&lt;class T&gt; void mySwap(T&amp; a, T&amp; b) &#123; T temp = a; a = b; b = temp; &#125; // 1、自动类型推导，必须推导出一致的数据类型T,才可以使用 void test01() &#123; int a = 10; int b = 20; char c = &#39;c&#39;; mySwap(a, b); // 正确，可以推导出一致的T //mySwap(a, c); // 错误，推导不出一致的T类型 &#125; // 2、模板必须要确定出T的数据类型，才可以使用 template&lt;class T&gt; void func() &#123; cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl; &#125; void test02() &#123; //func(); //错误，模板不能独立使用，必须确定出T的类型 func&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板 &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结： 使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型 1.2.3 函数模板案例案例描述： 利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试 示例： //交换的函数模板 template&lt;typename T&gt; void mySwap(T &amp;a, T&amp;b) &#123; T temp = a; a = b; b = temp; &#125; template&lt;class T&gt; // 也可以替换成typename //利用选择排序，进行对数组从大到小的排序 void mySort(T arr[], int len) &#123; for (int i = 0; i &lt; len; i++) &#123; int max = i; //最大数的下标 for (int j = i + 1; j &lt; len; j++) &#123; if (arr[max] &lt; arr[j]) &#123; max = j; &#125; &#125; if (max != i) //如果最大数的下标不是i，交换两者 &#123; mySwap(arr[max], arr[i]); &#125; &#125; &#125; template&lt;typename T&gt; void printArray(T arr[], int len) &#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; void test01() &#123; //测试char数组 char charArr[] = &quot;bdcfeagh&quot;; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num); &#125; void test02() &#123; //测试int数组 int intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num); &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：模板可以提高代码复用，需要熟练掌握 1.2.4 普通函数与函数模板的区别普通函数与函数模板区别： 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换 示例： //普通函数 int myAdd01(int a, int b) &#123; return a + b; &#125; //函数模板 template&lt;class T&gt; T myAdd02(T a, T b) &#123; return a + b; &#125; //使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换 void test01() &#123; int a = 10; int b = 20; char c = &#39;c&#39;; cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的&#39;c&#39;隐式转换为int类型 &#39;c&#39; 对应 ASCII码 99 //myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换 myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T 1.2.5 普通函数与函数模板的调用规则调用规则如下： 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配,优先调用函数模板 示例： //普通函数与函数模板调用规则 void myPrint(int a, int b) &#123; cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl; &#125; template&lt;typename T&gt; void myPrint(T a, T b) &#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl; &#125; template&lt;typename T&gt; void myPrint(T a, T b, T c) &#123; cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; &#125; void test01() &#123; //1、如果函数模板和普通函数都可以实现，优先调用普通函数 // 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 int a = 10; int b = 20; myPrint(a, b); //调用普通函数 //2、可以通过空模板参数列表来强制调用函数模板 myPrint&lt;&gt;(a, b); //调用函数模板 //3、函数模板也可以发生重载 int c = 30; myPrint(a, b, c); //调用重载的函数模板 //4、 如果函数模板可以产生更好的匹配,优先调用函数模板 char c1 = &#39;a&#39;; char c2 = &#39;b&#39;; myPrint(c1, c2); //调用函数模板 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性 1.2.6 模板的局限性局限性： 模板的通用性并不是万能的 例如： template&lt;class T&gt; void f(T a, T b) &#123; a = b; &#125; 在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了 再例如： template&lt;class T&gt; void f(T a, T b) &#123; if(a &gt; b) &#123; ... &#125; &#125; 在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行 因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板 示例： #include&lt;iostream&gt; using namespace std; #include &lt;string&gt; class Person &#123; public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age; &#125;; //普通函数模板 template&lt;class T&gt; bool myCompare(T&amp; a, T&amp; b) &#123; if (a == b) &#123; return true; &#125; else &#123; return false; &#125; &#125; //具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型 //具体化优先于常规模板 template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2) &#123; if ( p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; void test01() &#123; int a = 10; int b = 20; //内置数据类型可以直接使用通用的函数模板 bool ret = myCompare(a, b); if (ret) &#123; cout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl; &#125; &#125; void test02() &#123; Person p1(&quot;Tom&quot;, 10); Person p2(&quot;Tom&quot;, 10); //自定义数据类型，不会调用普通的函数模板 //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型 bool ret = myCompare(p1, p2); if (ret) &#123; cout &lt;&lt; &quot;p1 == p2 &quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结： 利用具体化的模板，可以解决自定义类型的通用化 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板 1.3 类模板1.3.1 类模板语法类模板作用： 建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。 语法： template&lt;typename T&gt; 类 解释： template — 声明创建模板 typename — 表面其后面的符号是一种数据类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 示例： #include &lt;string&gt; //类模板 template&lt;class NameType, class AgeType&gt; class Person &#123; public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125; public: NameType mName; AgeType mAge; &#125;; void test01() &#123; // 指定NameType 为string类型，AgeType 为 int类型 Person&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999); P1.showPerson(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板 1.3.2 类模板与函数模板区别类模板与函数模板区别主要有两点： 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 示例： #include &lt;string&gt; //类模板 template&lt;class NameType, class AgeType = int&gt; class Person &#123; public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125; public: NameType mName; AgeType mAge; &#125;; //1、类模板没有自动类型推导的使用方式 void test01() &#123; // Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导 Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板 p.showPerson(); &#125; //2、类模板在模板参数列表中可以有默认参数 void test02() &#123; Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数 p.showPerson(); &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结： 类模板使用只能用显示指定类型方式 类模板中的模板参数列表可以有默认参数 1.3.3 类模板中成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的： 普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 示例： class Person1 &#123; public: void showPerson1() &#123; cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl; &#125; &#125;; class Person2 &#123; public: void showPerson2() &#123; cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl; &#125; &#125;; template&lt;class T&gt; class MyClass &#123; public: T obj; //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成 void fun1() &#123; obj.showPerson1(); &#125; void fun2() &#123; obj.showPerson2(); &#125; &#125;; void test01() &#123; MyClass&lt;Person1&gt; m; m.fun1(); //m.fun2();//编译会出错，说明函数调用才会去创建成员函数 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建 1.3.4 类模板对象做函数参数学习目标： 类模板实例化出的对象，向函数传参的方式 一共有三种传入方式： 指定传入的类型 — 直接显示对象的数据类型 参数模板化 — 将对象中的参数变为模板进行传递 整个类模板化 — 将这个对象类型 模板化进行传递 示例： #include &lt;string&gt; //类模板 template&lt;class NameType, class AgeType = int&gt; class Person &#123; public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125; public: NameType mName; AgeType mAge; &#125;; //1、指定传入的类型 void printPerson1(Person&lt;string, int&gt; &amp;p) &#123; p.showPerson(); &#125; void test01() &#123; Person &lt;string, int &gt;p(&quot;孙悟空&quot;, 100); printPerson1(p); &#125; //2、参数模板化 template &lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt;&amp;p) &#123; p.showPerson(); cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl; &#125; void test02() &#123; Person &lt;string, int &gt;p(&quot;猪八戒&quot;, 90); printPerson2(p); &#125; //3、整个类模板化 template&lt;class T&gt; void printPerson3(T &amp; p) &#123; cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl; p.showPerson(); &#125; void test03() &#123; Person &lt;string, int &gt;p(&quot;唐僧&quot;, 30); printPerson3(p); &#125; int main() &#123; test01(); test02(); test03(); system(&quot;pause&quot;); return 0; &#125; 总结： 通过类模板创建的对象，可以有三种方式向函数中进行传参 使用比较广泛是第一种：指定传入的类型 1.3.5 类模板与继承当类模板碰到继承时，需要注意一下几点： 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板 示例： template&lt;class T&gt; class Base &#123; T m; &#125;; //class Son:public Base //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承 class Son :public Base&lt;int&gt; //必须指定一个类型 &#123; &#125;; void test01() &#123; Son c; &#125; //类模板继承类模板 ,可以用T2指定父类中的T类型 template&lt;class T1, class T2&gt; class Son2 :public Base&lt;T2&gt; &#123; public: Son2() &#123; cout &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; typeid(T2).name() &lt;&lt; endl; &#125; &#125;; void test02() &#123; Son2&lt;int, char&gt; child1; &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：如果父类是类模板，子类需要指定出父类中T的数据类型 1.3.6 类模板成员函数类外实现学习目标：能够掌握类模板中的成员函数类外实现 示例： #include &lt;string&gt; //类模板中成员函数类外实现 template&lt;class T1, class T2&gt; class Person &#123; public: //成员函数类内声明 Person(T1 name, T2 age); void showPerson(); public: T1 m_Name; T2 m_Age; &#125;; //构造函数 类外实现 template&lt;class T1, class T2&gt; Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; //成员函数 类外实现 template&lt;class T1, class T2&gt; void Person&lt;T1, T2&gt;::showPerson() &#123; cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; void test01() &#123; Person&lt;string, int&gt; p(&quot;Tom&quot;, 20); p.showPerson(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：类模板中成员函数类外实现时，需要加上模板参数列表 1.3.7 类模板分文件编写学习目标： 掌握类模板成员函数分文件编写产生的问题以及解决方式 问题： 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到 解决： 解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 示例： person.hpp中代码： #pragma once #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; template&lt;class T1, class T2&gt; class Person &#123; public: Person(T1 name, T2 age); void showPerson(); public: T1 m_Name; T2 m_Age; &#125;; //构造函数 类外实现 template&lt;class T1, class T2&gt; Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; //成员函数 类外实现 template&lt;class T1, class T2&gt; void Person&lt;T1, T2&gt;::showPerson() &#123; cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; 类模板分文件编写.cpp中代码 #include&lt;iostream&gt; using namespace std; //#include &quot;person.h&quot; #include &quot;person.cpp&quot; //解决方式1，包含cpp源文件 //解决方式2，将声明和实现写到一起，文件后缀名改为.hpp #include &quot;person.hpp&quot; void test01() &#123; Person&lt;string, int&gt; p(&quot;Tom&quot;, 10); p.showPerson(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp 1.3.8 类模板与友元学习目标： 掌握类模板配合友元函数的类内和类外实现 全局函数类内实现 - 直接在类内声明友元即可 全局函数类外实现 - 需要提前让编译器知道全局函数的存在 示例： #include &lt;string&gt; //2、全局函数配合友元 类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元 template&lt;class T1, class T2&gt; class Person; //如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到 //template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p) &#123; cout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl; &#125; template&lt;class T1, class T2&gt; class Person &#123; //1、全局函数配合友元 类内实现 friend void printPerson(Person&lt;T1, T2&gt; &amp; p) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl; &#125; //全局函数配合友元 类外实现 friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p); public: Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; private: T1 m_Name; T2 m_Age; &#125;; //1、全局函数在类内实现 void test01() &#123; Person &lt;string, int &gt;p(&quot;Tom&quot;, 20); printPerson(p); &#125; //2、全局函数在类外实现 void test02() &#123; Person &lt;string, int &gt;p(&quot;Jerry&quot;, 30); printPerson2(p); &#125; int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别 1.3.9 类模板案例案例描述: 实现一个通用的数组类，要求如下： 可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量 示例： myArray.hpp中代码 #pragma once #include &lt;iostream&gt; using namespace std; template&lt;class T&gt; class MyArray &#123; public: //构造函数 MyArray(int capacity) &#123; this-&gt;m_Capacity = capacity; this-&gt;m_Size = 0; pAddress = new T[this-&gt;m_Capacity]; &#125; //拷贝构造 MyArray(const MyArray &amp; arr) &#123; this-&gt;m_Capacity = arr.m_Capacity; this-&gt;m_Size = arr.m_Size; this-&gt;pAddress = new T[this-&gt;m_Capacity]; for (int i = 0; i &lt; this-&gt;m_Size; i++) &#123; //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值， // 普通类型可以直接= 但是指针类型需要深拷贝 this-&gt;pAddress[i] = arr.pAddress[i]; &#125; &#125; //重载= 操作符 防止浅拷贝问题 MyArray&amp; operator=(const MyArray&amp; myarray) &#123; if (this-&gt;pAddress != NULL) &#123; delete[] this-&gt;pAddress; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; &#125; this-&gt;m_Capacity = myarray.m_Capacity; this-&gt;m_Size = myarray.m_Size; this-&gt;pAddress = new T[this-&gt;m_Capacity]; for (int i = 0; i &lt; this-&gt;m_Size; i++) &#123; this-&gt;pAddress[i] = myarray[i]; &#125; return *this; &#125; //重载[] 操作符 arr[0] T&amp; operator [](int index) &#123; return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理 &#125; //尾插法 void Push_back(const T &amp; val) &#123; if (this-&gt;m_Capacity == this-&gt;m_Size) &#123; return; &#125; this-&gt;pAddress[this-&gt;m_Size] = val; this-&gt;m_Size++; &#125; //尾删法 void Pop_back() &#123; if (this-&gt;m_Size == 0) &#123; return; &#125; this-&gt;m_Size--; &#125; //获取数组容量 int getCapacity() &#123; return this-&gt;m_Capacity; &#125; //获取数组大小 int getSize() &#123; return this-&gt;m_Size; &#125; //析构 ~MyArray() &#123; if (this-&gt;pAddress != NULL) &#123; delete[] this-&gt;pAddress; this-&gt;pAddress = NULL; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; &#125; &#125; private: T * pAddress; //指向一个堆空间，这个空间存储真正的数据 int m_Capacity; //容量 int m_Size; // 大小 &#125;; 类模板案例—数组类封装.cpp中 #include &quot;myArray.hpp&quot; #include &lt;string&gt; void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //测试内置数据类型 void test01() &#123; MyArray&lt;int&gt; array1(10); for (int i = 0; i &lt; 10; i++) &#123; array1.Push_back(i); &#125; cout &lt;&lt; &quot;array1打印输出：&quot; &lt;&lt; endl; printIntArray(array1); cout &lt;&lt; &quot;array1的大小：&quot; &lt;&lt; array1.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;array1的容量：&quot; &lt;&lt; array1.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; MyArray&lt;int&gt; array2(array1); array2.Pop_back(); cout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl; printIntArray(array2); cout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl; &#125; //测试自定义数据类型 class Person &#123; public: Person() &#123;&#125; Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; public: string m_Name; int m_Age; &#125;; void printPersonArray(MyArray&lt;Person&gt;&amp; personArr) &#123; for (int i = 0; i &lt; personArr.getSize(); i++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; personArr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; personArr[i].m_Age &lt;&lt; endl; &#125; &#125; void test02() &#123; //创建数组 MyArray&lt;Person&gt; pArray(10); Person p1(&quot;孙悟空&quot;, 30); Person p2(&quot;韩信&quot;, 20); Person p3(&quot;妲己&quot;, 18); Person p4(&quot;王昭君&quot;, 15); Person p5(&quot;赵云&quot;, 24); //插入数据 pArray.Push_back(p1); pArray.Push_back(p2); pArray.Push_back(p3); pArray.Push_back(p4); pArray.Push_back(p5); printPersonArray(pArray); cout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl; &#125; int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结： 能够利用所学知识点实现通用的数组 2 STL初识2.1 STL的诞生 长久以来，软件界一直希望建立一种可重复利用的东西 C++的面向对象和泛型编程思想，目的就是复用性的提升 大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作 为了建立数据结构和算法的一套标准,诞生了STL 2.2 STL基本概念 STL(Standard Template Library,标准模板库) STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator) 容器和算法之间通过迭代器进行无缝连接。 STL 几乎所有的代码都采用了模板类或者模板函数 2.3 STL六大组件STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。 算法：各种常用的算法，如sort、find、copy、for_each等 迭代器：扮演了容器与算法之间的胶合剂。 仿函数：行为类似函数，可作为算法的某种策略。 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。 2.4 STL中容器、算法、迭代器容器：置物之所也 STL容器就是将运用最广泛的一些数据结构实现出来 常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等 这些容器分为序列式容器和关联式容器两种: ​ 序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。​ 关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系 算法：问题之解法也 有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms) 算法分为:质变算法和非质变算法。 质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等 迭代器：容器和算法之间粘合剂 提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。 每个容器都有自己专属的迭代器 迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针 迭代器种类： 种类 功能 支持运算 输入迭代器 对数据的只读访问 只读，支持++、&#x3D;&#x3D;、！&#x3D; 输出迭代器 对数据的只写访问 只写，支持++ 前向迭代器 读写操作，并能向前推进迭代器 读写，支持++、&#x3D;&#x3D;、！&#x3D; 双向迭代器 读写操作，并能向前和向后操作 读写，支持++、–， 随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D; 常用的容器中迭代器种类为双向迭代器，和随机访问迭代器 2.5 容器算法迭代器初识了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力 STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器 2.5.1 vector存放内置数据类型容器： vector 算法： for_each 迭代器： vector&lt;int&gt;::iterator 示例： #include &lt;vector&gt; #include &lt;algorithm&gt; void MyPrint(int val) &#123; cout &lt;&lt; val &lt;&lt; endl; &#125; void test01() &#123; //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型 vector&lt;int&gt; v; //向容器中放数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素 //v.begin()返回迭代器，这个迭代器指向容器中第一个数据 //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置 //vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型 vector&lt;int&gt;::iterator pBegin = v.begin(); vector&lt;int&gt;::iterator pEnd = v.end(); //第一种遍历方式： while (pBegin != pEnd) &#123; cout &lt;&lt; *pBegin &lt;&lt; endl; pBegin++; &#125; //第二种遍历方式： for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; cout &lt;&lt; endl; //第三种遍历方式： //使用STL提供标准遍历算法 头文件 algorithm for_each(v.begin(), v.end(), MyPrint); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 2.5.2 Vector存放自定义数据类型学习目标：vector中存放自定义数据类型，并打印输出 示例： #include &lt;vector&gt; #include &lt;string&gt; //自定义数据类型 class Person &#123; public: Person(string name, int age) &#123; mName = name; mAge = age; &#125; public: string mName; int mAge; &#125;; //存放对象 void test01() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); Person p5(&quot;eee&quot;, 50); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl; &#125; &#125; //放对象指针 void test02() &#123; vector&lt;Person*&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); Person p5(&quot;eee&quot;, 50); v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); v.push_back(&amp;p4); v.push_back(&amp;p5); for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; Person * p = (*it); cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 2.5.3 Vector容器嵌套容器学习目标：容器中嵌套容器，我们将所有数据进行遍历输出 示例： #include &lt;vector&gt; //容器嵌套容器 void test01() &#123; vector&lt; vector&lt;int&gt; &gt; v; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; v3; vector&lt;int&gt; v4; for (int i = 0; i &lt; 4; i++) &#123; v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); &#125; //将容器元素插入到vector v中 v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123; cout &lt;&lt; *vit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 3 STL- 常用容器3.1 string容器3.1.1 string基本概念本质： string是C++风格的字符串，而string本质上是一个类 string和char * 区别： char * 是一个指针 string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。 特点： string 类内部封装了很多成员方法 例如：查找find，拷贝copy，删除delete 替换replace，插入insert string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责 3.1.2 string构造函数构造函数原型： string(); &#x2F;&#x2F;创建一个空的字符串 例如: string str; string(const char* s); &#x2F;&#x2F;使用字符串s初始化 string(const string&amp; str); &#x2F;&#x2F;使用一个string对象初始化另一个string对象 string(int n, char c); &#x2F;&#x2F;使用n个字符c初始化 示例： #include &lt;string&gt; //string构造 void test01() &#123; string s1; //创建空字符串，调用无参构造函数 cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; s1 &lt;&lt; endl; const char* str = &quot;hello world&quot;; string s2(str); //把c_string转换成了string cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl; string s3(s2); //调用拷贝构造函数 cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl; string s4(10, &#39;a&#39;); cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：string的多种构造方式没有可比性，灵活使用即可 3.1.3 string赋值操作功能描述： 给string字符串进行赋值 赋值的函数原型： string&amp; operator=(const char* s); &#x2F;&#x2F;char*类型字符串 赋值给当前的字符串 string&amp; operator=(const string &amp;s); &#x2F;&#x2F;把字符串s赋给当前的字符串 string&amp; operator=(char c); &#x2F;&#x2F;字符赋值给当前的字符串 string&amp; assign(const char *s); &#x2F;&#x2F;把字符串s赋给当前的字符串 string&amp; assign(const char *s, int n); &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串 string&amp; assign(const string &amp;s); &#x2F;&#x2F;把字符串s赋给当前字符串 string&amp; assign(int n, char c); &#x2F;&#x2F;用n个字符c赋给当前字符串 示例： //赋值 void test01() &#123; string str1; str1 = &quot;hello world&quot;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; string str2; str2 = str1; cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl; string str3; str3 = &#39;a&#39;; cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl; string str4; str4.assign(&quot;hello c++&quot;); cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl; string str5; str5.assign(&quot;hello c++&quot;,5); cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl; string str6; str6.assign(str5); cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl; string str7; str7.assign(5, &#39;x&#39;); cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： ​ string的赋值方式很多，operator= 这种方式是比较实用的 3.1.4 string字符串拼接功能描述： 实现在字符串末尾拼接字符串 函数原型： string&amp; operator+=(const char* str); &#x2F;&#x2F;重载+&#x3D;操作符 string&amp; operator+=(const char c); &#x2F;&#x2F;重载+&#x3D;操作符 string&amp; operator+=(const string&amp; str); &#x2F;&#x2F;重载+&#x3D;操作符 string&amp; append(const char *s); &#x2F;&#x2F;把字符串s连接到当前字符串结尾 string&amp; append(const char *s, int n); &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾 string&amp; append(const string &amp;s); &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str) string&amp; append(const string &amp;s, int pos, int n);&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾 示例： //字符串拼接 void test01() &#123; string str1 = &quot;我&quot;; str1 += &quot;爱玩游戏&quot;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; str1 += &#39;:&#39;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; string str2 = &quot;LOL DNF&quot;; str1 += str2; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; string str3 = &quot;I&quot;; str3.append(&quot; love &quot;); str3.append(&quot;game abcde&quot;, 4); //str3.append(str2); str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾 cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：字符串拼接的重载版本很多，初学阶段记住几种即可 3.1.5 string查找和替换功能描述： 查找：查找指定字符串是否存在 替换：在指定的位置替换字符串 函数原型： int find(const string&amp; str, int pos = 0) const; &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; &#x2F;&#x2F;查找字符c第一次出现位置 int rfind(const string&amp; str, int pos = npos) const; &#x2F;&#x2F;查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const; &#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const; &#x2F;&#x2F;从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; &#x2F;&#x2F;查找字符c最后一次出现位置 string&amp; replace(int pos, int n, const string&amp; str); &#x2F;&#x2F;替换从pos开始n个字符为字符串str string&amp; replace(int pos, int n,const char* s); &#x2F;&#x2F;替换从pos开始的n个字符为字符串s 示例： //查找和替换 void test01() &#123; //查找 string str1 = &quot;abcdefgde&quot;; int pos = str1.find(&quot;de&quot;); if (pos == -1) &#123; cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl; &#125; pos = str1.rfind(&quot;de&quot;); cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl; &#125; void test02() &#123; //替换 string str1 = &quot;abcdefgde&quot;; str1.replace(1, 3, &quot;1111&quot;); cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; &#125; int main() &#123; //test01(); //test02(); system(&quot;pause&quot;); return 0; &#125; 总结： find查找是从左往后，rfind从右往左 find找到字符串后返回查找的第一个字符位置，找不到返回-1 replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串 3.1.6 string字符串比较功能描述： 字符串之间的比较 比较方式： 字符串比较是按字符的ASCII码进行对比 &#x3D; 返回 0 &gt; 返回 1 &lt; 返回 -1 函数原型： int compare(const string &amp;s) const; &#x2F;&#x2F;与字符串s比较 int compare(const char *s) const; &#x2F;&#x2F;与字符串s比较 示例： //字符串比较 void test01() &#123; string s1 = &quot;hello&quot;; string s2 = &quot;aello&quot;; int ret = s1.compare(s2); if (ret == 0) &#123; cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl; &#125; else if (ret &gt; 0) &#123; cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大 3.1.7 string字符存取string中单个字符存取方式有两种 char&amp; operator[](int n); &#x2F;&#x2F;通过[]方式取字符 char&amp; at(int n); &#x2F;&#x2F;通过at方法获取字符 示例： void test01() &#123; string str = &quot;hello world&quot;; for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //字符修改 str[0] = &#39;x&#39;; str.at(1) = &#39;x&#39;; cout &lt;&lt; str &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at 3.1.8 string插入和删除功能描述： 对string字符串进行插入和删除字符操作 函数原型： string&amp; insert(int pos, const char* s); &#x2F;&#x2F;插入字符串 string&amp; insert(int pos, const string&amp; str); &#x2F;&#x2F;插入字符串 string&amp; insert(int pos, int n, char c); &#x2F;&#x2F;在指定位置插入n个字符c string&amp; erase(int pos, int n = npos); &#x2F;&#x2F;删除从Pos开始的n个字符 示例： //字符串插入和删除 void test01() &#123; string str = &quot;hello&quot;; str.insert(1, &quot;111&quot;); cout &lt;&lt; str &lt;&lt; endl; str.erase(1, 3); //从1号位置开始3个字符 cout &lt;&lt; str &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：插入和删除的起始下标都是从0开始 3.1.9 string子串功能描述： 从字符串中获取想要的子串 函数原型： string substr(int pos = 0, int n = npos) const; &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串 示例： //子串 void test01() &#123; string str = &quot;abcdefg&quot;; string subStr = str.substr(1, 3); cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl; string email = &quot;hello@sina.com&quot;; int pos = email.find(&quot;@&quot;); string username = email.substr(0, pos); cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息 3.2 vector容器3.2.1 vector基本概念功能： vector数据结构和数组非常相似，也称为单端数组 vector与普通数组区别： 不同之处在于数组是静态空间，而vector可以动态扩展 动态扩展： 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间 vector容器的迭代器是支持随机访问的迭代器 3.2.2 vector构造函数功能描述： 创建vector容器 函数原型： vector&lt;T&gt; v; &#x2F;&#x2F;采用模板实现类实现，默认构造函数 vector(v.begin(), v.end()); &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。 vector(const vector &amp;vec); &#x2F;&#x2F;拷贝构造函数。 示例： #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; void test01() &#123; vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt; v2(v1.begin(), v1.end()); printVector(v2); vector&lt;int&gt; v3(10, 100); printVector(v3); vector&lt;int&gt; v4(v3); printVector(v4); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：vector的多种构造方式没有可比性，灵活使用即可 3.2.3 vector赋值操作功能描述： 给vector容器进行赋值 函数原型： vector&amp; operator=(const vector &amp;vec);&#x2F;&#x2F;重载等号操作符 assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。 示例： #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //赋值操作 void test01() &#123; vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt;v2; v2 = v1; printVector(v2); vector&lt;int&gt;v3; v3.assign(v1.begin(), v1.end()); printVector(v3); vector&lt;int&gt;v4; v4.assign(10, 100); printVector(v4); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： vector赋值方式比较简单，使用operator&#x3D;，或者assign都可以 3.2.4 vector容量和大小功能描述： 对vector容器的容量和大小操作 函数原型： empty(); &#x2F;&#x2F;判断容器是否为空 capacity(); &#x2F;&#x2F;容器的容量 size(); &#x2F;&#x2F;返回容器中元素的个数 resize(int num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 ​ &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 ​ &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除 示例： #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; void test01() &#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); if (v1.empty()) &#123; cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#125; //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充 v1.resize(15,10); printVector(v1); //resize 重新指定大小 ，若指定的更小，超出部分元素被删除 v1.resize(5); printVector(v1); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 判断是否为空 — empty 返回元素个数 — size 返回容器容量 — capacity 重新指定大小 — resize 3.2.5 vector插入和删除功能描述： 对vector容器进行插入、删除操作 函数原型： push_back(ele); &#x2F;&#x2F;尾部插入元素ele pop_back(); &#x2F;&#x2F;删除最后一个元素 insert(const_iterator pos, ele); &#x2F;&#x2F;迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele erase(const_iterator pos); &#x2F;&#x2F;删除迭代器指向的元素 erase(const_iterator start, const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素 clear(); &#x2F;&#x2F;删除容器中所有元素 示例： #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //插入和删除 void test01() &#123; vector&lt;int&gt; v1; //尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入 v1.insert(v1.begin(), 100); printVector(v1); v1.insert(v1.begin(), 2, 1000); printVector(v1); //删除 v1.erase(v1.begin()); printVector(v1); //清空 v1.erase(v1.begin(), v1.end()); v1.clear(); printVector(v1); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 尾插 — push_back 尾删 — pop_back 插入 — insert (位置迭代器) 删除 — erase （位置迭代器） 清空 — clear 3.2.6 vector数据存取功能描述： 对vector中的数据的存取操作 函数原型： at(int idx); &#x2F;&#x2F;返回索引idx所指的数据 operator[]; &#x2F;&#x2F;返回索引idx所指的数据 front(); &#x2F;&#x2F;返回容器中第一个数据元素 back(); &#x2F;&#x2F;返回容器中最后一个数据元素 示例： #include &lt;vector&gt; void test01() &#123; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl; cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 除了用迭代器获取vector容器中元素，[ ]和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.2.7 vector互换容器功能描述： 实现两个容器内元素进行互换 函数原型： swap(vec); &#x2F;&#x2F; 将vec与本身的元素互换 示例： #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; void test01() &#123; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt;v2; for (int i = 10; i &gt; 0; i--) &#123; v2.push_back(i); &#125; printVector(v2); //互换容器 cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl; v1.swap(v2); printVector(v1); printVector(v2); &#125; void test02() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; v.resize(3); cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; //收缩内存 vector&lt;int&gt;(v).swap(v); //匿名对象 cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：swap可以使两个容器互换，可以达到实用的收缩内存效果 3.2.8 vector预留空间功能描述： 减少vector在动态扩展容量时的扩展次数 函数原型： reserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。 示例： #include &lt;vector&gt; void test01() &#123; vector&lt;int&gt; v; //预留空间 v.reserve(100000); int num = 0; int* p = NULL; for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); if (p != &amp;v[0]) &#123; p = &amp;v[0]; num++; &#125; &#125; cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：如果数据量较大，可以一开始利用reserve预留空间 3.3 deque容器3.3.1 deque容器基本概念功能： 双端数组，可以对头端进行插入删除操作 deque与vector区别： vector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度回比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关 deque内部工作原理: deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据 中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间 deque容器的迭代器也是支持随机访问的 3.3.2 deque构造函数功能描述： deque容器构造 函数原型： deque&lt;T&gt; deqT; &#x2F;&#x2F;默认构造形式 deque(beg, end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。 deque(const deque &amp;deq); &#x2F;&#x2F;拷贝构造函数 示例： #include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //deque构造 void test01() &#123; deque&lt;int&gt; d1; //无参构造函数 for (int i = 0; i &lt; 10; i++) &#123; d1.push_back(i); &#125; printDeque(d1); deque&lt;int&gt; d2(d1.begin(),d1.end()); printDeque(d2); deque&lt;int&gt;d3(10,100); printDeque(d3); deque&lt;int&gt;d4 = d3; printDeque(d4); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：deque容器和vector容器的构造方式几乎一致，灵活使用即可 3.3.3 deque赋值操作功能描述： 给deque容器进行赋值 函数原型： deque&amp; operator=(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符 assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。 示例： #include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //赋值操作 void test01() &#123; deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) &#123; d1.push_back(i); &#125; printDeque(d1); deque&lt;int&gt;d2; d2 = d1; printDeque(d2); deque&lt;int&gt;d3; d3.assign(d1.begin(), d1.end()); printDeque(d3); deque&lt;int&gt;d4; d4.assign(10, 100); printDeque(d4); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：deque赋值操作也与vector相同，需熟练掌握 3.3.4 deque大小操作功能描述： 对deque容器的大小进行操作 函数原型： deque.empty(); &#x2F;&#x2F;判断容器是否为空 deque.size(); &#x2F;&#x2F;返回容器中元素的个数 deque.resize(num); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。 ​ &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。 deque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。 ​ &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。 示例： #include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //大小操作 void test01() &#123; deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) &#123; d1.push_back(i); &#125; printDeque(d1); //判断容器是否为空 if (d1.empty()) &#123; cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl; //统计大小 cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl; &#125; //重新指定大小 d1.resize(15, 1); printDeque(d1); d1.resize(5); printDeque(d1); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： deque没有容量的概念 判断是否为空 — empty 返回元素个数 — size 重新指定个数 — resize 3.3.5 deque 插入和删除功能描述： 向deque容器中插入和删除数据 函数原型： 两端插入操作： push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据 push_front(elem); &#x2F;&#x2F;在容器头部插入一个数据 pop_back(); &#x2F;&#x2F;删除容器最后一个数据 pop_front(); &#x2F;&#x2F;删除容器第一个数据 指定位置操作： insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。 clear(); &#x2F;&#x2F;清空容器的所有数据 erase(beg,end); &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。 示例： #include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //两端操作 void test01() &#123; deque&lt;int&gt; d; //尾插 d.push_back(10); d.push_back(20); //头插 d.push_front(100); d.push_front(200); printDeque(d); //尾删 d.pop_back(); //头删 d.pop_front(); printDeque(d); &#125; //插入 void test02() &#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.insert(d.begin(), 1000); printDeque(d); d.insert(d.begin(), 2,10000); printDeque(d); deque&lt;int&gt;d2; d2.push_back(1); d2.push_back(2); d2.push_back(3); d.insert(d.begin(), d2.begin(), d2.end()); printDeque(d); &#125; //删除 void test03() &#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.erase(d.begin()); printDeque(d); d.erase(d.begin(), d.end()); d.clear(); printDeque(d); &#125; int main() &#123; //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0; &#125; 总结： 插入和删除提供的位置是迭代器！ 尾插 — push_back 尾删 — pop_back 头插 — push_front 头删 — pop_front 3.3.6 deque 数据存取功能描述： 对deque 中的数据的存取操作 函数原型： at(int idx); &#x2F;&#x2F;返回索引idx所指的数据 operator[]; &#x2F;&#x2F;返回索引idx所指的数据 front(); &#x2F;&#x2F;返回容器中第一个数据元素 back(); &#x2F;&#x2F;返回容器中最后一个数据元素 示例： #include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //数据存取 void test01() &#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); for (int i = 0; i &lt; d.size(); i++) &#123; cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; d.size(); i++) &#123; cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl; cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 除了用迭代器获取deque容器中元素，[ ]和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.3.7 deque 排序功能描述： 利用算法实现对deque容器进行排序 算法： sort(iterator beg, iterator end) &#x2F;&#x2F;对beg和end区间内元素进行排序 示例： #include &lt;deque&gt; #include &lt;algorithm&gt; void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; void test01() &#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); sort(d.begin(), d.end()); printDeque(d); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：sort算法非常实用，使用时包含头文件 algorithm即可 3.4 案例-评委打分3.4.1 案例描述有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。 3.4.2 实现步骤 创建五名选手，放到vector中 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中 sort算法对deque容器中分数排序，去除最高和最低分 deque容器遍历一遍，累加总分 获取平均分 示例代码： //选手类 class Person &#123; public: Person(string name, int score) &#123; this-&gt;m_Name = name; this-&gt;m_Score = score; &#125; string m_Name; //姓名 int m_Score; //平均分 &#125;; void createPerson(vector&lt;Person&gt;&amp;v) &#123; string nameSeed = &quot;ABCDE&quot;; for (int i = 0; i &lt; 5; i++) &#123; string name = &quot;选手&quot;; name += nameSeed[i]; int score = 0; Person p(name, score); //将创建的person对象 放入到容器中 v.push_back(p); &#125; &#125; //打分 void setScore(vector&lt;Person&gt;&amp;v) &#123; for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; //将评委的分数 放入到deque容器中 deque&lt;int&gt;d; for (int i = 0; i &lt; 10; i++) &#123; int score = rand() % 41 + 60; // 60 ~ 100 d.push_back(score); &#125; //cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl; //for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) //&#123; // cout &lt;&lt; *dit &lt;&lt; &quot; &quot;; //&#125; //cout &lt;&lt; endl; //排序 sort(d.begin(), d.end()); //去除最高和最低分 d.pop_back(); d.pop_front(); //取平均分 int sum = 0; for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) &#123; sum += *dit; //累加每个评委的分数 &#125; int avg = sum / d.size(); //将平均分 赋值给选手身上 it-&gt;m_Score = avg; &#125; &#125; void showScore(vector&lt;Person&gt;&amp;v) &#123; for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 平均分： &quot; &lt;&lt; it-&gt;m_Score &lt;&lt; endl; &#125; &#125; int main() &#123; //随机数种子 srand((unsigned int)time(NULL)); //1、创建5名选手 vector&lt;Person&gt;v; //存放选手容器 createPerson(v); //测试 //for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) //&#123; // cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl; //&#125; //2、给5名选手打分 setScore(v); //3、显示最后得分 showScore(v); system(&quot;pause&quot;); return 0; &#125; 总结： 选取不同的容器操作数据，可以提升代码的效率 3.5 stack容器3.5.1 stack 基本概念概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口 栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为 栈中进入数据称为 — 入栈 push 栈中弹出数据称为 — 出栈 pop 生活中的栈： 3.5.2 stack 常用接口功能描述：栈容器常用的对外接口 构造函数： stack&lt;T&gt; stk; &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式 stack(const stack &amp;stk); &#x2F;&#x2F;拷贝构造函数 赋值操作： stack&amp; operator=(const stack &amp;stk); &#x2F;&#x2F;重载等号操作符 数据存取： push(elem); &#x2F;&#x2F;向栈顶添加元素 pop(); &#x2F;&#x2F;从栈顶移除第一个元素 top(); &#x2F;&#x2F;返回栈顶元素 大小操作： empty(); &#x2F;&#x2F;判断堆栈是否为空 size(); &#x2F;&#x2F;返回栈的大小 示例： #include &lt;stack&gt; //栈容器常用接口 void test01() &#123; //创建栈容器 栈容器必须符合先进后出 stack&lt;int&gt; s; //向栈中添加元素，叫做 压栈 入栈 s.push(10); s.push(20); s.push(30); while (!s.empty()) &#123; //输出栈顶元素 cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl; //弹出栈顶元素 s.pop(); &#125; cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 入栈 — push 出栈 — pop 返回栈顶 — top 判断栈是否为空 — empty 返回栈大小 — size 3.6 queue 容器3.6.1 queue 基本概念概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口 队列容器允许从一端新增元素，从另一端移除元素 队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为 队列中进数据称为 — 入队 push 队列中出数据称为 — 出队 pop 生活中的队列： 3.6.2 queue 常用接口功能描述：栈容器常用的对外接口 构造函数： queue&lt;T&gt; que; &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式 queue(const queue &amp;que); &#x2F;&#x2F;拷贝构造函数 赋值操作： queue&amp; operator=(const queue &amp;que); &#x2F;&#x2F;重载等号操作符 数据存取： push(elem); &#x2F;&#x2F;往队尾添加元素 pop(); &#x2F;&#x2F;从队头移除第一个元素 back(); &#x2F;&#x2F;返回最后一个元素 front(); &#x2F;&#x2F;返回第一个元素 大小操作： empty(); &#x2F;&#x2F;判断堆栈是否为空 size(); &#x2F;&#x2F;返回栈的大小 示例： #include &lt;queue&gt; #include &lt;string&gt; class Person &#123; public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age; &#125;; void test01() &#123; //创建队列 queue&lt;Person&gt; q; //准备数据 Person p1(&quot;唐僧&quot;, 30); Person p2(&quot;孙悟空&quot;, 1000); Person p3(&quot;猪八戒&quot;, 900); Person p4(&quot;沙僧&quot;, 800); //向队列中添加元素 入队操作 q.push(p1); q.push(p2); q.push(p3); q.push(p4); //队列不提供迭代器，更不支持随机访问 while (!q.empty()) &#123; //输出队头元素 cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl; cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl; cout &lt;&lt; endl; //弹出队头元素 q.pop(); &#125; cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 入队 — push 出队 — pop 返回队头元素 — front 返回队尾元素 — back 判断队是否为空 — empty 返回队列大小 — size 3.7 list容器3.7.1 list基本概念功能：将数据进行链式存储 链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的 链表的组成：链表由一系列结点组成 结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域 STL中的链表是一个双向循环链表 由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器 list的优点： 采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 list的缺点： 链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大 List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。 总结：STL中List和vector是两个最常被使用的容器，各有优缺点 3.7.2 list构造函数功能描述： 创建list容器 函数原型： list&lt;T&gt; lst; &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式： list(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。 list(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数。 示例： #include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; void test01() &#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); list&lt;int&gt;L2(L1.begin(),L1.end()); printList(L2); list&lt;int&gt;L3(L2); printList(L3); list&lt;int&gt;L4(10, 1000); printList(L4); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：list构造方式同其他几个STL常用容器，熟练掌握即可 3.7.3 list 赋值和交换功能描述： 给list容器进行赋值，以及交换list容器 函数原型： assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。 list&amp; operator=(const list &amp;lst); &#x2F;&#x2F;重载等号操作符 swap(lst); &#x2F;&#x2F;将lst与本身的元素互换。 示例： #include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //赋值和交换 void test01() &#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); //赋值 list&lt;int&gt;L2; L2 = L1; printList(L2); list&lt;int&gt;L3; L3.assign(L2.begin(), L2.end()); printList(L3); list&lt;int&gt;L4; L4.assign(10, 100); printList(L4); &#125; //交换 void test02() &#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); list&lt;int&gt;L2; L2.assign(10, 100); cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl; printList(L1); printList(L2); cout &lt;&lt; endl; L1.swap(L2); cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl; printList(L1); printList(L2); &#125; int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：list赋值和交换操作能够灵活运用即可 3.7.4 list 大小操作功能描述： 对list容器的大小进行操作 函数原型： size(); &#x2F;&#x2F;返回容器中元素的个数 empty(); &#x2F;&#x2F;判断容器是否为空 resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 ​ &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。 resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。 示例： #include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //大小操作 void test01() &#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); if (L1.empty()) &#123; cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl; &#125; //重新指定大小 L1.resize(10); printList(L1); L1.resize(2); printList(L1); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 判断是否为空 — empty 返回元素个数 — size 重新指定个数 — resize 3.7.5 list 插入和删除功能描述： 对list容器进行数据的插入和删除 函数原型： push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素 pop_back();&#x2F;&#x2F;删除容器中最后一个元素 push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素 pop_front();&#x2F;&#x2F;从容器开头移除第一个元素 insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。 clear();&#x2F;&#x2F;移除容器的所有数据 erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。 remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。 示例： #include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //插入和删除 void test01() &#123; list&lt;int&gt; L; //尾插 L.push_back(10); L.push_back(20); L.push_back(30); //头插 L.push_front(100); L.push_front(200); L.push_front(300); printList(L); //尾删 L.pop_back(); printList(L); //头删 L.pop_front(); printList(L); //插入 list&lt;int&gt;::iterator it = L.begin(); L.insert(++it, 1000); printList(L); //删除 it = L.begin(); L.erase(++it); printList(L); //移除 L.push_back(10000); L.push_back(10000); L.push_back(10000); printList(L); L.remove(10000); printList(L); //清空 L.clear(); printList(L); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 尾插 — push_back 尾删 — pop_back 头插 — push_front 头删 — pop_front 插入 — insert 删除 — erase 移除 — remove 清空 — clear 3.7.6 list 数据存取功能描述： 对list容器中数据进行存取 函数原型： front(); &#x2F;&#x2F;返回第一个元素。 back(); &#x2F;&#x2F;返回最后一个元素。 示例： #include &lt;list&gt; //数据存取 void test01() &#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据 //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据 cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl; cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl; //list容器的迭代器是双向迭代器，不支持随机访问 list&lt;int&gt;::iterator it = L1.begin(); //it = it + 1;//错误，不可以跳跃访问，即使是+1 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： list容器中不可以通过[]或者at方式访问数据 返回第一个元素 — front 返回最后一个元素 — back 3.7.7 list 反转和排序功能描述： 将容器中的元素反转，以及将容器中的数据进行排序 函数原型： reverse(); &#x2F;&#x2F;反转链表 sort(); &#x2F;&#x2F;链表排序 示例： void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; bool myCompare(int val1 , int val2) &#123; return val1 &gt; val2; &#125; //反转和排序 void test01() &#123; list&lt;int&gt; L; L.push_back(90); L.push_back(30); L.push_back(20); L.push_back(70); printList(L); //反转容器的元素 L.reverse(); printList(L); //排序 L.sort(); //默认的排序规则 从小到大 printList(L); L.sort(myCompare); //指定规则，从大到小 printList(L); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 反转 — reverse 排序 — sort （成员函数） 3.7.8 排序案例案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高 排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序 示例： #include &lt;list&gt; #include &lt;string&gt; class Person &#123; public: Person(string name, int age , int height) &#123; m_Name = name; m_Age = age; m_Height = height; &#125; public: string m_Name; //姓名 int m_Age; //年龄 int m_Height; //身高 &#125;; bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123; if (p1.m_Age == p2.m_Age) &#123; return p1.m_Height &gt; p2.m_Height; &#125; else &#123; return p1.m_Age &lt; p2.m_Age; &#125; &#125; void test01() &#123; list&lt;Person&gt; L; Person p1(&quot;刘备&quot;, 35 , 175); Person p2(&quot;曹操&quot;, 45 , 180); Person p3(&quot;孙权&quot;, 40 , 170); Person p4(&quot;赵云&quot;, 25 , 190); Person p5(&quot;张飞&quot;, 35 , 160); Person p6(&quot;关羽&quot;, 35 , 200); L.push_back(p1); L.push_back(p2); L.push_back(p3); L.push_back(p4); L.push_back(p5); L.push_back(p6); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl; &#125; cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl; L.sort(ComparePerson); //排序 for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序 高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂 3.8 set&#x2F; multiset 容器3.8.1 set基本概念简介： 所有元素都会在插入时自动被排序 本质： set&#x2F;multiset属于关联式容器，底层结构是用二叉树实现。 set和multiset区别： set不允许容器中有重复的元素 multiset允许容器中有重复的元素 3.8.2 set构造和赋值功能描述：创建set容器以及赋值 构造： set&lt;T&gt; st; &#x2F;&#x2F;默认构造函数： set(const set &amp;st); &#x2F;&#x2F;拷贝构造函数 赋值： set&amp; operator=(const set &amp;st); &#x2F;&#x2F;重载等号操作符 示例： #include &lt;set&gt; void printSet(set&lt;int&gt; &amp; s) &#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //构造和赋值 void test01() &#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //拷贝构造 set&lt;int&gt;s2(s1); printSet(s2); //赋值 set&lt;int&gt;s3; s3 = s2; printSet(s3); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： set容器插入数据时用insert set容器插入数据的数据会自动排序 3.8.3 set大小和交换功能描述： 统计set容器大小以及交换set容器 函数原型： size(); &#x2F;&#x2F;返回容器中元素的数目 empty(); &#x2F;&#x2F;判断容器是否为空 swap(st); &#x2F;&#x2F;交换两个集合容器 示例： #include &lt;set&gt; void printSet(set&lt;int&gt; &amp; s) &#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //大小 void test01() &#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); if (s1.empty()) &#123; cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl; &#125; &#125; //交换 void test02() &#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); set&lt;int&gt; s2; s2.insert(100); s2.insert(300); s2.insert(200); s2.insert(400); cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl; printSet(s1); printSet(s2); cout &lt;&lt; endl; cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl; s1.swap(s2); printSet(s1); printSet(s2); &#125; int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结： 统计大小 — size 判断是否为空 — empty 交换容器 — swap 3.8.4 set插入和删除功能描述： set容器进行插入数据和删除数据 函数原型： insert(elem); &#x2F;&#x2F;在容器中插入元素。 clear(); &#x2F;&#x2F;清除所有元素 erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem); &#x2F;&#x2F;删除容器中值为elem的元素。 示例： #include &lt;set&gt; void printSet(set&lt;int&gt; &amp; s) &#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //插入和删除 void test01() &#123; set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //删除 s1.erase(s1.begin()); printSet(s1); s1.erase(30); printSet(s1); //清空 //s1.erase(s1.begin(), s1.end()); s1.clear(); printSet(s1); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 插入 — insert 删除 — erase 清空 — clear 3.8.5 set查找和统计功能描述： 对set容器进行查找数据以及统计数据 函数原型： find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); &#x2F;&#x2F;统计key的元素个数 示例： #include &lt;set&gt; //查找和统计 void test01() &#123; set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); //查找 set&lt;int&gt;::iterator pos = s1.find(30); if (pos != s1.end()) &#123; cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl; &#125; //统计 int num = s1.count(30); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 查找 — find （返回的是迭代器） 统计 — count （对于set，结果为0或者1） 3.8.6 set和multiset区别学习目标： 掌握set和multiset的区别 区别： set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 示例： #include &lt;set&gt; //set和multiset区别 void test01() &#123; set&lt;int&gt; s; pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert(10); if (ret.second) &#123; cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl; &#125; ret = s.insert(10); if (ret.second) &#123; cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl; &#125; //multiset multiset&lt;int&gt; ms; ms.insert(10); ms.insert(10); for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 如果不允许插入重复数据可以利用set 如果需要插入重复数据利用multiset 3.8.7 pair对组创建功能描述： 成对出现的数据，利用对组可以返回两个数据 两种创建方式： pair&lt;type, type&gt; p ( value1, value2 ); pair&lt;type, type&gt; p = make_pair( value1, value2 ); 示例： #include &lt;string&gt; //对组创建 void test01() &#123; pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl; pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 两种方式都可以创建对组，记住一种即可 3.8.8 set容器排序学习目标： set容器默认排序规则为从小到大，掌握如何改变排序规则 主要技术点： 利用仿函数，可以改变排序规则 示例一 set存放内置数据类型 #include &lt;set&gt; class MyCompare &#123; public: bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125; &#125;; void test01() &#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(40); s1.insert(20); s1.insert(30); s1.insert(50); //默认从小到大 for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //指定排序规则 set&lt;int,MyCompare&gt; s2; s2.insert(10); s2.insert(40); s2.insert(20); s2.insert(30); s2.insert(50); for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：利用仿函数可以指定set容器的排序规则 示例二 set存放自定义数据类型 #include &lt;set&gt; #include &lt;string&gt; class Person &#123; public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age; &#125;; class comparePerson &#123; public: bool operator()(const Person&amp; p1, const Person &amp;p2) &#123; //按照年龄进行排序 降序 return p1.m_Age &gt; p2.m_Age; &#125; &#125;; void test01() &#123; set&lt;Person, comparePerson&gt; s; Person p1(&quot;刘备&quot;, 23); Person p2(&quot;关羽&quot;, 27); Person p3(&quot;张飞&quot;, 25); Person p4(&quot;赵云&quot;, 21); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 对于自定义数据类型，set必须指定排序规则才可以插入数据 3.9 map&#x2F; multimap容器3.9.1 map基本概念简介： map中所有元素都是pair pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 本质： map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。 优点： 可以根据key值快速找到value值 map和multimap区别： map不允许容器中有重复key值元素 multimap允许容器中有重复key值元素 3.9.2 map构造和赋值功能描述： 对map容器进行构造和赋值操作 函数原型： 构造： map&lt;T1, T2&gt; mp; &#x2F;&#x2F;map默认构造函数: map(const map &amp;mp); &#x2F;&#x2F;拷贝构造函数 赋值： map&amp; operator=(const map &amp;mp); &#x2F;&#x2F;重载等号操作符 示例： #include &lt;map&gt; void printMap(map&lt;int,int&gt;&amp;m) &#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; void test01() &#123; map&lt;int,int&gt;m; //默认构造 m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); printMap(m); map&lt;int, int&gt;m2(m); //拷贝构造 printMap(m2); map&lt;int, int&gt;m3; m3 = m2; //赋值 printMap(m3); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：map中所有元素都是成对出现，插入数据时候要使用对组 3.9.3 map大小和交换功能描述： 统计map容器大小以及交换map容器 函数原型： size(); &#x2F;&#x2F;返回容器中元素的数目 empty(); &#x2F;&#x2F;判断容器是否为空 swap(st); &#x2F;&#x2F;交换两个集合容器 示例： #include &lt;map&gt; void printMap(map&lt;int,int&gt;&amp;m) &#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; void test01() &#123; map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); if (m.empty()) &#123; cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl; &#125; &#125; //交换 void test02() &#123; map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); map&lt;int, int&gt;m2; m2.insert(pair&lt;int, int&gt;(4, 100)); m2.insert(pair&lt;int, int&gt;(5, 200)); m2.insert(pair&lt;int, int&gt;(6, 300)); cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl; printMap(m); printMap(m2); cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl; m.swap(m2); printMap(m); printMap(m2); &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结： 统计大小 — size 判断是否为空 — empty 交换容器 — swap 3.9.4 map插入和删除功能描述： map容器进行插入数据和删除数据 函数原型： insert(elem); &#x2F;&#x2F;在容器中插入元素。 clear(); &#x2F;&#x2F;清除所有元素 erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(key); &#x2F;&#x2F;删除容器中值为key的元素。 示例： #include &lt;map&gt; void printMap(map&lt;int,int&gt;&amp;m) &#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; void test01() &#123; //插入 map&lt;int, int&gt; m; //第一种插入方式 m.insert(pair&lt;int, int&gt;(1, 10)); //第二种插入方式 m.insert(make_pair(2, 20)); //第三种插入方式 m.insert(map&lt;int, int&gt;::value_type(3, 30)); //第四种插入方式 m[4] = 40; printMap(m); //删除 m.erase(m.begin()); printMap(m); m.erase(3); printMap(m); //清空 m.erase(m.begin(),m.end()); m.clear(); printMap(m); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： map插入方式很多，记住其一即可 插入 — insert 删除 — erase 清空 — clear 3.9.5 map查找和统计功能描述： 对map容器进行查找数据以及统计数据 函数原型： find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); &#x2F;&#x2F;统计key的元素个数 示例： #include &lt;map&gt; //查找和统计 void test01() &#123; map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); //查找 map&lt;int, int&gt;::iterator pos = m.find(3); if (pos != m.end()) &#123; cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl; &#125; //统计 int num = m.count(3); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 查找 — find （返回的是迭代器） 统计 — count （对于map，结果为0或者1） 3.9.6 map容器排序学习目标： map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则 主要技术点: 利用仿函数，可以改变排序规则 示例： #include &lt;map&gt; class MyCompare &#123; public: bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125; &#125;; void test01() &#123; //默认从小到大排序 //利用仿函数实现从大到小排序 map&lt;int, int, MyCompare&gt; m; m.insert(make_pair(1, 10)); m.insert(make_pair(2, 20)); m.insert(make_pair(3, 30)); m.insert(make_pair(4, 40)); m.insert(make_pair(5, 50)); for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 利用仿函数可以指定map容器的排序规则 对于自定义数据类型，map必须要指定排序规则,同set容器 3.10 案例-员工分组3.10.1 案例描述 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给10名员工分配部门和工资 通过multimap进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息 3.10.2 实现步骤 创建10名员工，放到vector中 遍历vector容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中 分部门显示员工信息 案例代码： #include&lt;iostream&gt; using namespace std; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;map&gt; #include &lt;ctime&gt; /* - 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作 - 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 - 随机给10名员工分配部门和工资 - 通过multimap进行信息的插入 key(部门编号) value(员工) - 分部门显示员工信息 */ #define CEHUA 0 #define MEISHU 1 #define YANFA 2 class Worker &#123; public: string m_Name; int m_Salary; &#125;; void createWorker(vector&lt;Worker&gt;&amp;v) &#123; string nameSeed = &quot;ABCDEFGHIJ&quot;; for (int i = 0; i &lt; 10; i++) &#123; Worker worker; worker.m_Name = &quot;员工&quot;; worker.m_Name += nameSeed[i]; worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999 //将员工放入到容器中 v.push_back(worker); &#125; &#125; //员工分组 void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m) &#123; for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; //产生随机部门编号 int deptId = rand() % 3; // 0 1 2 //将员工插入到分组中 //key部门编号，value具体员工 m.insert(make_pair(deptId, *it)); &#125; &#125; void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m) &#123; // 0 A B C 1 D E 2 F G ... cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl; multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA); int count = m.count(CEHUA); // 统计具体人数 int index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; &#125; cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl; pos = m.find(MEISHU); count = m.count(MEISHU); // 统计具体人数 index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; &#125; cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl; pos = m.find(YANFA); count = m.count(YANFA); // 统计具体人数 index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; &#125; &#125; int main() &#123; srand((unsigned int)time(NULL)); //1、创建员工 vector&lt;Worker&gt;vWorker; createWorker(vWorker); //2、员工分组 multimap&lt;int, Worker&gt;mWorker; setGroup(vWorker, mWorker); //3、分组显示员工 showWorkerByGourp(mWorker); ////测试 //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++) //&#123; // cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl; //&#125; system(&quot;pause&quot;); return 0; &#125; 总结： 当数据以键值对形式存在，可以考虑用map 或 multimap 4 STL- 函数对象4.1 函数对象4.1.1 函数对象概念概念： 重载函数调用操作符的类，其对象常称为函数对象 函数对象使用重载的()时，行为类似函数调用，也叫仿函数 本质： 函数对象(仿函数)是一个类，不是一个函数 4.1.2 函数对象使用特点： 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 函数对象超出普通函数的概念，函数对象可以有自己的状态 函数对象可以作为参数传递 示例: #include &lt;string&gt; //1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 class MyAdd &#123; public : int operator()(int v1,int v2) &#123; return v1 + v2; &#125; &#125;; void test01() &#123; MyAdd myAdd; cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl; &#125; //2、函数对象可以有自己的状态 class MyPrint &#123; public: MyPrint() &#123; count = 0; &#125; void operator()(string test) &#123; cout &lt;&lt; test &lt;&lt; endl; count++; //统计使用次数 &#125; int count; //内部自己的状态 &#125;; void test02() &#123; MyPrint myPrint; myPrint(&quot;hello world&quot;); myPrint(&quot;hello world&quot;); myPrint(&quot;hello world&quot;); cout &lt;&lt; &quot;myPrint调用次数为： &quot; &lt;&lt; myPrint.count &lt;&lt; endl; &#125; //3、函数对象可以作为参数传递 void doPrint(MyPrint &amp;mp , string test) &#123; mp(test); &#125; void test03() &#123; MyPrint myPrint; doPrint(myPrint, &quot;Hello C++&quot;); &#125; int main() &#123; //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0; &#125; 总结： 仿函数写法非常灵活，可以作为参数进行传递。 4.2 谓词4.2.1 谓词概念概念： 返回bool类型的仿函数称为谓词 如果operator()接受一个参数，那么叫做一元谓词 如果operator()接受两个参数，那么叫做二元谓词 4.2.2 一元谓词示例： #include &lt;vector&gt; #include &lt;algorithm&gt; //1.一元谓词 struct GreaterFive&#123; bool operator()(int val) &#123; return val &gt; 5; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) &#123; cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：参数只有一个的谓词，称为一元谓词 4.2.3 二元谓词示例： #include &lt;vector&gt; #include &lt;algorithm&gt; //二元谓词 class MyCompare &#123; public: bool operator()(int num1, int num2) &#123; return num1 &gt; num2; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.push_back(50); //默认从小到大 sort(v.begin(), v.end()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：参数只有两个的谓词，称为二元谓词 4.3 内建函数对象4.3.1 内建函数对象意义概念： STL内建了一些函数对象 分类: 算术仿函数 关系仿函数 逻辑仿函数 用法： 这些仿函数所产生的对象，用法和一般函数完全相同 使用内建函数对象，需要引入头文件 #include&lt;functional&gt; 4.3.2 算术仿函数功能描述： 实现四则运算 其中negate是一元运算，其他都是二元运算 仿函数原型： template&lt;class T&gt; T plus&lt;T&gt; &#x2F;&#x2F;加法仿函数 template&lt;class T&gt; T minus&lt;T&gt; &#x2F;&#x2F;减法仿函数 template&lt;class T&gt; T multiplies&lt;T&gt; &#x2F;&#x2F;乘法仿函数 template&lt;class T&gt; T divides&lt;T&gt; &#x2F;&#x2F;除法仿函数 template&lt;class T&gt; T modulus&lt;T&gt; &#x2F;&#x2F;取模仿函数 template&lt;class T&gt; T negate&lt;T&gt; &#x2F;&#x2F;取反仿函数 示例： #include &lt;functional&gt; //negate void test01() &#123; negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl; &#125; //plus void test02() &#123; plus&lt;int&gt; p; cout &lt;&lt; p(10, 20) &lt;&lt; endl; &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：使用内建函数对象时，需要引入头文件 #include &lt;functional&gt; 4.3.3 关系仿函数功能描述： 实现关系对比 仿函数原型： template&lt;class T&gt; bool equal_to&lt;T&gt; &#x2F;&#x2F;等于 template&lt;class T&gt; bool not_equal_to&lt;T&gt; &#x2F;&#x2F;不等于 template&lt;class T&gt; bool greater&lt;T&gt; &#x2F;&#x2F;大于 template&lt;class T&gt; bool greater_equal&lt;T&gt; &#x2F;&#x2F;大于等于 template&lt;class T&gt; bool less&lt;T&gt; &#x2F;&#x2F;小于 template&lt;class T&gt; bool less_equal&lt;T&gt; &#x2F;&#x2F;小于等于 示例： #include &lt;functional&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; class MyCompare &#123; public: bool operator()(int v1,int v2) &#123; return v1 &gt; v2; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(40); v.push_back(20); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //自己实现仿函数 //sort(v.begin(), v.end(), MyCompare()); //STL内建仿函数 大于仿函数 sort(v.begin(), v.end(), greater&lt;int&gt;()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：关系仿函数中最常用的就是greater&lt;&gt;大于 4.3.4 逻辑仿函数功能描述： 实现逻辑运算 函数原型： template&lt;class T&gt; bool logical_and&lt;T&gt; &#x2F;&#x2F;逻辑与 template&lt;class T&gt; bool logical_or&lt;T&gt; &#x2F;&#x2F;逻辑或 template&lt;class T&gt; bool logical_not&lt;T&gt; &#x2F;&#x2F;逻辑非 示例： #include &lt;vector&gt; #include &lt;functional&gt; #include &lt;algorithm&gt; void test01() &#123; vector&lt;bool&gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //逻辑非 将v容器搬运到v2中，并执行逻辑非运算 vector&lt;bool&gt; v2; v2.resize(v.size()); transform(v.begin(), v.end(), v2.begin(), logical_not&lt;bool&gt;()); for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：逻辑仿函数实际应用较少，了解即可 5 STL- 常用算法概述: 算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。 &lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等 &lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数 &lt;functional&gt;定义了一些模板类,用以声明函数对象。 5.1 常用遍历算法学习目标： 掌握常用的遍历算法 算法简介： for_each &#x2F;&#x2F;遍历容器 transform &#x2F;&#x2F;搬运容器到另一个容器中 5.1.1 for_each功能描述： 实现遍历容器 函数原型： for_each(iterator beg, iterator end, _func); &#x2F;&#x2F; 遍历算法 遍历容器元素 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; _func 函数或者函数对象 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; //普通函数 void print01(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; //函数对象 class print02 &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; //for_each算法基本用法 void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //遍历算法 for_each(v.begin(), v.end(), print01); cout &lt;&lt; endl; for_each(v.begin(), v.end(), print02()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握 5.1.2 transform功能描述： 搬运容器到另一个容器中 函数原型： transform(iterator beg1, iterator end1, iterator beg2, _func); &#x2F;&#x2F;beg1 源容器开始迭代器 &#x2F;&#x2F;end1 源容器结束迭代器 &#x2F;&#x2F;beg2 目标容器开始迭代器 &#x2F;&#x2F;_func 函数或者函数对象 示例： #include&lt;vector&gt; #include&lt;algorithm&gt; //常用遍历算法 搬运 transform class TransForm &#123; public: int operator()(int val) &#123; return val; &#125; &#125;; class MyPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;vTarget; //目标容器 vTarget.resize(v.size()); // 目标容器需要提前开辟空间 transform(v.begin(), v.end(), vTarget.begin(), TransForm()); for_each(vTarget.begin(), vTarget.end(), MyPrint()); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运 5.2 常用查找算法学习目标： 掌握常用的查找算法 算法简介： find &#x2F;&#x2F;查找元素 find_if &#x2F;&#x2F;按条件查找元素 adjacent_find &#x2F;&#x2F;查找相邻重复元素 binary_search &#x2F;&#x2F;二分查找法 count &#x2F;&#x2F;统计元素个数 count_if &#x2F;&#x2F;按条件统计元素个数 5.2.1 find功能描述： 查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end() 函数原型： find(iterator beg, iterator end, value); &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; value 查找的元素 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;string&gt; void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; //查找容器中是否有 5 这个元素 vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl; &#125; &#125; class Person &#123; public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; //重载== bool operator==(const Person&amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false; &#125; public: string m_Name; int m_Age; &#125;; void test02() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125; &#125; 总结： 利用find可以在容器中找指定的元素，返回值是迭代器 5.2.2 find_if功能描述： 按条件查找元素 函数原型： find_if(iterator beg, iterator end, _Pred); &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数） 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;string&gt; //内置数据类型 class GreaterFive &#123; public: bool operator()(int val) &#123; return val &gt; 5; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl; &#125; &#125; //自定义数据类型 class Person &#123; public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; public: string m_Name; int m_Age; &#125;; class Greater20 &#123; public: bool operator()(Person &amp;p) &#123; return p.m_Age &gt; 20; &#125; &#125;; void test02() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20()); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125; &#125; int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略 5.2.3 adjacent_find功能描述： 查找相邻重复元素 函数原型： adjacent_find(iterator beg, iterator end); &#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; void test01() &#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(5); v.push_back(2); v.push_back(4); v.push_back(4); v.push_back(3); //查找相邻重复元素 vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); if (it == v.end()) &#123; cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl; &#125; &#125; 总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法 5.2.4 binary_search功能描述： 查找指定元素是否存在 函数原型： bool binary_search(iterator beg, iterator end, value); &#x2F;&#x2F; 查找指定的元素，查到 返回true 否则false &#x2F;&#x2F; 注意: 在无序序列中不可用 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; value 查找的元素 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; void test01() &#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //二分查找 bool ret = binary_search(v.begin(), v.end(),2); if (ret) &#123; cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列 5.2.5 count功能描述： 统计元素个数 函数原型： count(iterator beg, iterator end, value); &#x2F;&#x2F; 统计元素出现次数 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; value 统计的元素 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; //内置数据类型 void test01() &#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count(v.begin(), v.end(), 4); cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl; &#125; //自定义数据类型 class Person &#123; public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; bool operator==(const Person &amp; p) &#123; if (this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; string m_Name; int m_Age; &#125;; void test02() &#123; vector&lt;Person&gt; v; Person p1(&quot;刘备&quot;, 35); Person p2(&quot;关羽&quot;, 35); Person p3(&quot;张飞&quot;, 35); Person p4(&quot;赵云&quot;, 30); Person p5(&quot;曹操&quot;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); Person p(&quot;诸葛亮&quot;,35); int num = count(v.begin(), v.end(), p); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; &#125; int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结： 统计自定义数据类型时候，需要配合重载 operator== 5.2.6 count_if功能描述： 按条件统计元素个数 函数原型： count_if(iterator beg, iterator end, _Pred); &#x2F;&#x2F; 按条件统计元素出现次数 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; _Pred 谓词 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class Greater4 &#123; public: bool operator()(int val) &#123; return val &gt;= 4; &#125; &#125;; //内置数据类型 void test01() &#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count_if(v.begin(), v.end(), Greater4()); cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl; &#125; //自定义数据类型 class Person &#123; public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age; &#125;; class AgeLess35 &#123; public: bool operator()(const Person &amp;p) &#123; return p.m_Age &lt; 35; &#125; &#125;; void test02() &#123; vector&lt;Person&gt; v; Person p1(&quot;刘备&quot;, 35); Person p2(&quot;关羽&quot;, 35); Person p3(&quot;张飞&quot;, 35); Person p4(&quot;赵云&quot;, 30); Person p5(&quot;曹操&quot;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); int num = count_if(v.begin(), v.end(), AgeLess35()); cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl; &#125; int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：按值统计用count，按条件统计用count_if 5.3 常用排序算法学习目标： 掌握常用的排序算法 算法简介： sort &#x2F;&#x2F;对容器内元素进行排序 random_shuffle &#x2F;&#x2F;洗牌 指定范围内的元素随机调整次序 merge &#x2F;&#x2F; 容器元素合并，并存储到另一容器中 reverse &#x2F;&#x2F; 反转指定范围的元素 5.3.1 sort功能描述： 对容器内元素进行排序 函数原型： sort(iterator beg, iterator end, _Pred); &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; _Pred 谓词 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; void myPrint(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; void test01() &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //sort默认从小到大排序 sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; //从大到小排序 sort(v.begin(), v.end(), greater&lt;int&gt;()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：sort属于开发中最常用的算法之一，需熟练掌握 5.3.2 random_shuffle功能描述： 洗牌 指定范围内的元素随机调整次序 函数原型： random_shuffle(iterator beg, iterator end); &#x2F;&#x2F; 指定范围内的元素随机调整次序 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;ctime&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; srand((unsigned int)time(NULL)); vector&lt;int&gt; v; for(int i = 0 ; i &lt; 10;i++) &#123; v.push_back(i); &#125; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //打乱顺序 random_shuffle(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子 5.3.3 merge功能描述： 两个容器元素合并，并存储到另一容器中 函数原型： merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); &#x2F;&#x2F; 容器元素合并，并存储到另一容器中 &#x2F;&#x2F; 注意: 两个容器必须是有序的 &#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10 ; i++) &#123; v1.push_back(i); v2.push_back(i + 1); &#125; vector&lt;int&gt; vtarget; //目标容器需要提前开辟空间 vtarget.resize(v1.size() + v2.size()); //合并 需要两个有序序列 merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin()); for_each(vtarget.begin(), vtarget.end(), myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：merge合并的两个容器必须的有序序列 5.3.4 reverse功能描述： 将容器内元素进行反转 函数原型： reverse(iterator beg, iterator end); &#x2F;&#x2F; 反转指定范围的元素 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl; reverse(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：reverse反转区间内元素，面试题可能涉及到 5.4 常用拷贝和替换算法学习目标： 掌握常用的拷贝和替换算法 算法简介： copy &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中 replace &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素 replace_if &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素 swap &#x2F;&#x2F; 互换两个容器的元素 5.4.1 copy功能描述： 容器内指定范围的元素拷贝到另一容器中 函数原型： copy(iterator beg, iterator end, iterator dest); &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; dest 目标起始迭代器 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i + 1); &#125; vector&lt;int&gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：利用copy算法在拷贝时，目标容器记得提前开辟空间 5.4.2 replace功能描述： 将容器内指定范围的旧元素修改为新元素 函数原型： replace(iterator beg, iterator end, oldvalue, newvalue); &#x2F;&#x2F; 将区间内旧元素 替换成 新元素 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; oldvalue 旧元素 &#x2F;&#x2F; newvalue 新元素 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中的20 替换成 2000 cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl; replace(v.begin(), v.end(), 20,2000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：replace会替换区间内满足条件的元素 5.4.3 replace_if功能描述: 将区间内满足条件的元素，替换成指定元素 函数原型： replace_if(iterator beg, iterator end, _pred, newvalue); &#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; _pred 谓词 &#x2F;&#x2F; newvalue 替换的新元素 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; class ReplaceGreater30 &#123; public: bool operator()(int val) &#123; return val &gt;= 30; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中大于等于的30 替换成 3000 cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl; replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件 5.4.4 swap功能描述： 互换两个容器的元素 函数原型： swap(container c1, container c2); &#x2F;&#x2F; 互换两个容器的元素 &#x2F;&#x2F; c1容器1 &#x2F;&#x2F; c2容器2 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+100); &#125; cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl; swap(v1, v2); for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：swap交换容器时，注意交换的容器要同种类型 5.5 常用算术生成算法学习目标： 掌握常用的算术生成算法 注意： 算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt; 算法简介： accumulate &#x2F;&#x2F; 计算容器元素累计总和 fill &#x2F;&#x2F; 向容器中添加元素 5.5.1 accumulate功能描述： 计算区间内 容器元素累计总和 函数原型： accumulate(iterator beg, iterator end, value); &#x2F;&#x2F; 计算容器元素累计总和 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; value 起始值 示例： #include &lt;numeric&gt; #include &lt;vector&gt; void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt;= 100; i++) &#123; v.push_back(i); &#125; int total = accumulate(v.begin(), v.end(), 0); cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：accumulate使用时头文件注意是 numeric，这个算法很实用 5.5.2 fill功能描述： 向容器中填充指定的元素 函数原型： fill(iterator beg, iterator end, value); &#x2F;&#x2F; 向容器中填充元素 &#x2F;&#x2F; beg 开始迭代器 &#x2F;&#x2F; end 结束迭代器 &#x2F;&#x2F; value 填充的值 示例： #include &lt;numeric&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v; v.resize(10); //填充 fill(v.begin(), v.end(), 100); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：利用fill可以将容器区间内元素填充为 指定的值 5.6 常用集合算法学习目标： 掌握常用的集合算法 算法简介： set_intersection &#x2F;&#x2F; 求两个容器的交集 set_union &#x2F;&#x2F; 求两个容器的并集 set_difference &#x2F;&#x2F; 求两个容器的差集 5.6.1 set_intersection功能描述： 求两个容器的交集 函数原型： set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); &#x2F;&#x2F; 求两个集合的交集 &#x2F;&#x2F; 注意:两个集合必须是有序序列 &#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器 示例： #include &lt;vector&gt; #include &lt;algorithm&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个里面较小的值给目标容器开辟空间 vTarget.resize(min(v1.size(), v2.size())); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 求交集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器中取小值 set_intersection返回值既是交集中最后一个元素的位置 5.6.2 set_union功能描述： 求两个集合的并集 函数原型： set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); &#x2F;&#x2F; 求两个集合的并集 &#x2F;&#x2F; 注意:两个集合必须是有序序列 &#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器 示例： #include &lt;vector&gt; #include &lt;algorithm&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个容器的和给目标容器开辟空间 vTarget.resize(v1.size() + v2.size()); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 求并集的两个集合必须的有序序列 目标容器开辟空间需要两个容器相加 set_union返回值既是并集中最后一个元素的位置 5.6.3 set_difference功能描述： 求两个集合的差集 函数原型： set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); &#x2F;&#x2F; 求两个集合的差集 &#x2F;&#x2F; 注意:两个集合必须是有序序列 &#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器 示例： #include &lt;vector&gt; #include &lt;algorithm&gt; class myPrint &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#125;; void test01() &#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个里面较大的值给目标容器开辟空间 vTarget.resize( max(v1.size() , v2.size())); //返回目标容器的最后一个元素的迭代器地址 cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl; vector&lt;int&gt;::iterator itEnd = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl; itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 求差集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器取较大值 set_difference返回值既是差集中最后一个元素的位置","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++ 核心编程","slug":"03 【编程学习】/C++核心编程","date":"2019-01-17T03:00:11.654Z","updated":"2024-09-22T15:41:25.740Z","comments":true,"path":"2019/01/17/03 【编程学习】/C++核心编程/","link":"","permalink":"http://example.com/2019/01/17/03%20%E3%80%90%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/","excerpt":"","text":"C++核心编程本阶段主要针对C++&#x3D;&#x3D;面向对象&#x3D;&#x3D;编程技术做详细讲解，探讨C++中的核心和精髓。 1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义： 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程 1.1 程序运行前​ 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 ​ 代码区： ​ 存放 CPU 执行的机器指令 ​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 ​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 ​ 全局区： ​ 全局变量和静态变量存放在此. ​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ​ &#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;. 示例： //全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() &#123; //局部变量 int a = 10; int b = 10; //打印地址 cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt; (int)&amp;g_b &lt;&lt; endl; //静态变量 static int s_a = 10; static int s_b = 10; cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 打印结果： 总结： C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量 1.2 程序运行后​ 栈区： ​ 由编译器自动分配释放, 存放函数的参数值,局部变量等 ​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 示例： int * func() &#123; int a = 10; return &amp;a; &#125; int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; ​ 堆区： ​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 ​ 在C++中主要利用new在堆区开辟内存 示例： int* func() &#123; int* a = new int(10); return a; &#125; int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结： 堆区数据由程序员管理开辟和释放 堆区数据利用new关键字进行开辟内存 1.3 new操作符​ C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据 ​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D; ​ 语法： new 数据类型 ​ 利用new创建的数据，会返回该数据对应的类型的指针 示例1： 基本语法 int* func() &#123; int* a = new int(10); return a; &#125; int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; //利用delete释放堆区数据 delete p; //cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问 system(&quot;pause&quot;); return 0; &#125; 示例2：开辟数组 //堆区开辟数组 int main() &#123; int* arr = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = i + 100; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; //释放数组 delete 后加 [] delete[] arr; system(&quot;pause&quot;); return 0; &#125; 2 引用2.1 引用的基本使用**作用： **给变量起别名 语法： 数据类型 &amp;别名 = 原名 示例： int main() &#123; int a = 10; int &amp;b = a; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; b = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 2.2 引用注意事项 引用必须初始化 引用在初始化后，不可以改变 示例： int main() &#123; int a = 10; int b = 20; //int &amp;c; //错误，引用必须初始化 int &amp;c = a; //一旦初始化后，就不可以更改 c = b; //这是赋值操作，不是更改引用 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 示例： //1. 值传递 void mySwap01(int a, int b) &#123; int temp = a; a = b; b = temp; &#125; //2. 地址传递 void mySwap02(int* a, int* b) &#123; int temp = *a; *a = *b; *b = temp; &#125; //3. 引用传递 void mySwap03(int&amp; a, int&amp; b) &#123; int temp = a; a = b; b = temp; &#125; int main() &#123; int a = 10; int b = 20; mySwap01(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap02(&amp;a, &amp;b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap03(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单 2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 示例： //返回局部变量引用 int&amp; test01() &#123; int a = 10; //局部变量 return a; &#125; //返回静态变量引用 int&amp; test02() &#123; static int a = 20; return a; &#125; int main() &#123; //不能返回局部变量的引用 int&amp; ref = test01(); cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; //如果函数做左值，那么必须返回引用 int&amp; ref2 = test02(); cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; test02() = 1000; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; ​ 2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量. 讲解示例： //发现是引用，转换为 int* const ref = &amp;a; void func(int&amp; ref)&#123; ref = 100; // ref是引用，转换为*ref = 100 &#125; int main()&#123; int a = 10; //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl; func(a); return 0; &#125; 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了 2.6 常量引用作用：常量引用主要用来修饰形参，防止误操作 在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参 示例： //引用使用的场景，通常用来修饰形参 void showValue(const int&amp; v) &#123; //v += 10; cout &lt;&lt; v &lt;&lt; endl; &#125; int main() &#123; //int&amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 //加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp; const int&amp; ref = 10; //ref = 100; //加入const后不可以修改变量 cout &lt;&lt; ref &lt;&lt; endl; //函数中利用常量引用防止误操作修改实参 int a = 10; showValue(a); system(&quot;pause&quot;); return 0; &#125; 3 函数提高3.1 函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。 语法： 返回值类型 函数名 （参数= 默认值）&#123;&#125; 示例： int func(int a, int b = 10, int c = 10) &#123; return a + b + c; &#125; //1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值 //2. 如果函数声明有默认值，函数实现的时候就不能有默认参数 int func2(int a = 10, int b = 10); int func2(int a, int b) &#123; return a + b; &#125; int main() &#123; cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl; cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 3.2 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 语法： 返回值类型 函数名 (数据类型)&#123;&#125; 在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术 示例： //函数占位参数 ，占位参数也可以有默认参数 void func(int a, int) &#123; cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl; &#125; int main() &#123; func(10,10); //占位参数必须填补 system(&quot;pause&quot;); return 0; &#125; 3.3 函数重载3.3.1 函数重载概述作用：函数名可以相同，提高复用性 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同 注意: 函数的返回值不可以作为函数重载的条件 示例： //函数重载需要函数都在同一个作用域下 void func() &#123; cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl; &#125; void func(double a) &#123; cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl; &#125; void func(int a ,double b) &#123; cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl; &#125; void func(double a ,int b) &#123; cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl; &#125; //函数返回值不可以作为函数重载条件 //int func(double a, int b) //&#123; // cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl; //&#125; int main() &#123; func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); system(&quot;pause&quot;); return 0; &#125; 3.3.2 函数重载注意事项 引用作为重载条件 函数重载碰到函数默认参数 示例： //函数重载注意事项 //1、引用作为重载条件 void func(int &amp;a) &#123; cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl; &#125; void func(const int &amp;a) &#123; cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl; &#125; //2、函数重载碰到函数默认参数 void func2(int a, int b = 10) &#123; cout &lt;&lt; &quot;func2(int a, int b = 10) 调用&quot; &lt;&lt; endl; &#125; void func2(int a) &#123; cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl; &#125; int main() &#123; int a = 10; func(a); //调用无const func(10);//调用有const //func2(10); //碰到默认参数产生歧义，需要避免 system(&quot;pause&quot;); return 0; &#125; 4 类和对象C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D; C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为 例如： ​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌… ​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调… ​ 具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类 4.1 封装4.1.1 封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一： ​ 在设计类的时候，属性和行为写在一起，表现事物 语法： class 类名&#123; 访问权限： 属性 / 行为 &#125;; 示例1：设计一个圆类，求圆的周长 示例代码： //圆周率 const double PI = 3.14; //1、封装的意义 //将属性和行为作为一个整体，用来表现生活中的事物 //封装一个圆类，求圆的周长 //class代表设计一个类，后面跟着的是类名 class Circle &#123; public: //访问权限 公共的权限 //属性 int m_r;//半径 //行为 //获取到圆的周长 double calculateZC() &#123; //2 * pi * r //获取圆的周长 return 2 * PI * m_r; &#125; &#125;; int main() &#123; //通过圆类，创建圆的对象 // c1就是一个具体的圆 Circle c1; c1.m_r = 10; //给圆对象的半径 进行赋值操作 //2 * pi * 10 = = 62.8 cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号 示例2代码： //学生类 class Student &#123; public: void setName(string name) &#123; m_name = name; &#125; void setID(int id) &#123; m_id = id; &#125; void showStudent() &#123; cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl; &#125; public: string m_name; int m_id; &#125;; int main() &#123; Student stu; stu.setName(&quot;德玛西亚&quot;); stu.setID(250); stu.showStudent(); system(&quot;pause&quot;); return 0; &#125; 封装意义二： 类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 protected 保护权限 private 私有权限 示例： //三种权限 //公共权限 public 类内可以访问 类外可以访问 //保护权限 protected 类内可以访问 类外不可以访问 //私有权限 private 类内可以访问 类外不可以访问 class Person &#123; //姓名 公共权限 public: string m_Name; //汽车 保护权限 protected: string m_Car; //银行卡密码 私有权限 private: int m_Password; public: void func() &#123; m_Name = &quot;张三&quot;; m_Car = &quot;拖拉机&quot;; m_Password = 123456; &#125; &#125;; int main() &#123; Person p; p.m_Name = &quot;李四&quot;; //p.m_Car = &quot;奔驰&quot;; //保护权限类外访问不到 //p.m_Password = 123; //私有权限类外访问不到 system(&quot;pause&quot;); return 0; &#125; 4.1.2 struct和class区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同 区别： struct 默认权限为公共 class 默认权限为私有 class C1 &#123; int m_A; //默认是私有权限 &#125;; struct C2 &#123; int m_A; //默认是公共权限 &#125;; int main() &#123; C1 c1; c1.m_A = 10; //错误，访问权限是私有 C2 c2; c2.m_A = 10; //正确，访问权限是公共 system(&quot;pause&quot;); return 0; &#125; 4.1.3 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限 优点2：对于写权限，我们可以检测数据的有效性 示例： class Person &#123; public: //姓名设置可读可写 void setName(string name) &#123; m_Name = name; &#125; string getName() &#123; return m_Name; &#125; //获取年龄 int getAge() &#123; return m_Age; &#125; //设置年龄 void setAge(int age) &#123; if (age &lt; 0 || age &gt; 150) &#123; cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl; return; &#125; m_Age = age; &#125; //情人设置为只写 void setLover(string lover) &#123; m_Lover = lover; &#125; private: string m_Name; //可读可写 姓名 int m_Age; //只读 年龄 string m_Lover; //只写 情人 &#125;; int main() &#123; Person p; //姓名设置 p.setName(&quot;张三&quot;); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl; //年龄设置 p.setAge(50); cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl; //情人设置 p.setLover(&quot;苍井&quot;); //cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl; //只写属性，不可以读取 system(&quot;pause&quot;); return 0; &#125; 练习案例1：设计立方体类 设计立方体类(Cube) 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等。 练习案例2：点和圆的关系 设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。 4.2 对象的初始化和清理 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。 4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 ​ 一个对象或者变量没有初始状态，对其使用后果是未知 ​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题 c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供 编译器提供的构造函数和析构函数是空实现。 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名()&#123;&#125; 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次 析构函数语法： ~类名()&#123;&#125; 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 class Person &#123; public: //构造函数 Person() &#123; cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; &#125;; void test01() &#123; Person p; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.2.2 构造函数的分类及调用两种分类方式： ​ 按参数分为： 有参构造和无参构造 ​ 按类型分为： 普通构造和拷贝构造 三种调用方式： ​ 括号法 ​ 显示法 ​ 隐式转换法 示例： //1、构造函数分类 // 按照参数分类分为 有参和无参构造 无参又称为默认构造函数 // 按照类型分类分为 普通构造和拷贝构造 class Person &#123; public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125; public: int age; &#125;; //2、构造函数的调用 //调用无参构造函数 void test01() &#123; Person p; //调用无参构造函数 &#125; //调用有参的构造函数 void test02() &#123; //2.1 括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 //Person p2(); //2.2 显式法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 //Person p5(p4); &#125; int main() &#123; test01(); //test02(); system(&quot;pause&quot;); return 0; &#125; 4.2.3 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 示例： class Person &#123; public: Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; mAge = 0; &#125; Person(int age) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; mAge = age; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; mAge = p.mAge; &#125; //析构函数在释放内存之前调用 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125; public: int mAge; &#125;; //1. 使用一个已经创建完毕的对象来初始化一个新对象 void test01() &#123; Person man(100); //p对象已经创建完毕 Person newman(man); //调用拷贝构造函数 Person newman2 = man; //拷贝构造 //Person newman3; //newman3 = man; //不是调用拷贝构造函数，赋值操作 &#125; //2. 值传递的方式给函数参数传值 //相当于Person p1 = p; void doWork(Person p1) &#123;&#125; void test02() &#123; Person p; //无参构造函数 doWork(p); &#125; //3. 以值方式返回局部对象 Person doWork2() &#123; Person p1; cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl; return p1; &#125; void test03() &#123; Person p = doWork2(); cout &lt;&lt; (int *)&amp;p &lt;&lt; endl; &#125; int main() &#123; //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0; &#125; 4.2.4 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数 1．默认构造函数(无参，函数体为空) 2．默认析构函数(无参，函数体为空) 3．默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造 如果用户定义拷贝构造函数，c++不会再提供其他构造函数 示例： class Person &#123; public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125; public: int age; &#125;; void test01() &#123; Person p1(18); //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 Person p2(p1); cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl; &#125; void test02() &#123; //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 Person p1; //此时如果用户自己没有提供默认构造，会出错 Person p2(10); //用户提供的有参 Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供 //如果用户提供拷贝构造，编译器不会提供其他构造函数 Person p4; //此时如果用户自己没有提供默认构造，会出错 Person p5(10); //此时如果用户自己没有提供有参，会出错 Person p6(p5); //用户自己提供拷贝构造 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.2.5 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 示例： class Person &#123; public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int age ,int height) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; m_age = age; m_height = new int(height); &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age = p.m_age; m_height = new int(*p.m_height); &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; if (m_height != NULL) &#123; delete m_height; &#125; &#125; public: int m_age; int* m_height; &#125;; void test01() &#123; Person p1(18, 180); Person p2(p1); cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 4.2.6 初始化列表作用： C++提供了初始化列表语法，用来初始化属性 语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125; 示例： class Person &#123; public: ////传统方式初始化 //Person(int a, int b, int c) &#123; // m_A = a; // m_B = b; // m_C = c; //&#125; //初始化列表方式初始化 Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125; void PrintPerson() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl; cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl; cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl; &#125; private: int m_A; int m_B; int m_C; &#125;; int main() &#123; Person p(1, 2, 3); p.PrintPerson(); system(&quot;pause&quot;); return 0; &#125; 4.2.7 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员 例如： class A &#123;&#125; class B &#123; A a； &#125; B类中有对象A作为成员，A为对象成员 那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？ 示例： class Phone &#123; public: Phone(string name) &#123; m_PhoneName = name; cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl; &#125; ~Phone() &#123; cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl; &#125; string m_PhoneName; &#125;; class Person &#123; public: //初始化列表可以告诉编译器调用哪一个构造函数 Person(string name, string pName) :m_Name(name), m_Phone(pName) &#123; cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl; &#125; void playGame() &#123; cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl; &#125; string m_Name; Phone m_Phone; &#125;; void test01() &#123; //当类中成员是其他类对象时，我们称该成员为 对象成员 //构造的顺序是 ：先调用对象成员的构造，再调用本类构造 //析构顺序与构造相反 Person p(&quot;张三&quot; , &quot;苹果X&quot;); p.playGame(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： 静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 示例1 ：静态成员变量 class Person &#123; public: static int m_A; //静态成员变量 //静态成员变量特点： //1 在编译阶段分配内存 //2 类内声明，类外初始化 //3 所有对象共享同一份数据 private: static int m_B; //静态成员变量也是有访问权限的 &#125;; int Person::m_A = 10; int Person::m_B = 10; void test01() &#123; //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.m_A = 100; cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; Person p2; p2.m_A = 200; cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据 cout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl; //2、通过类名 cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl; //cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 示例2：静态成员函数 class Person &#123; public: //静态成员函数特点： //1 程序共享一个函数 //2 静态成员函数只能访问静态成员变量 static void func() &#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量 &#125; static int m_A; //静态成员变量 int m_B; // private: //静态成员函数也是有访问权限的 static void func2() &#123; cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl; &#125; &#125;; int Person::m_A = 10; void test01() &#123; //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.func(); //2、通过类名 Person::func(); //Person::func2(); //私有权限访问不到 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 class Person &#123; public: Person() &#123; mA = 0; &#125; //非静态成员变量占对象空间 int mA; //静态成员变量不占对象空间 static int mB; //函数也不占对象空间，所有函数共享一个函数实例 void func() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl; &#125; //静态成员函数也不占对象空间 static void sfunc() &#123; &#125; &#125;; int main() &#123; cout &lt;&lt; sizeof(Person) &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 4.3.2 this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this class Person &#123; public: Person(int age) &#123; //1、当形参和成员变量同名时，可用this指针来区分 this-&gt;age = age; &#125; Person&amp; PersonAddPerson(Person p) &#123; this-&gt;age += p.age; //返回对象本身 return *this; &#125; int age; &#125;; void test01() &#123; Person p1(10); cout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.3.3 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 示例： //空指针访问成员函数 class Person &#123; public: void ShowClassName() &#123; cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl; &#125; void ShowPerson() &#123; if (this == NULL) &#123; return; &#125; cout &lt;&lt; mAge &lt;&lt; endl; &#125; public: int mAge; &#125;; void test01() &#123; Person * p = NULL; p-&gt;ShowClassName(); //空指针，可以调用成员函数 p-&gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.3.4 const修饰成员函数常函数： 成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 示例： class Person &#123; public: Person() &#123; m_A = 0; m_B = 0; &#125; //this指针的本质是一个指针常量，指针的指向不可修改 //如果想让指针指向的值也不可以修改，需要声明常函数 void ShowPerson() const &#123; //const Type* const pointer; //this = NULL; //不能修改指针的指向 Person* const this; //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-&gt;m_B = 100; &#125; void MyFunc() const &#123; //mA = 10000; &#125; public: int m_A; mutable int m_B; //可修改 可变的 &#125;; //const修饰对象 常对象 void test01() &#123; const Person person; //常量对象 cout &lt;&lt; person.m_A &lt;&lt; endl; //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 person.m_B = 100; //但是常对象可以修改mutable修饰成员变量 //常对象访问成员函数 person.MyFunc(); //常对象不能调用const的函数 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.4 友元生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类 访问另一个类中私有成员 友元的关键字为 &#x3D;&#x3D;friend&#x3D;&#x3D; 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 4.4.1 全局函数做友元class Building &#123; //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 friend void goodGay(Building * building); public: Building() &#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;; &#125; public: string m_SittingRoom; //客厅 private: string m_BedRoom; //卧室 &#125;; void goodGay(Building * building) &#123; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; &#125; void test01() &#123; Building b; goodGay(&amp;b); &#125; int main()&#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.4.2 类做友元class Building; class goodGay &#123; public: goodGay(); void visit(); private: Building *building; &#125;; class Building &#123; //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 friend class goodGay; public: Building(); public: string m_SittingRoom; //客厅 private: string m_BedRoom;//卧室 &#125;; Building::Building() &#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;; &#125; goodGay::goodGay() &#123; building = new Building; &#125; void goodGay::visit() &#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; &#125; void test01() &#123; goodGay gg; gg.visit(); &#125; int main()&#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.4.3 成员函数做友元 class Building; class goodGay &#123; public: goodGay(); void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 void visit2(); private: Building *building; &#125;; class Building &#123; //告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 friend void goodGay::visit(); public: Building(); public: string m_SittingRoom; //客厅 private: string m_BedRoom;//卧室 &#125;; Building::Building() &#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;; &#125; goodGay::goodGay() &#123; building = new Building; &#125; void goodGay::visit() &#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; &#125; void goodGay::visit2() &#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; &#125; void test01() &#123; goodGay gg; gg.visit(); &#125; int main()&#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算 class Person &#123; public: Person() &#123;&#125;; Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数实现 + 号运算符重载 Person operator+(const Person&amp; p) &#123; Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; &#125; public: int m_A; int m_B; &#125;; //全局函数实现 + 号运算符重载 //Person operator+(const Person&amp; p1, const Person&amp; p2) &#123; // Person temp(0, 0); // temp.m_A = p1.m_A + p2.m_A; // temp.m_B = p1.m_B + p2.m_B; // return temp; //&#125; //运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val) &#123; Person temp; temp.m_A = p2.m_A + val; temp.m_B = p2.m_B + val; return temp; &#125; void test() &#123; Person p1(10, 10); Person p2(20, 20); //成员函数方式 Person p3 = p2 + p1; //相当于 p2.operaor+(p1) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl; Person p4 = p3 + 10; //相当于 operator+(p3,10) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl; &#125; int main() &#123; test(); system(&quot;pause&quot;); return 0; &#125; 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的 总结2：不要滥用运算符重载 4.5.2 左移运算符重载作用：可以输出自定义数据类型 class Person &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p); public: Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果 //void operator&lt;&lt;(Person&amp; p)&#123; //&#125; private: int m_A; int m_B; &#125;; //全局函数实现左移重载 //ostream对象只能有一个 ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123; out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B; return out; &#125; void test() &#123; Person p1(10, 20); cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程 &#125; int main() &#123; test(); system(&quot;pause&quot;); return 0; &#125; 总结：重载左移运算符配合友元可以实现输出自定义数据类型 4.5.3 递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据 class MyInteger &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint); public: MyInteger() &#123; m_Num = 0; &#125; //前置++ MyInteger&amp; operator++() &#123; //先++ m_Num++; //再返回 return *this; &#125; //后置++ MyInteger operator++(int) &#123; //先返回 MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp; &#125; private: int m_Num; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123; out &lt;&lt; myint.m_Num; return out; &#125; //前置++ 先++ 再返回 void test01() &#123; MyInteger myInt; cout &lt;&lt; ++myInt &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl; &#125; //后置++ 先返回 再++ void test02() &#123; MyInteger myInt; cout &lt;&lt; myInt++ &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl; &#125; int main() &#123; test01(); //test02(); system(&quot;pause&quot;); return 0; &#125; 总结： 前置递增返回引用，后置递增返回值 4.5.4 赋值运算符重载c++编译器至少给一个类添加4个函数 默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator&#x3D;, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 示例： class Person &#123; public: Person(int age) &#123; //将年龄数据开辟到堆区 m_Age = new int(age); &#125; //重载赋值运算符 Person&amp; operator=(Person &amp;p) &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; //编译器提供的代码是浅拷贝 //m_Age = p.m_Age; //提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); //返回自身 return *this; &#125; ~Person() &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; &#125; //年龄的指针 int *m_Age; &#125;; void test01() &#123; Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作 cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl; &#125; int main() &#123; test01(); //int a = 10; //int b = 20; //int c = 30; //c = b = a; //cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; //cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 4.5.5 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 示例： class Person &#123; public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;; bool operator==(Person &amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; bool operator!=(Person &amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return false; &#125; else &#123; return true; &#125; &#125; string m_Name; int m_Age; &#125;; void test01() &#123; //int a = 0; //int b = 0; Person a(&quot;孙悟空&quot;, 18); Person b(&quot;孙悟空&quot;, 18); if (a == b) &#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; &#125; if (a != b) &#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.5.6 函数调用运算符重载 函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 示例： class MyPrint &#123; public: void operator()(string text) &#123; cout &lt;&lt; text &lt;&lt; endl; &#125; &#125;; void test01() &#123; //重载的（）操作符 也称为仿函数 MyPrint myFunc; myFunc(&quot;hello world&quot;); &#125; class MyAdd &#123; public: int operator()(int v1, int v2) &#123; return v1 + v2; &#125; &#125;; void test02() &#123; MyAdd add; int ret = add(10, 10); cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl; //匿名对象调用 cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl; &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 4.6 继承继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，例如下图中： 我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 这个时候我们就可以考虑利用继承的技术，减少重复代码 4.6.1 继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 普通实现： //Java页面 class Java &#123; public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; &#125; &#125;; //Python页面 class Python &#123; public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125; &#125;; //C++页面 class CPP &#123; public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125; &#125;; void test01() &#123; //Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //C++页面 cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 继承实现： //公共页面 class BasePage &#123; public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; &#125;; //Java页面 class Java : public BasePage &#123; public: void content() &#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; &#125; &#125;; //Python页面 class Python : public BasePage &#123; public: void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125; &#125;; //C++页面 class CPP : public BasePage &#123; public: void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125; &#125;; void test01() &#123; //Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //C++页面 cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D; class A : public B; A 类称为子类 或 派生类 B 类称为父类 或 基类 派生类中的成员，包含两大部分： 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过过来的表现其共性，而新增的成员体现了其个性。 4.6.2 继承方式继承的语法：class 子类 : 继承方式 父类 继承方式一共有三种： 公共继承 保护继承 私有继承 示例： class Base1 &#123; public: int m_A; protected: int m_B; private: int m_C; &#125;; //公共继承 class Son1 :public Base1 &#123; public: void func() &#123; m_A; //可访问 public权限 m_B; //可访问 protected权限 //m_C; //不可访问 &#125; &#125;; void myClass() &#123; Son1 s1; s1.m_A; //其他类只能访问到公共权限 &#125; //保护继承 class Base2 &#123; public: int m_A; protected: int m_B; private: int m_C; &#125;; class Son2:protected Base2 &#123; public: void func() &#123; m_A; //可访问 protected权限 m_B; //可访问 protected权限 //m_C; //不可访问 &#125; &#125;; void myClass2() &#123; Son2 s; //s.m_A; //不可访问 &#125; //私有继承 class Base3 &#123; public: int m_A; protected: int m_B; private: int m_C; &#125;; class Son3:private Base3 &#123; public: void func() &#123; m_A; //可访问 private权限 m_B; //可访问 private权限 //m_C; //不可访问 &#125; &#125;; class GrandSon3 :public Son3 &#123; public: void func() &#123; //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 //m_A; //m_B; //m_C; &#125; &#125;; 4.6.3 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？ 示例： class Base &#123; public: int m_A; protected: int m_B; private: int m_C; //私有成员只是被隐藏了，但是还是会继承下去 &#125;; //公共继承 class Son :public Base &#123; public: int m_D; &#125;; void test01() &#123; cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 利用工具查看： 打开工具窗口后，定位到当前CPP文件的盘符 然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名 所属文件名 效果如下图： 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到 4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 问题：父类和子类的构造和析构顺序是谁先谁后？ 示例： class Base &#123; public: Base() &#123; cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl; &#125; &#125;; class Son : public Base &#123; public: Son() &#123; cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl; &#125; &#125;; void test01() &#123; //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 Son s; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 4.6.5 继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： class Base &#123; public: Base() &#123; m_A = 100; &#125; void func() &#123; cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl; &#125; public: int m_A; &#125;; class Son : public Base &#123; public: Son() &#123; m_A = 200; &#125; //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 void func() &#123; cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl; &#125; public: int m_A; &#125;; void test01() &#123; Son s; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; s.func(); s.Base::func(); s.Base::func(10); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return EXIT_SUCCESS; &#125; 总结： 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数 4.6.6 继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？ 静态成员和非静态成员出现同名，处理方式一致 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： class Base &#123; public: static void func() &#123; cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl; &#125; static void func(int a) &#123; cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl; &#125; static int m_A; &#125;; int Base::m_A = 100; class Son : public Base &#123; public: static void func() &#123; cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl; &#125; static int m_A; &#125;; int Son::m_A = 200; //同名成员属性 void test01() &#123; //通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; cout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; //通过类名访问 cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl; &#125; //同名成员函数 void test02() &#123; //通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; s.func(); s.Base::func(); cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; Son::func(); Son::Base::func(); //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 Son::Base::func(100); &#125; int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名） 4.6.7 多继承语法C++允许一个类继承多个类 语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2... 多继承可能会引发父类中有同名成员出现，需要加作用域区分 C++实际开发中不建议用多继承 示例： class Base1 &#123; public: Base1() &#123; m_A = 100; &#125; public: int m_A; &#125;; class Base2 &#123; public: Base2() &#123; m_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确 &#125; public: int m_A; &#125;; //语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 &#123; public: Son() &#123; m_C = 300; m_D = 400; &#125; public: int m_C; int m_D; &#125;; //多继承容易产生成员同名的情况 //通过使用类名作用域可以区分调用哪一个基类的成员 void test01() &#123; Son s; cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; s.Base2::m_A &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域 4.6.8 菱形继承菱形继承概念： ​ 两个派生类继承同一个基类 ​ 又有某个类同时继承者两个派生类 ​ 这种继承被称为菱形继承，或者钻石继承 典型的菱形继承案例： 菱形继承问题： 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。 示例： class Animal &#123; public: int m_Age; &#125;; //继承前加virtual关键字后，变为虚继承 //此时公共的父类Animal称为虚基类 class Sheep : virtual public Animal &#123;&#125;; class Tuo : virtual public Animal &#123;&#125;; class SheepTuo : public Sheep, public Tuo &#123;&#125;; void test01() &#123; SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 4.7 多态4.7.1 多态的基本概念多态是C++面向对象三大特性之一 多态分为两类 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别： 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 下面通过案例进行讲解多态 class Animal &#123; public: //Speak函数就是虚函数 //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125; &#125;; class Cat :public Animal &#123; public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125; &#125;; class Dog :public Animal &#123; public: void speak() &#123; cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl; &#125; &#125;; //我们希望传入什么对象，那么就调用什么对象的函数 //如果函数地址在编译阶段就能确定，那么静态联编 //如果函数地址在运行阶段才能确定，就是动态联编 void DoSpeak(Animal &amp; animal) &#123; animal.speak(); &#125; // //多态满足条件： //1、有继承关系 //2、子类重写父类中的虚函数 //多态使用： //父类指针或引用指向子类对象 void test01() &#123; Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 多态满足条件 有继承关系 子类重写父类中的虚函数 多态使用条件 父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 4.7.2 多态案例一-计算器类案例描述： 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类 多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 示例： //普通实现 class Calculator &#123; public: int getResult(string oper) &#123; if (oper == &quot;+&quot;) &#123; return m_Num1 + m_Num2; &#125; else if (oper == &quot;-&quot;) &#123; return m_Num1 - m_Num2; &#125; else if (oper == &quot;*&quot;) &#123; return m_Num1 * m_Num2; &#125; //如果要提供新的运算，需要修改源码 &#125; public: int m_Num1; int m_Num2; &#125;; void test01() &#123; //普通实现测试 Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl; &#125; //多态实现 //抽象计算器类 //多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护 class AbstractCalculator &#123; public : virtual int getResult() &#123; return 0; &#125; int m_Num1; int m_Num2; &#125;; //加法计算器 class AddCalculator :public AbstractCalculator &#123; public: int getResult() &#123; return m_Num1 + m_Num2; &#125; &#125;; //减法计算器 class SubCalculator :public AbstractCalculator &#123; public: int getResult() &#123; return m_Num1 - m_Num2; &#125; &#125;; //乘法计算器 class MulCalculator :public AbstractCalculator &#123; public: int getResult() &#123; return m_Num1 * m_Num2; &#125; &#125;; void test02() &#123; //创建加法计算器 AbstractCalculator *abc = new AddCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //用完了记得销毁 //创建减法计算器 abc = new SubCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //创建乘法计算器 abc = new MulCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; &#125; int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多 4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ; 当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D; 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 示例： class Base &#123; public: //纯虚函数 //类中只要有一个纯虚函数就称为抽象类 //抽象类无法实例化对象 //子类必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0; &#125;; class Son :public Base &#123; public: virtual void func() &#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; &#125;; &#125;; void test01() &#123; Base * base = NULL; //base = new Base; // 错误，抽象类无法实例化对象 base = new Son; base-&gt;func(); delete base;//记得销毁 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.7.4 多态案例二-制作饮品案例描述： 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 示例： //抽象制作饮品 class AbstractDrinking &#123; public: //烧水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //规定流程 void MakeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething(); &#125; &#125;; //制作咖啡 class Coffee : public AbstractDrinking &#123; public: //烧水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl; &#125; &#125;; //制作茶水 class Tea : public AbstractDrinking &#123; public: //烧水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl; &#125; &#125;; //业务函数 void DoWork(AbstractDrinking* drink) &#123; drink-&gt;MakeDrink(); delete drink; &#125; void test01() &#123; DoWork(new Coffee); cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl; DoWork(new Tea); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名()&#123;&#125; 纯虚析构语法： virtual ~类名() = 0; 类名::~类名()&#123;&#125; 示例： class Animal &#123; public: Animal() &#123; cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl; &#125; virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 //virtual ~Animal() //&#123; // cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl; //&#125; virtual ~Animal() = 0; &#125;; Animal::~Animal() &#123; cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl; &#125; //和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。 class Cat : public Animal &#123; public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void Speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话!&quot; &lt;&lt; endl; &#125; ~Cat() &#123; cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl; if (this-&gt;m_Name != NULL) &#123; delete m_Name; m_Name = NULL; &#125; &#125; public: string *m_Name; &#125;; void test01() &#123; Animal *animal = new Cat(&quot;Tom&quot;); animal-&gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 //怎么解决？给基类增加一个虚析构函数 //虚析构函数就是用来解决通过父类指针释放子类对象 delete animal; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： ​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 ​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 ​ 3. 拥有纯虚析构函数的类也属于抽象类 4.7.6 多态案例三-电脑组装案例描述： 电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储） 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 测试时组装三台不同的电脑进行工作 示例： #include&lt;iostream&gt; using namespace std; //抽象CPU类 class CPU &#123; public: //抽象的计算函数 virtual void calculate() = 0; &#125;; //抽象显卡类 class VideoCard &#123; public: //抽象的显示函数 virtual void display() = 0; &#125;; //抽象内存条类 class Memory &#123; public: //抽象的存储函数 virtual void storage() = 0; &#125;; //电脑类 class Computer &#123; public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) &#123; m_cpu = cpu; m_vc = vc; m_mem = mem; &#125; //提供工作的函数 void work() &#123; //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125; //提供析构函数 释放3个电脑零件 ~Computer() &#123; //释放CPU零件 if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; //释放显卡零件 if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; //释放内存条零件 if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125; &#125; private: CPU * m_cpu; //CPU的零件指针 VideoCard * m_vc; //显卡零件指针 Memory * m_mem; //内存条零件指针 &#125;; //具体厂商 //Intel厂商 class IntelCPU :public CPU &#123; public: virtual void calculate() &#123; cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl; &#125; &#125;; class IntelVideoCard :public VideoCard &#123; public: virtual void display() &#123; cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl; &#125; &#125;; class IntelMemory :public Memory &#123; public: virtual void storage() &#123; cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl; &#125; &#125;; //Lenovo厂商 class LenovoCPU :public CPU &#123; public: virtual void calculate() &#123; cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl; &#125; &#125;; class LenovoVideoCard :public VideoCard &#123; public: virtual void display() &#123; cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl; &#125; &#125;; class LenovoMemory :public Memory &#123; public: virtual void storage() &#123; cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl; &#125; &#125;; void test01() &#123; //第一台电脑零件 CPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-&gt;work(); delete computer1; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl; //第二台电脑组装 Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-&gt;work(); delete computer2; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl; //第三台电脑组装 Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-&gt;work(); delete computer3; &#125; 5 文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D; 文件类型分为两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: ofstream：写操作 ifstream： 读操作 fstream ： 读写操作 5.1文本文件5.1.1写文件 写文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ofstream ofs; 打开文件 ofs.open(“文件路径”,打开方式); 写数据 ofs &lt;&lt; “写入的数据”; 关闭文件 ofs.close(); 文件打开方式： 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意： 文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios:: out 示例： #include &lt;fstream&gt; void test01() &#123; ofstream ofs; ofs.open(&quot;test.txt&quot;, ios::out); ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl; ofs.close(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 5.1.2读文件读文件与写文件步骤相似，但是读取方式相对于比较多 读文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ifstream ifs; 打开文件并判断文件是否打开成功 ifs.open(“文件路径”,打开方式); 读数据 四种方式读取 关闭文件 ifs.close(); 示例： #include &lt;fstream&gt; #include &lt;string&gt; void test01() &#123; ifstream ifs; ifs.open(&quot;test.txt&quot;, ios::in); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; &#125; //第一种方式 //char buf[1024] = &#123; 0 &#125;; //while (ifs &gt;&gt; buf) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第二种 //char buf[1024] = &#123; 0 &#125;; //while (ifs.getline(buf,sizeof(buf))) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第三种 //string buf; //while (getline(ifs, buf)) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; char c; while ((c = ifs.get()) != EOF) &#123; cout &lt;&lt; c; &#125; ifs.close(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件 5.2 二进制文件以二进制的方式对文件进行读写操作 打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D; 5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write 函数原型 ：ostream&amp; write(const char * buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： #include &lt;fstream&gt; #include &lt;string&gt; class Person &#123; public: char m_Name[64]; int m_Age; &#125;; //二进制文件 写文件 void test01() &#123; //1、包含头文件 //2、创建输出流对象 ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary); //3、打开文件 //ofs.open(&quot;person.txt&quot;, ios::out | ios::binary); Person p = &#123;&quot;张三&quot; , 18&#125;; //4、写文件 ofs.write((const char *)&amp;p, sizeof(p)); //5、关闭文件 ofs.close(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 文件输出流对象 可以通过write函数，以二进制方式写数据 5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read 函数原型：istream&amp; read(char *buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： #include &lt;fstream&gt; #include &lt;string&gt; class Person &#123; public: char m_Name[64]; int m_Age; &#125;; void test01() &#123; ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; &#125; Person p; ifs.read((char *)&amp;p, sizeof(p)); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 文件输入流对象 可以通过read函数，以二进制方式读数据","categories":[{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"编程学习","slug":"编程学习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"速查手册","slug":"速查手册","permalink":"http://example.com/categories/%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"},{"name":"工作日志","slug":"工作日志","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"机器视觉","slug":"机器视觉","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"},{"name":"blender","slug":"blender","permalink":"http://example.com/tags/blender/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"bpy","slug":"bpy","permalink":"http://example.com/tags/bpy/"},{"name":"Volantis","slug":"Volantis","permalink":"http://example.com/tags/Volantis/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"WSL","slug":"WSL","permalink":"http://example.com/tags/WSL/"},{"name":"CV","slug":"CV","permalink":"http://example.com/tags/CV/"},{"name":"Rasberry Pi","slug":"Rasberry-Pi","permalink":"http://example.com/tags/Rasberry-Pi/"},{"name":"Lenet","slug":"Lenet","permalink":"http://example.com/tags/Lenet/"},{"name":"Alexnet","slug":"Alexnet","permalink":"http://example.com/tags/Alexnet/"},{"name":"VGG","slug":"VGG","permalink":"http://example.com/tags/VGG/"},{"name":"GoogleNet","slug":"GoogleNet","permalink":"http://example.com/tags/GoogleNet/"},{"name":"ResNet","slug":"ResNet","permalink":"http://example.com/tags/ResNet/"},{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"感悟","slug":"感悟","permalink":"http://example.com/tags/%E6%84%9F%E6%82%9F/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"404实验室","slug":"404实验室","permalink":"http://example.com/tags/404%E5%AE%9E%E9%AA%8C%E5%AE%A4/"},{"name":"latex","slug":"latex","permalink":"http://example.com/tags/latex/"},{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"},{"name":"me s","slug":"me-s","permalink":"http://example.com/tags/me-s/"},{"name":"SSH","slug":"SSH","permalink":"http://example.com/tags/SSH/"},{"name":"DuckX","slug":"DuckX","permalink":"http://example.com/tags/DuckX/"},{"name":"minidocx","slug":"minidocx","permalink":"http://example.com/tags/minidocx/"},{"name":"Python-docx","slug":"Python-docx","permalink":"http://example.com/tags/Python-docx/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"Qxlnt","slug":"Qxlnt","permalink":"http://example.com/tags/Qxlnt/"},{"name":"xlnt","slug":"xlnt","permalink":"http://example.com/tags/xlnt/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Qxlsx","slug":"Qxlsx","permalink":"http://example.com/tags/Qxlsx/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"books","slug":"books","permalink":"http://example.com/tags/books/"},{"name":"json","slug":"json","permalink":"http://example.com/tags/json/"}]}